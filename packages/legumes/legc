#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));

// src/common.ts
var NOTE_LENGTH = {
  WHOLE: 64,
  HALF: 32,
  QUARTER: 16,
  EIGHTH: 8,
  SIXTEENTH: 4,
  THIRTYSECOND: 2,
  SIXTYFOURTH: 1
};
var ACCIDENTAL = {
  SHARP: 1,
  NATURAL: 0,
  FLAT: -1
};
var CLEF = {
  TREBLE: 0,
  BASS: 1,
  ALTO: 2,
  TENOR: 3,
  MEZZO_SOPRANO: 4,
  SOPRANO: 5,
  BARITONE: 6
};
var ORDER_OF_ACCIDENTALS = {
  [ACCIDENTAL.SHARP]: "FCGDAEB",
  [ACCIDENTAL.FLAT]: "BEADGCF",
  [ACCIDENTAL.NATURAL]: ""
};
var ARTICULATION = {
  STACCATO: 11,
  SPICCATO: 12,
  TENUTO: 13,
  FERMATA: 14,
  ACCENT: 15,
  MARCATO: 16,
  TREMBLEMENT: 17,
  TRILL: 18,
  MORDENT: 19,
  TURN: 20,
  UP_BOW: 21,
  FLAGEOLET: 22,
  ARPEGGIATED: 23,
  MORDENT_INV: -19,
  TURN_INV: -20
};
var CUE = {
  PEDAL_ON: "ped",
  PEDAL_OFF: "*",
  PIANISSISSIMO: "ppp",
  PIANISSIMO: "pp",
  PIANO: "p",
  MEZZO_PIANO: "mp",
  MEZZO_FORTE: "mf",
  FORTE: "f",
  FORTISSIMO: "ff",
  FORTISSISSIMO: "fff",
  SFORZANDO: "sfz"
};
var BARLINE = {
  NONE: 0,
  SINGLE: 1,
  DOUBLE: 2,
  END: 3,
  REPEAT_BEGIN: 4,
  REPEAT_END: 5,
  REPEAT_END_BEGIN: 6
};
var BRACKET = {
  NONE: 0,
  BRACE: 1,
  BRACKET: 2
};
function note_name_to_staff_pos(name, clef) {
  let base_name = name[0];
  let octave = Number(name.split("_")[1]);
  let i0 = {
    [CLEF.TREBLE]: 6 * 7 + 3,
    [CLEF.BASS]: 5 * 7 - 2,
    [CLEF.ALTO]: 6 * 7 - 3,
    [CLEF.TENOR]: 6 * 7 - 5,
    [CLEF.MEZZO_SOPRANO]: 6 * 7 - 1,
    [CLEF.SOPRANO]: 6 * 7 + 1,
    [CLEF.BARITONE]: 5 * 7
  }[clef];
  let idx = i0 - ("CDEFGAB".indexOf(base_name) + octave * 7);
  return idx;
}
function get_note_name_accidental(name) {
  return [ACCIDENTAL.FLAT, ACCIDENTAL.NATURAL, ACCIDENTAL.SHARP]["b_s".indexOf(name[1])];
}
function get_existing_voices(staff_notes, filt) {
  return Array.from(new Set(staff_notes.map((x) => x.voice))).filter(
    (x) => filt.includes(x) || !filt.length
  );
}
function short_id() {
  return "_" + String.fromCharCode(
    ...new Array(6).fill(0).map((x) => ~~(Math.random() * 26) + 65)
  );
}
function get_median_staff_pos(notes) {
  let c2p = {};
  for (let n of notes) {
    if (!c2p[n.voice]) {
      c2p[n.voice] = [];
    }
    c2p[n.voice].push(n.staff_pos);
  }
  let c2p2 = {};
  for (let k in c2p) {
    c2p[k].sort((a, b) => a - b);
    let m = ~~(c2p[k].length / 2);
    if (c2p[k].length % 2) {
      c2p2[k] = c2p[k][m];
    } else {
      c2p2[k] = (c2p[k][m - 1] + c2p[k][m]) / 2;
    }
  }
  return c2p2;
}
function chord_and_beam_staff(staff, beat_length) {
  let beam_cnt = 1;
  let notes_beam = new Array(staff.notes.length);
  let beam_info = {};
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let beam = 0;
    let chord = [];
    let stem_dir = note.stem_dir;
    let disp_dur = note.duration;
    if (note.tuplet) {
      disp_dur = note.tuplet.display_duration;
    }
    for (let j = 0; j < staff.notes.length; j++) {
      let own = note;
      let other = staff.notes[j];
      if (own.voice == other.voice && own.begin == other.begin && own.duration == other.duration) {
        chord.push([j, other]);
      }
    }
    chord.sort((a, b) => stem_dir * (a[1].staff_pos - b[1].staff_pos));
    let my_idx = chord.findIndex((x) => x[0] == i2);
    if (chord[my_idx - 1]) {
      note.prev_in_chord = chord[my_idx - 1][0];
    }
    if (chord[my_idx + 1]) {
      note.next_in_chord = chord[my_idx + 1][0];
    } else if (disp_dur < NOTE_LENGTH.QUARTER) {
      let linked = false;
      for (let j = 0; j < i2; j++) {
        let calc_consecutive = function() {
          for (let k = 0; k < i2; k++) {
            if (staff.notes[k].voice != staff.notes[i2].voice) {
              continue;
            }
            if (staff.notes[j].begin < staff.notes[k].begin && staff.notes[k].begin < staff.notes[i2].begin) {
              consecutive = false;
              break;
            }
          }
          if (consecutive) {
            for (let k = 0; k < staff.rests.length; k++) {
              if (staff.rests[k].voice != staff.notes[i2].voice) {
                continue;
              }
              if (staff.notes[j].begin < staff.rests[k].begin && staff.rests[k].begin < staff.notes[i2].begin) {
                consecutive = false;
                break;
              }
            }
          }
          if (consecutive) {
            for (let k = staff.notes[j].begin + staff.notes[j].duration; k <= staff.notes[i2].begin; k++) {
              if (staff.grace[k]) {
                consecutive = false;
                break;
              }
            }
          }
        };
        let own = staff.notes[i2];
        let other = staff.notes[j];
        let other_beam = notes_beam[j];
        let consecutive = true;
        if (other.voice != own.voice) {
          continue;
        }
        if (other.next_in_chord != null) {
          continue;
        }
        if (own.tuplet && other.tuplet && own.tuplet.id == other.tuplet.id) {
          calc_consecutive();
          if (consecutive) {
            beam = notes_beam[j];
            linked = true;
            break;
          }
        } else if (own.tuplet || other.tuplet) {
          continue;
        } else {
          calc_consecutive();
          let same_stem_dir = stem_dir == staff.notes[j].stem_dir;
          let same_beat = ~~(other.begin / beat_length) == ~~(own.begin / beat_length);
          if (other_beam != 0 && consecutive && same_stem_dir && same_beat) {
            beam = notes_beam[j];
            linked = true;
            break;
          }
        }
      }
      if (!linked) {
        beam = beam_cnt;
        beam_cnt++;
      }
    }
    notes_beam[i2] = beam;
  }
  for (let i2 = 0; i2 < staff.voices; i2++) {
    beam_info[i2] = {};
  }
  for (let b = 1; b < beam_cnt; b++) {
    let children = notes_beam.map((x, i2) => [x, i2]).filter((x) => x[0] == b).map((x) => x[1]);
    if (children.length > 1) {
      beam_info[staff.notes[children[0]].voice][b] = [];
    }
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let on_record = beam_info[staff.notes[i2].voice][notes_beam[i2]];
    let can_beam = notes_beam[i2] > 0;
    if (can_beam && !on_record) {
    } else if (on_record) {
      beam_info[staff.notes[i2].voice][notes_beam[i2]].push(i2);
    }
  }
  for (let a in beam_info) {
    for (let b in beam_info[a]) {
      staff.beams.push(beam_info[a][b]);
    }
  }
}

// src/hershey.ts
var ordR = "R".charCodeAt(0);
var custom_map = {};
var custom_scale = {};
function HERSHEY(i2) {
  if (data[i2] == null) {
    compile(i2);
  }
  return data[i2];
}
function compile(i2) {
  var entry = raw[i2];
  if (entry == null) {
    return;
  }
  var bound = entry.substring(3, 5);
  var xmin = 1 * bound.charCodeAt(0) - ordR;
  var xmax = 1 * bound.charCodeAt(1) - ordR;
  var content = entry.substring(5);
  var polylines = [[]];
  var ymin = Infinity;
  var ymax = -Infinity;
  var j = 0;
  while (j < content.length) {
    var digit = content.substring(j, j + 2);
    if (digit == " R") {
      polylines.push([]);
    } else {
      var x = digit.charCodeAt(0) - ordR;
      var y = digit.charCodeAt(1) - ordR;
      ymin = Math.min(y, ymin);
      ymax = Math.max(y, ymax);
      polylines[polylines.length - 1].push([x, y]);
    }
    j += 2;
  }
  if (custom_scale[i2]) {
    let s = custom_scale[i2];
    xmin *= s;
    xmax *= s;
    ymin *= s;
    ymax *= s;
    for (let i3 = 0; i3 < polylines.length; i3++) {
      for (let j2 = 0; j2 < polylines[i3].length; j2++) {
        polylines[i3][j2][0] *= s;
        polylines[i3][j2][1] *= s;
      }
    }
  }
  data[i2] = {
    xmin,
    xmax,
    ymin,
    ymax,
    polylines
  };
}
var FONT = {
  DUPLEX: 0,
  DUPLEX_ITALIC: 1,
  TRIPLEX: 20,
  TRIPLEX_ITALIC: 21
};
function ascii_map(x, font = FONT.DUPLEX_ITALIC) {
  let base = 2001 + font * 50;
  let c = x.charCodeAt(0);
  if (65 <= c && c <= 90) {
    return c - 65 + base;
  }
  if (97 <= c && c <= 122) {
    return c - 97 + base + 100;
  }
  if (48 <= c && c <= 57) {
    return c - 48 + base + 199;
  }
  let symb = {
    ".": 2210,
    ",": 2211,
    ":": 2212,
    ";": 2213,
    "!": 2214,
    "?": 2215,
    "'": 2216,
    '"': 2217,
    "\xB0": 2218,
    "*": 2219,
    "/": 2220,
    "(": 2221,
    ")": 2222,
    "[": 2223,
    "]": 2224,
    "{": 2225,
    "}": 2226,
    "\u27E8": 2227,
    "\u27E9": 2228,
    "|": 2229,
    "-": 2231,
    "+": 2232,
    "=": 2238,
    "<": 2241,
    ">": 2242,
    "~": 2246,
    "`": 2249,
    "\u2019": 2251,
    "\u2018": 2252,
    "\u221A": 2255,
    "\u2192": 2261,
    "%": 2271,
    "&": 2272,
    "@": 2273,
    $: 2274,
    "#": 2275
  }[x];
  if (symb) return symb;
  return custom_map[x];
}
function get_text_width(x, font = FONT.DUPLEX_ITALIC, spacing = 0) {
  let width = -spacing;
  for (let i2 = 0; i2 < x.length; i2++) {
    width += spacing;
    if (x[i2] == " ") {
      width += 10;
      continue;
    }
    let a = ascii_map(x[i2], font);
    if (a === void 0) {
      continue;
    }
    let e = HERSHEY(a);
    let w = e.xmax - e.xmin;
    width += w;
  }
  return width;
}
function register_font(map_char_to_hid, map_hid_to_data, scale = 1) {
  let cmap = {};
  if (map_char_to_hid == "unicode") {
    for (let k in map_hid_to_data) {
      cmap[String.fromCharCode(Number(k))] = Number(k);
    }
  } else {
    cmap = map_char_to_hid;
  }
  Object.assign(custom_map, cmap);
  Object.assign(raw, map_hid_to_data);
  if (scale != 1) {
    for (let k in map_hid_to_data) {
      custom_scale[k] = scale;
    }
  }
}
var data = {};
var raw = {
  2001: " 18H\\RFK[ RRFY[ RRIX[ RMUVU RI[O[ RU[[[",
  2002: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUP RUFWGXHYJYLXNWOUP RMPUPXQYRZTZWYYXZU[I[ RUPWQXRYTYWXYWZU[",
  2003: " 32G\\XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXXYV RQFOGMILKKNKSLVMXOZQ[",
  2004: " 30G]LFL[ RMFM[ RIFSFVGXIYKZNZSYVXXVZS[I[ RSFUGWIXKYNYSXVWXUZS[",
  2005: " 22G\\LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[Y[YUX[",
  2006: " 20G[LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[P[",
  2007: " 40G^XIYLYFXIVGSFQFNGLIKKJNJSKVLXNZQ[S[VZXX RQFOGMILKKNKSLVMXOZQ[ RXSX[ RYSY[ RUS\\S",
  2008: " 27F^KFK[ RLFL[ RXFX[ RYFY[ RHFOF RUF\\F RLPXP RH[O[ RU[\\[",
  2009: " 12MXRFR[ RSFS[ ROFVF RO[V[",
  2010: " 20KZUFUWTZR[P[NZMXMVNUOVNW RTFTWSZR[ RQFXF",
  2011: " 27F\\KFK[ RLFL[ RYFLS RQOY[ RPOX[ RHFOF RUF[F RH[O[ RU[[[",
  2012: " 14I[NFN[ ROFO[ RKFRF RK[Z[ZUY[",
  2013: " 30F_KFK[ RLFRX RKFR[ RYFR[ RYFY[ RZFZ[ RHFLF RYF]F RH[N[ RV[][",
  2014: " 21G^LFL[ RMFYY RMHY[ RYFY[ RIFMF RVF\\F RI[O[",
  2015: " 44G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF",
  2016: " 29G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[P[",
  2017: " 64G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF RNYNXOVQURUTVUXV_W`Y`Z^Z] RUXV\\W^X_Y_Z^",
  2018: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUPMP RUFWGXHYJYLXNWOUP RI[P[ RRPTQURXYYZZZ[Y RTQUSWZX[Z[[Y[X",
  2019: " 34H\\XIYFYLXIVGSFPFMGKIKKLMMNOOUQWRYT RKKMMONUPWQXRYTYXWZT[Q[NZLXKUK[LX",
  2020: " 16I\\RFR[ RSFS[ RLFKLKFZFZLYF RO[V[",
  2021: " 23F^KFKULXNZQ[S[VZXXYUYF RLFLUMXOZQ[ RHFOF RVF\\F",
  2022: " 15H\\KFR[ RLFRX RYFR[ RIFOF RUF[F",
  2023: " 24F^JFN[ RKFNV RRFN[ RRFV[ RSFVV RZFV[ RGFNF RWF]F",
  2024: " 21H\\KFX[ RLFY[ RYFK[ RIFOF RUF[F RI[O[ RU[[[",
  2025: " 20H]KFRQR[ RLFSQS[ RZFSQ RIFOF RVF\\F RO[V[",
  2026: " 16H\\XFK[ RYFL[ RLFKLKFYF RK[Y[YUX[",
  2027: " 18H\\RFK[ RRFY[ RRIX[ RMUVU RI[O[ RU[[[",
  2028: " 45G]LFL[ RMFM[ RIFUFXGYHZJZLYNXOUP RUFWGXHYJYLXNWOUP RMPUPXQYRZTZWYYXZU[I[ RUPWQXRYTYWXYWZU[",
  2029: " 14I[NFN[ ROFO[ RKFZFZLYF RK[R[",
  2030: " 15H\\RFJ[ RRFZ[ RRIY[ RKZYZ RJ[Z[",
  2031: " 22G\\LFL[ RMFM[ RSLST RIFYFYLXF RMPSP RI[Y[YUX[",
  2032: " 16H\\XFK[ RYFL[ RLFKLKFYF RK[Y[YUX[",
  2033: " 27F^KFK[ RLFL[ RXFX[ RYFY[ RHFOF RUF\\F RLPXP RH[O[ RU[\\[",
  2034: " 56G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF ROMOT RUMUT ROPUP ROQUQ",
  2035: " 12MXRFR[ RSFS[ ROFVF RO[V[",
  2036: " 27F\\KFK[ RLFL[ RYFLS RQOY[ RPOX[ RHFOF RUF[F RH[O[ RU[[[",
  2037: " 15H\\RFK[ RRFY[ RRIX[ RI[O[ RU[[[",
  2038: " 30F_KFK[ RLFRX RKFR[ RYFR[ RYFY[ RZFZ[ RHFLF RYF]F RH[N[ RV[][",
  2039: " 21G^LFL[ RMFYY RMHY[ RYFY[ RIFMF RVF\\F RI[O[",
  2040: " 36G]KEJJ RZEYJ RONNS RVNUS RKWJ\\ RZWY\\ RKGYG RKHYH ROPUP ROQUQ RKYYY RKZYZ",
  2041: " 44G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RQFOGMILKKOKRLVMXOZQ[ RS[UZWXXVYRYOXKWIUGSF",
  2042: " 21F^KFK[ RLFL[ RXFX[ RYFY[ RHF\\F RH[O[ RU[\\[",
  2043: " 29G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[P[",
  2044: " 20H]KFRPJ[ RJFQP RJFYFZLXF RKZXZ RJ[Y[ZUX[",
  2045: " 16I\\RFR[ RSFS[ RLFKLKFZFZLYF RO[V[",
  2046: " 33I\\KKKILGMFOFPGQIRMR[ RKIMGOGQI RZKZIYGXFVFUGTISMS[ RZIXGVGTI RO[V[",
  2047: " 48H]RFR[ RSFS[ RPKMLLMKOKRLTMUPVUVXUYTZRZOYMXLUKPK RPKNLMMLOLRMTNUPV RUVWUXTYRYOXMWLUK ROFVF RO[V[",
  2048: " 21H\\KFX[ RLFY[ RYFK[ RIFOF RUF[F RI[O[ RU[[[",
  2049: " 41G^RFR[ RSFS[ RIMJLLMMQNSOTQU RJLKMLQMSNTQUTUWTXSYQZM[L RTUVTWSXQYM[L\\M ROFVF RO[V[",
  2050: " 43G]JXK[O[MWKSJPJLKIMGPFTFWGYIZLZPYSWWU[Y[ZX RMWLTKPKLLINGPF RTFVGXIYLYPXTWW RKZNZ RVZYZ",
  2051: " 18H\\UFH[ RUFV[ RTHU[ RLUUU RF[L[ RR[X[",
  2052: " 41F^OFI[ RPFJ[ RLFWFZG[I[KZNYOVP RWFYGZIZKYNXOVP RMPVPXQYSYUXXVZR[F[ RVPWQXSXUWXUZR[",
  2053: " 34H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV RTFRGPINLMOLSLVMYNZP[",
  2054: " 30F]OFI[ RPFJ[ RLFUFXGYHZKZOYSWWUYSZO[F[ RUFWGXHYKYOXSVWTYRZO[",
  2055: " 22F]OFI[ RPFJ[ RTLRT RLF[FZLZF RMPSP RF[U[WVT[",
  2056: " 20F\\OFI[ RPFJ[ RTLRT RLF[FZLZF RMPSP RF[M[",
  2057: " 42H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT RTFRGPINLMOLSLVMYNZP[ RR[TZVXXT RUT\\T",
  2058: " 27E_NFH[ ROFI[ R[FU[ R\\FV[ RKFRF RXF_F RLPXP RE[L[ RR[Y[",
  2059: " 12LYUFO[ RVFP[ RRFYF RL[S[",
  2060: " 21I[XFSWRYQZO[M[KZJXJVKULVKW RWFRWQYO[ RTF[F",
  2061: " 27F]OFI[ RPFJ[ R]FLS RSOW[ RROV[ RLFSF RYF_F RF[M[ RS[Y[",
  2062: " 14H\\QFK[ RRFL[ RNFUF RH[W[YUV[",
  2063: " 30E`NFH[ RNFO[ ROFPY R\\FO[ R\\FV[ R]FW[ RKFOF R\\F`F RE[K[ RS[Z[",
  2064: " 21F_OFI[ ROFVX ROIV[ R\\FV[ RLFOF RYF_F RF[L[",
  2065: " 42G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF RSFQGOIMLLOKSKVLYN[ RQ[SZUXWUXRYNYKXHVF",
  2066: " 27F]OFI[ RPFJ[ RLFXF[G\\I\\K[NYPUQMQ RXFZG[I[KZNXPUQ RF[M[",
  2067: " 61G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF RSFQGOIMLLOKSKVLYN[ RQ[SZUXWUXRYNYKXHVF RLYLXMVOUPURVSXS_T`V`W^W] RSXT^U_V_W^",
  2068: " 42F^OFI[ RPFJ[ RLFWFZG[I[KZNYOVPMP RWFYGZIZKYNXOVP RRPTQURVZW[Y[ZYZX RURWYXZYZZY RF[M[",
  2069: " 35G^ZH[H\\F[L[JZHYGVFRFOGMIMKNMONVRXT RMKOMVQWRXTXWWYVZS[O[LZKYJWJUI[JYKY",
  2070: " 16H]UFO[ RVFP[ ROFLLNF]F\\L\\F RL[S[",
  2071: " 25F_NFKQJUJXKZN[R[UZWXXU\\F ROFLQKUKXLZN[ RKFRF RYF_F",
  2072: " 15H\\NFO[ ROFPY R\\FO[ RLFRF RXF^F",
  2073: " 24E_MFK[ RNFLY RUFK[ RUFS[ RVFTY R]FS[ RJFQF RZF`F",
  2074: " 21G]NFU[ ROFV[ R\\FH[ RLFRF RXF^F RF[L[ RR[X[",
  2075: " 20H]NFRPO[ ROFSPP[ R]FSP RLFRF RYF_F RL[S[",
  2076: " 16G][FH[ R\\FI[ ROFLLNF\\F RH[V[XUU[",
  2077: " 46H\\KILKXWYYY[ RLLXX RKIKKLMXYY[ RPPLTKVKXLZK[ RKVMZ RLTLVMXMZK[ RSSXN RVIVLWNYNYLWKVI RVIWLYN",
  2101: " 39I]NONPMPMONNPMTMVNWOXQXXYZZ[ RWOWXXZZ[[[ RWQVRPSMTLVLXMZP[S[UZWX RPSNTMVMXNZP[",
  2102: " 33G\\LFL[ RMFM[ RMPONQMSMVNXPYSYUXXVZS[Q[OZMX RSMUNWPXSXUWXUZS[ RIFMF",
  2103: " 28H[WPVQWRXQXPVNTMQMNNLPKSKULXNZQ[S[VZXX RQMONMPLSLUMXOZQ[",
  2104: " 36H]WFW[ RXFX[ RWPUNSMQMNNLPKSKULXNZQ[S[UZWX RQMONMPLSLUMXOZQ[ RTFXF RW[[[",
  2105: " 31H[LSXSXQWOVNTMQMNNLPKSKULXNZQ[S[VZXX RWSWPVN RQMONMPLSLUMXOZQ[",
  2106: " 22KXUGTHUIVHVGUFSFQGPIP[ RSFRGQIQ[ RMMUM RM[T[",
  2107: " 60I\\QMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM RONNPNTOV RUVVTVPUN RVOWNYMYNWN RNUMVLXLYM[P\\U\\X]Y^ RLYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[",
  2108: " 28G]LFL[ RMFM[ RMPONRMTMWNXPX[ RTMVNWPW[ RIFMF RI[P[ RT[[[",
  2109: " 18MXRFQGRHSGRF RRMR[ RSMS[ ROMSM RO[V[",
  2110: " 25MXSFRGSHTGSF RTMT_SaQbObNaN`O_P`Oa RSMS_RaQb RPMTM",
  2111: " 27G\\LFL[ RMFM[ RWMMW RRSX[ RQSW[ RIFMF RTMZM RI[P[ RT[Z[",
  2112: " 12MXRFR[ RSFS[ ROFSF RO[V[",
  2113: " 44BcGMG[ RHMH[ RHPJNMMOMRNSPS[ ROMQNRPR[ RSPUNXMZM]N^P^[ RZM\\N]P][ RDMHM RD[K[ RO[V[ RZ[a[",
  2114: " 28G]LML[ RMMM[ RMPONRMTMWNXPX[ RTMVNWPW[ RIMMM RI[P[ RT[[[",
  2115: " 36H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM RQMONMPLSLUMXOZQ[ RS[UZWXXUXSWPUNSM",
  2116: " 36G\\LMLb RMMMb RMPONQMSMVNXPYSYUXXVZS[Q[OZMX RSMUNWPXSXUWXUZS[ RIMMM RIbPb",
  2117: " 33H\\WMWb RXMXb RWPUNSMQMNNLPKSKULXNZQ[S[UZWX RQMONMPLSLUMXOZQ[ RTb[b",
  2118: " 23IZNMN[ ROMO[ ROSPPRNTMWMXNXOWPVOWN RKMOM RK[R[",
  2119: " 32J[WOXMXQWOVNTMPMNNMOMQNRPSUUWVXW RMPNQPRUTWUXVXYWZU[Q[OZNYMWM[NY",
  2120: " 16KZPFPWQZS[U[WZXX RQFQWRZS[ RMMUM",
  2121: " 28G]LMLXMZP[R[UZWX RMMMXNZP[ RWMW[ RXMX[ RIMMM RTMXM RW[[[",
  2122: " 15I[LMR[ RMMRY RXMR[ RJMPM RTMZM",
  2123: " 24F^JMN[ RKMNX RRMN[ RRMV[ RSMVX RZMV[ RGMNM RWM]M",
  2124: " 21H\\LMW[ RMMX[ RXML[ RJMPM RTMZM RJ[P[ RT[Z[",
  2125: " 22H[LMR[ RMMRY RXMR[P_NaLbKbJaK`La RJMPM RTMZM",
  2126: " 16I[WML[ RXMM[ RMMLQLMXM RL[X[XWW[",
  2127: " 40G^QMNNLPKRJUJXKZN[P[RZUWWTYPZM RQMONMPLRKUKXLZN[ RQMSMUNVPXXYZZ[ RSMTNUPWXXZZ[[[",
  2128: " 57G\\TFQGOIMMLPKTJZIb RTFRGPINMMPLTKZJb RTFVFXGYHYKXMWNTOPO RVFXHXKWMVNTO RPOTPVRWTWWVYUZR[P[NZMYLV RPOSPURVTVWUYTZR[",
  2129: " 28H\\IPKNMMOMQNROSRSVRZOb RJOLNPNRO RZMYPXRSYP^Nb RYMXPWRSY",
  2130: " 44I\\VNTMRMONMQLTLWMYNZP[R[UZWWXTXQWOSJRHRFSEUEWFYH RRMPNNQMTMXNZ RR[TZVWWTWPVNTKSISGTFVFYH",
  2131: " 32I[XPVNTMPMNNNPPRSS RPMONOPQRSS RSSNTLVLXMZP[S[UZWX RSSOTMVMXNZP[",
  2132: " 31I[TFRGQHQIRJUKZKZJWKSMPOMRLULWMYP[S]T_TaSbQbPa RULQONRMUMWNYP[",
  2133: " 32G]HQIOKMNMONOPNTL[ RMMNNNPMTK[ RNTPPRNTMVMXNYOYRXWUb RVMXOXRWWTb",
  2134: " 44F]GQHOJMMMNNNPMUMXNZO[ RLMMNMPLULXMZO[Q[SZUXWUXRYMYIXGVFTFRHRJSMUPWRZT RSZUWVUWRXMXIWGVF",
  2135: " 15LXRMPTOXOZP[S[UYVW RSMQTPXPZQ[",
  2136: " 29H\\NMJ[ ROMK[ RXMYNZNYMWMUNQROSMS ROSQTSZT[ ROSPTRZS[U[WZYW",
  2137: " 23H\\KFMFOGPHQJWXXZY[ RMFOHPJVXWZY[Z[ RRMJ[ RRMK[",
  2138: " 28F]MMGb RNMHb RMPLVLYN[P[RZTXVU RXMUXUZV[Y[[Y\\W RYMVXVZW[",
  2139: " 24H\\NML[ ROMNSMXL[ RYMXQVU RZMYPXRVUTWQYOZL[ RKMOM",
  2140: " 45IZTFRGQHQIRJUKXK RUKQLOMNONQPSSTVT RUKRLPMOOOQQSST RSTOUMVLXLZN\\S^T_TaRbPb RSTPUNVMXMZO\\S^",
  2141: " 32I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RRMPNNQMTMXNZ RR[TZVWWTWPVN",
  2142: " 22G]PNL[ RPNM[ RVNV[ RVNW[ RIPKNNM[M RIPKONN[N",
  2143: " 31H[LVMYNZP[R[UZWWXTXQWOVNTMRMONMQLTHb RR[TZVWWTWPVN RRMPNNQMTIb",
  2144: " 35H][MQMNNLQKTKWLYMZO[Q[TZVWWTWQVOUNSM RQMONMQLTLXMZ RQ[SZUWVTVPUN RUN[N",
  2145: " 16H\\SNP[ RSNQ[ RJPLNOMZM RJPLOONZN",
  2146: " 31H\\IQJOLMOMPNPPNVNYP[ RNMONOPMVMYNZP[Q[TZVXXUYRYOXMWNXOYR RXUYO",
  2147: " 37G]ONMOKQJTJWKYLZN[Q[TZWXYUZRZOXMVMTORSPXMb RJWLYNZQZTYWWYU RZOXNVNTPRSPYNb",
  2148: " 23I[KMMMONPPU_VaWb RMMNNOPT_UaWbYb RZMYOWRM]K`Jb",
  2149: " 34F]UFOb RVFNb RGQHOJMMMNNNPMUMXOZRZTYWVYS RLMMNMPLULXMZO[R[TZVXXUYS[M",
  2150: " 44F]JQLOONNMLNJQITIWJZK[M[OZQWRT RIWJYKZMZOYQW RQTQWRZS[U[WZYWZTZQYNXMWNYOZQ RQWRYSZUZWYYW",
  2151: " 39H]XMVTUXUZV[Y[[Y\\W RYMWTVXVZW[ RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ",
  2152: " 36H[PFLSLVMYNZ RQFMS RMSNPPNRMTMVNWOXQXTWWUZR[P[NZMWMS RVNWPWTVWTZR[ RMFQF",
  2153: " 25I[WPWQXQXPWNUMRMONMQLTLWMYNZP[R[UZWW RRMPNNQMTMXNZ",
  2154: " 42H]ZFVTUXUZV[Y[[Y\\W R[FWTVXVZW[ RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ RWF[F",
  2155: " 26I[MVQUTTWRXPWNUMRMONMQLTLWMYNZP[R[UZWX RRMPNNQMTMXNZ",
  2156: " 35KZZGYHZI[H[GZFXFVGUHTJSMP[O_Na RXFVHUJTNRWQ[P^O`NaLbJbIaI`J_K`Ja ROMYM",
  2157: " 43H\\YMU[T^RaObLbJaI`I_J^K_J` RXMT[S^QaOb RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ",
  2158: " 31H]PFJ[ RQFK[ RMTOPQNSMUMWNXOXQVWVZW[ RUMWOWQUWUZV[Y[[Y\\W RMFQF",
  2159: " 26LYUFTGUHVGUF RMQNOPMSMTNTQRWRZS[ RRMSNSQQWQZR[U[WYXW",
  2160: " 32LYVFUGVHWGVF RNQOOQMTMUNUQR[Q^P`OaMbKbJaJ`K_L`Ka RSMTNTQQ[P^O`Mb",
  2161: " 34H\\PFJ[ RQFK[ RXNWOXPYOYNXMWMUNQROSMS ROSQTSZT[ ROSPTRZS[U[WZYW RMFQF",
  2162: " 18MYUFQTPXPZQ[T[VYWW RVFRTQXQZR[ RRFVF",
  2163: " 52AbBQCOEMHMINIPHTF[ RGMHNHPGTE[ RHTJPLNNMPMRNSOSQP[ RPMRORQO[ RRTTPVNXMZM\\N]O]Q[W[Z\\[ RZM\\O\\QZWZZ[[^[`YaW",
  2164: " 37F]GQHOJMMMNNNPMTK[ RLMMNMPLTJ[ RMTOPQNSMUMWNXOXQVWVZW[ RUMWOWQUWUZV[Y[[Y\\W",
  2165: " 32I[RMONMQLTLWMYNZP[R[UZWWXTXQWOVNTMRM RRMPNNQMTMXNZ RR[TZVWWTWPVN",
  2166: " 42G\\HQIOKMNMONOPNTJb RMMNNNPMTIb RNTOQQNSMUMWNXOYQYTXWVZS[Q[OZNWNT RWNXPXTWWUZS[ RFbMb",
  2167: " 33H\\XMRb RYMSb RVTVQUNSMQMNNLQKTKWLYMZO[Q[SZUWVT RQMONMQLTLXMZ RObVb",
  2168: " 26IZJQKOMMPMQNQPPTN[ ROMPNPPOTM[ RPTRPTNVMXMYNYOXPWOXN",
  2169: " 28J[XOXPYPYOXNUMRMONNONQORVVWW RNPOQVUWVWYVZS[P[MZLYLXMXMY",
  2170: " 18KYTFPTOXOZP[S[UYVW RUFQTPXPZQ[ RNMWM",
  2171: " 37F]GQHOJMMMNNNQLWLYN[ RLMMNMQKWKYLZN[P[RZTXVT RXMVTUXUZV[Y[[Y\\W RYMWTVXVZW[",
  2172: " 26H\\IQJOLMOMPNPQNWNYP[ RNMONOQMWMYNZP[Q[TZVXXUYQYMXMYO",
  2173: " 41C`DQEOGMJMKNKQIWIYK[ RIMJNJQHWHYIZK[M[OZQXRV RTMRVRYSZU[W[YZ[X\\V]R]M\\M]O RUMSVSYU[",
  2174: " 42H\\KQMNOMRMSOSR RQMRORRQVPXNZL[K[JZJYKXLYKZ RQVQYR[U[WZYW RYNXOYPZOZNYMXMVNTPSRRVRYS[",
  2175: " 41G\\HQIOKMNMONOQMWMYO[ RMMNNNQLWLYMZO[Q[SZUXWT RZMV[U^SaPbMbKaJ`J_K^L_K` RYMU[T^RaPb",
  2176: " 31H\\YMXOVQNWLYK[ RLQMOOMRMVO RMOONRNVOXO RLYNYRZUZWY RNYR[U[WYXW",
  2177: " 43G^VGUHVIWHWGUFRFOGMILLL[ RRFPGNIMLM[ R\\G[H\\I]H]G\\FZFXGWIW[ RZFYGXIX[ RIM[M RI[P[ RT[[[",
  2178: " 33G]WGVHWIXHWGUFRFOGMILLL[ RRFPGNIMLM[ RWMW[ RXMX[ RIMXM RI[P[ RT[[[",
  2179: " 35G]VGUHVIWHWGUF RXFRFOGMILLL[ RRFPGNIMLM[ RWHW[ RXFX[ RIMWM RI[P[ RT[[[",
  2180: " 54BcRGQHRISHRGPFMFJGHIGLG[ RMFKGIIHLH[ R]G\\H]I^H]G[FXFUGSIRLR[ RXFVGTISLS[ R]M][ R^M^[ RDM^M RD[K[ RO[V[ RZ[a[",
  2181: " 56BcRGQHRISHRGPFMFJGHIGLG[ RMFKGIIHLH[ R\\G[H\\I]H]G[F R^FXFUGSIRLR[ RXFVGTISLS[ R]H][ R^F^[ RDM]M RD[K[ RO[V[ RZ[a[",
  2182: " 12MXRMR[ RSMS[ ROMSM RO[V[",
  2184: " 25IZWNUMRMONMPLSLVMYNZQ[T[VZ RRMPNNPMSMVNYOZQ[ RMTUT",
  2185: " 43I\\TFQGOJNLMOLTLXMZO[Q[TZVWWUXRYMYIXGVFTF RTFRGPJOLNOMTMXNZO[ RQ[SZUWVUWRXMXIWGVF RNPWP",
  2186: " 42G]UFOb RVFNb RQMMNKPJSJVKXMZP[S[WZYXZUZRYPWNTMQM RQMNNLPKSKVLXNZP[ RS[VZXXYUYRXPVNTM",
  2187: " 27I[TMVNXPXOWNTMQMNNMOLQLSMUOWSZ RQMONNOMQMSNUSZT\\T^S_Q_",
  2190: " 45G]LMKNJPJRKUOYP[ RJRKTOXP[P]O`MbLbKaJ_J\\KXMTOQRNTMVMYNZPZTYXWZU[T[SZSXTWUXTY RVMXNYPYTXXWZ",
  2191: " 69E_YGXHYIZHYGWFTFQGOINKMNLRJ[I_Ha RTFRGPIOKNNLWK[J^I`HaFbDbCaC`D_E`Da R_G^H_I`H`G_F]F[GZHYJXMU[T_Sa R]F[HZJYNWWV[U^T`SaQbObNaN`O_P`Oa RIM^M",
  2192: " 52F^[GZH[I\\H[GXFUFRGPIOKNNMRK[J_Ia RUFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea RYMWTVXVZW[Z[\\Y]W RZMXTWXWZX[ RJMZM",
  2193: " 54F^YGXHYIZHZGXF R\\FUFRGPIOKNNMRK[J_Ia RUFSGQIPKONMWL[K^J`IaGbEbDaD`E_F`Ea R[FWTVXVZW[Z[\\Y]W R\\FXTWXWZX[ RJMYM",
  2194: " 86@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca ROFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a R`G_H`IaH`G]FZFWGUITKSNRRP[O_Na RZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja R^M\\T[X[Z\\[_[aYbW R_M]T\\X\\Z][ RDM_M",
  2195: " 88@cTGSHTIUHTGRFOFLGJIIKHNGRE[D_Ca ROFMGKIJKINGWF[E^D`CaAb?b>a>`?_@`?a R^G]H^I_H_G]F RaFZFWGUITKSNRRP[O_Na RZFXGVIUKTNRWQ[P^O`NaLbJbIaI`J_K`Ja R`F\\T[X[Z\\[_[aYbW RaF]T\\X\\Z][ RDM^M",
  2196: " 20LYMQNOPMSMTNTQRWRZS[ RRMSNSQQWQZR[U[WYXW",
  2200: " 40H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF RQFOGNHMJLOLRMWNYOZQ[ RS[UZVYWWXRXOWJVHUGSF",
  2201: " 11H\\NJPISFS[ RRGR[ RN[W[",
  2202: " 45H\\LJMKLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ RTFVGWHXJXLWNTPPR RKYLXNXSZVZXYYX RNXS[W[XZYXYV",
  2203: " 47H\\LJMKLLKKKJLHMGPFTFWGXIXLWNTOQO RTFVGWIWLVNTO RTOVPXRYTYWXYWZT[P[MZLYKWKVLUMVLW RWQXTXWWYVZT[",
  2204: " 13H\\THT[ RUFU[ RUFJUZU RQ[X[",
  2205: " 39H\\MFKP RKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMVLW RSMUNWPXSXUWXUZS[ RMFWF RMGRGWF",
  2206: " 48H\\WIVJWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNRNOOMQLT RRFPGNIMKLOLUMXOZQ[ RS[UZWXXUXTWQUOSN",
  2207: " 31H\\KFKL RKJLHNFPFUIWIXHYF RLHNGPGUI RYFYIXLTQSSRVR[ RXLSQRSQVQ[",
  2208: " 63H\\PFMGLILLMNPOTOWNXLXIWGTFPF RPFNGMIMLNNPO RTOVNWLWIVGTF RPOMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO RPONPMQLSLWMYNZP[ RT[VZWYXWXSWQVPTO",
  2209: " 48H\\XMWPURRSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNWMX RQSORMPLMLLMIOGQF RSFUGWIXLXRWVVXTZR[",
  2210: "  6MWRYQZR[SZRY",
  2211: "  8MWR[QZRYSZS\\R^Q_",
  2212: " 12MWRMQNROSNRM RRYQZR[SZRY",
  2213: " 14MWRMQNROSNRM RR[QZRYSZS\\R^Q_",
  2214: " 15MWRFQHRTSHRF RRHRN RRYQZR[SZRY",
  2215: " 32I[MJNKMLLKLJMHNGPFSFVGWHXJXLWNVORQRT RSFUGVHWJWLVNTP RRYQZR[SZRY",
  2216: "  6NVRFQM RSFQM",
  2217: " 12JZNFMM ROFMM RVFUM RWFUM",
  2218: " 14KYQFOGNINKOMQNSNUMVKVIUGSFQF",
  2219: "  9JZRFRR RMIWO RWIMO",
  2220: "  3G][BIb",
  2221: " 20KYVBTDRGPKOPOTPYR]T`Vb RTDRHQKPPPTQYR\\T`",
  2222: " 20KYNBPDRGTKUPUTTYR]P`Nb RPDRHSKTPTTSYR\\P`",
  2223: " 12KYOBOb RPBPb ROBVB RObVb",
  2224: " 12KYTBTb RUBUb RNBUB RNbUb",
  2225: " 40KYTBRCQDPFPHQJRKSMSOQQ RRCQEQGRISJTLTNSPORSTTVTXSZR[Q]Q_Ra RQSSUSWRYQZP\\P^Q`RaTb",
  2226: " 40KYPBRCSDTFTHSJRKQMQOSQ RRCSESGRIQJPLPNQPURQTPVPXQZR[S]S_Ra RSSQUQWRYSZT\\T^S`RaPb",
  2227: "  4KYUBNRUb",
  2228: "  4KYOBVROb",
  2229: "  3NVRBRb",
  2230: "  6KYOBOb RUBUb",
  2231: "  3E_IR[R",
  2232: "  6E_RIR[ RIR[R",
  2233: "  9F^RJR[ RJRZR RJ[Z[",
  2234: "  9F^RJR[ RJJZJ RJRZR",
  2235: "  6G]KKYY RYKKY",
  2236: "  6MWRQQRRSSRRQ",
  2237: " 15E_RIQJRKSJRI RIR[R RRYQZR[SZRY",
  2238: "  6E_IO[O RIU[U",
  2239: "  9E_YIK[ RIO[O RIU[U",
  2240: "  9E_IM[M RIR[R RIW[W",
  2241: "  4F^ZIJRZ[",
  2242: "  4F^JIZRJ[",
  2243: " 10F^ZFJMZT RJVZV RJ[Z[",
  2244: " 10F^JFZMJT RJVZV RJ[Z[",
  2245: " 21F_[WYWWVUTRPQOONMNKOJQJSKUMVOVQURTUPWNYM[M",
  2246: " 24F^IUISJPLONOPPTSVTXTZS[Q RISJQLPNPPQTTVUXUZT[Q[O",
  2247: "  8G]JTROZT RJTRPZT",
  2248: "  7LXTFOL RTFUGOL",
  2249: "  7LXPFUL RPFOGUL",
  2250: " 18H\\KFLHNJQKSKVJXHYF RKFLINKQLSLVKXIYF",
  2251: "  8MWRHQGRFSGSIRKQL",
  2252: "  8MWSFRGQIQKRLSKRJ",
  2253: "  8MWRHSGRFQGQIRKSL",
  2254: "  8MWQFRGSISKRLQKRJ",
  2255: " 10E[HMLMRY RKMR[ R[BR[",
  2256: " 13F^ZJSJOKMLKNJQJSKVMXOYSZZZ",
  2257: " 13F^JJJQKULWNYQZSZVYXWYUZQZJ",
  2258: " 13F^JJQJUKWLYNZQZSYVWXUYQZJZ",
  2259: " 13F^JZJSKOLMNKQJSJVKXMYOZSZZ",
  2260: " 16F^ZJSJOKMLKNJQJSKVMXOYSZZZ RJRVR",
  2261: " 11E_XP[RXT RUMZRUW RIRZR",
  2262: " 11JZPLRITL RMORJWO RRJR[",
  2263: " 11E_LPIRLT ROMJROW RJR[R",
  2264: " 11JZPXR[TX RMURZWU RRIRZ",
  2265: " 44I\\XRWOVNTMRMONMQLTLWMYNZP[R[UZWXXUYPYKXHWGUFRFPGOHOIPIPH RRMPNNQMTMXNZ RR[TZVXWUXPXKWHUF",
  2266: " 15H\\JFR[ RKFRY RZFR[ RJFZF RKGYG",
  2267: " 10AbDMIMRY RHNR[ Rb:R[",
  2268: " 32F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` RVDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia",
  2269: " 50F^[CZD[E\\D\\C[BYBWCUETGSJRNPZO^N` RVDUFTJRVQZP]O_MaKbIbHaH`I_J`Ia RQKNLLNKQKSLVNXQYSYVXXVYSYQXNVLSKQK",
  2270: " 26F_\\S[UYVWVUUTTQPPONNLNJOIQISJULVNVPUQTTPUOWNYN[O\\Q\\S",
  2271: " 32F^[FI[ RNFPHPJOLMMKMIKIIJGLFNFPGSHVHYG[F RWTUUTWTYV[X[ZZ[X[VYTWT",
  2272: " 49F_[NZO[P\\O\\N[MZMYNXPVUTXRZP[M[JZIXIUJSPORMSKSIRGPFNGMIMKNNPQUXWZZ[[[\\Z\\Y RM[KZJXJUKSMQ RMKNMVXXZZ[",
  2273: " 56E`WNVLTKQKOLNMMPMSNUPVSVUUVS RQKOMNPNSOUPV RWKVSVUXVZV\\T]Q]O\\L[JYHWGTFQFNGLHJJILHOHRIUJWLYNZQ[T[WZYYZX RXKWSWUXV",
  2274: " 42H\\PBP_ RTBT_ RXIWJXKYJYIWGTFPFMGKIKKLMMNOOUQWRYT RKKMMONUPWQXRYTYXWZT[P[MZKXKWLVMWLX",
  2275: " 12H]SFLb RYFRb RLQZQ RKWYW",
  2276: " 46JZUITJUKVJVIUGSFQFOGNINKOMQOVR ROMTPVRWTWVVXTZ RPNNPMRMTNVPXU[ RNVSYU[V]V_UaSbQbOaN_N^O]P^O_",
  2277: " 30JZRFQHRJSHRF RRFRb RRQQTRbSTRQ RLMNNPMNLLM RLMXM RTMVNXMVLTM",
  2278: " 56JZRFQHRJSHRF RRFRT RRPQRSVRXQVSRRP RRTRb RR^Q`RbS`R^ RLMNNPMNLLM RLMXM RTMVNXMVLTM RL[N\\P[NZL[ RL[X[ RT[V\\X[VZT[",
  2279: " 12I\\XFX[ RKFXF RPPXP RK[X[",
  2281: " 38E`QFNGKIILHOHRIUKXNZQ[T[WZZX\\U]R]O\\LZIWGTFQF RROQPQQRRSRTQTPSORO RRPRQSQSPRP",
  2282: " 45J[PFNGOIQJ RPFOGOI RUFWGVITJ RUFVGVI RQJOKNLMNMQNSOTQUTUVTWSXQXNWLVKTJQJ RRUR[ RSUS[ RNXWX",
  2283: " 27I\\RFOGMILLLMMPORRSSSVRXPYMYLXIVGSFRF RRSR[ RSSS[ RNWWW",
  2284: " 28D`PFMGJIHLGOGSHVJYM[P\\T\\W[ZY\\V]S]O\\LZIWGTFPF RRFR\\ RGQ]Q",
  2285: " 31G`PMMNKPJSJTKWMYPZQZTYVWWTWSVPTNQMPM R]GWG[HUN R]G]M\\IVO R\\HVN",
  2286: " 28F\\IIJGLFOFQGRIRLQOPQNSKU ROFPGQIQMPPNS RVFT[ RWFS[ RKUYU",
  2287: " 30I\\MFMU RNFMQ RMQNOONQMTMWNXPXRWTUV RTMVNWPWRTXTZU[W[YY RKFNF",
  2288: " 44I\\RNOOMQLTLUMXOZR[S[VZXXYUYTXQVOSNRN RRHNJRFRN RSHWJSFSN RRSQTQURVSVTUTTSSRS RRTRUSUSTRT",
  2289: " 37G^QHRFR[ RTHSFS[ RJHKFKMLPNRQSRS RMHLFLNMQ R[HZFZMYPWRTSSS RXHYFYNXQ RNWWW",
  2290: " 31G]LFL[ RMFM[ RIFUFXGYHZJZMYOXPUQMQ RUFWGXHYJYMXOWPUQ RI[Y[YVX[",
  2291: " 24H[YGUGQHNJLMKPKSLVNYQ[U\\Y\\ RYGVHSJQMPPPSQVSYV[Y\\",
  2292: " 27F_OQMQKRJSIUIWJYKZM[O[QZRYSWSURSQROQ RSHPQ RZJRR R\\QST",
  2293: " 12H\\OKUY RUKOY RKOYU RYOKU",
  2294: " 48F^NVLUKUIVHXHYI[K\\L\\N[OYOXNVKRJOJMKJMHPGTGWHYJZMZOYRVVUXUYV[X\\Y\\[[\\Y\\X[VYUXUVV RJMKKMIPHTHWIYKZM",
  2295: " 48F^NMLNKNIMHKHJIHKGLGNHOJOKNMKQJTJVKYM[P\\T\\W[YYZVZTYQVMUKUJVHXGYG[H\\J\\K[MYNXNVM RJVKXMZP[T[WZYXZV",
  2317: " 12NVQQQSSSSQQQ RQQSS RSQQS",
  2318: " 18JZMPQRTTVVWYW[V]U^ RMQST RMRPSTUVWWY",
  2319: " 18JZWKVMTOPQMR RSPMS RUFVGWIWKVNTPQRMT",
  2320: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
  2321: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
  2322: " 34J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM ROPUM RNRVN RMTWO RNUXP ROVWR RPWVT",
  2323: " 18JZOGO^ RUFU] RMNWL RMOWM RMWWU RMXWV",
  2324: " 18JZNFNX RVLV^ RNNVL RNOVM RNWVU RNXVV",
  2325: " 25JZNBNW RNNQLTLVMWOWQVSSUQVNW RNNQMTMVN RUMVOVQUSSU",
  2326: " 18E_HIHL R\\I\\L RHI\\I RHJ\\J RHK\\K RHL\\L",
  2327: " 18JZMNMQ RWNWQ RMNWN RMOWO RMPWP RMQWQ",
  2328: " 49JZMLWX RMLONQOTOVNWMWKUKUMTO RONTO RQOWM RVKVN RULWL RWXUVSUPUNVMWMYOYOWPU RUVPU RSUMW RNVNY RMXOX",
  2329: " 26JZPOOMOKMKMMNNPOSOUNWL RNKNN RMLOL RMMSO RPOUN RWLWY",
  2330: " 86A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW RGdGeHeHdGd RU;Q?LCIFGIFKENERFVGXJ[ RR\\U[WZYWZTZPYMXKVITH",
  2331: "103EfNSOUQVSVUUVSVQUOSNQNOONPMSMVNYP[S\\V\\Y[[Y\\W]T]P\\MZJXIUHRHOIMJKLIOHSHXI]KaMcPeTfYf]e`cba RKLJNIRIXJ\\L`NbQdUeYe]d_cba RPOTO ROPUP RNQVQ RNRVR RNSVS ROTUT RPUTU RaLaNcNcLaL RbLbN RaMcM RaVaXcXcVaV RbVbX RaWcW",
  2332: " 30D`H@Hd RM@Md RW@Wd R\\@\\d RMMWK RMNWL RMOWM RMWWU RMXWV RMYWW",
  2367: " 12NVQQQSSSSQQQ RQQSS RSQQS",
  2368: " 18JZMPQRTTVVWYW[V]U^ RMQST RMRPSTUVWWY",
  2369: " 18JZWKVMTOPQMR RSPMS RUFVGWIWKVNTPQRMT",
  2370: " 32H\\PMMNLOKQKSLUMVPWTWWVXUYSYQXOWNTMPM RMNLPLSMUNVPW RWVXTXQWOVNTM",
  2371: " 36H\\SMONLPKRKTLVNWQWUVXTYRYPXNVMSM RXNSM RVMQNLP RONKR RLVQW RNWSVXT RUVYR",
  2372: " 34J[SMPNNPMRMTNVPWRWUVWTXRXPWNUMSM ROPUM RNRVN RMTWO RNUXP ROVWR RPWVT",
  2373: " 18JZOGO^ RUFU] RMNWL RMOWM RMWWU RMXWV",
  2374: " 18JZNFNX RVLV^ RNNVL RNOVM RNWVU RNXVV",
  2375: " 25JZNBNW RNNQLTLVMWOWQVSSUQVNW RNNQMTMVN RUMVOVQUSSU",
  2376: " 18E_HIHL R\\I\\L RHI\\I RHJ\\J RHK\\K RHL\\L",
  2377: " 18JZMNMQ RWNWQ RMNWN RMOWO RMPWP RMQWQ",
  2378: " 36JZQCVMRTRU RULQS RTITKPRRUUY RW\\UYSXQXOYN[N]O_Ra RW\\UZSYOYO]P_Ra RSXPZN]",
  2379: " 26JZPOOMOKMKMMNNPOSOUNWL RNKNN RMLOL RMMSO RPOUN RWLSY",
  2380: " 86A^GfHfIeIdHcGcFdFfGhIiKiNhPfQdR`RUQ;Q4R/S-U,V,X-Y/Y3X6W8U;P?JCHEFHEJDNDREVGYJ[N\\R\\V[XZZW[T[PZMYKWITHPHMIKKJNJRKUMW RGdGeHeHdGd RU;Q?LCIFGIFKENERFVGXJ[ RR\\U[WZYWZTZPYMXKVITH",
  2381: " 89IjNQOOQNSNUOVQVSUUSVQVOUNTMQMNNKPISHWH[I^K`NaRaW`[_]]`ZcVfQiMk RWHZI]K_N`R`W_[^]\\`YcTgQi RPOTO ROPUP RNQVQ RNRVR RNSVS ROTUT RPUTU ReLeNgNgLeL RfLfN ReMgM ReVeXgXgVeV RfVfX ReWgW",
  2382: " 85D`H>Hf RI>If RM>Mf RQBSBSDQDQAR?T>W>Y?[A\\D\\I[LYNWOUOSNRLQNOQNROSQVRXSVUUWUYV[X\\[\\`[cYeWfTfReQcQ`S`SbQb RRBRD RQCSC RY?ZA[D[IZLYN RRLRNPQNRPSRVRX RYVZX[[[`ZcYe RR`Rb RQaSa",
  2401: " 21AcHBHb RIBIb R[B[b R\\B\\b RDB`B RDbMb RWb`b",
  2402: " 23BaGBQPFb RFBPP REBPQ REB\\B^I[B RGa\\a RFb\\b^[[b",
  2403: " 28I[X+U1R8P=OANFMNMVN^OcPgRlUsXy RU1S6Q<P@OFNNNVO^PdQhSnUs",
  2404: " 28I[L+O1R8T=UAVFWNWVV^UcTgRlOsLy RO1Q6S<T@UFVNVVU^TdShQnOs",
  2405: " 14I[M+MRMy RN+NRNy RM+X+ RMyXy",
  2406: " 14I[V+VRVy RW+WRWy RL+W+ RLyWy",
  2407: " 48I[V+S-Q/P1O4O8P<TDUGUJTMRP RS-Q0P4P8Q;UCVGVJUMRPNRRTUWVZV]UaQiPlPpQtSw RRTTWUZU]T`PhOlOpPsQuSwVy",
  2408: " 48I[N+Q-S/T1U4U8T<PDOGOJPMRP RQ-S0T4T8S;OCNGNJOMRPVRRTOWNZN]OaSiTlTpStQw RRTPWOZO]P`ThUlUpTsSuQwNy",
  2409: " 32I[V.S1Q4O8N=NCOIPMSXT\\UbUgTlSoQs RS1Q5P8O=OBPHQLTWU[VaVgUlSpQsNv",
  2410: " 32I[N.Q1S4U8V=VCUITMQXP\\ObOgPlQoSs RQ1S5T8U=UBTHSLPWO[NaNgOlQpSsVv",
  2411: ' 147Z:RARRo R@RQo R?RRr RZ"VJRr',
  2412: " 57Ca].\\.[/[0\\1]1^0^.],[+Y+W,U.T0S3R:QJQjPsOv R\\/\\0]0]/\\/ RR:Rj RU.T1S:SZRjQqPtOvMxKyIyGxFvFtGsHsItIuHvGv RGtGuHuHtGt",
  3001: " 36H\\RFKZ RQIW[ RRIX[ RRFY[ RMUVU RI[O[ RT[[[ RKZJ[ RKZM[ RWZU[ RWYV[ RXYZ[",
  3002: " 78G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZLYNXOUP RXHYJYLXN RUFWGXIXMWOUP RNPUPXQYRZTZWYYXZU[I[ RXRYTYWXY RUPWQXSXXWZU[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
  3003: " 37G\\XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXXYV RMILKKNKSLVMX RQFOGMJLNLSMWOZQ[",
  3004: " 62G]LFL[ RMGMZ RNFN[ RIFSFVGXIYKZNZSYVXXVZS[I[ RWIXKYNYSXVWX RSFUGWJXNXSWWUZS[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
  3005: " 83G\\LFL[ RMGMZ RNFN[ RIFYFYL RNPTP RTLTT RI[Y[YU RJFLG RKFLH ROFNH RPFNG RTFYG RVFYH RWFYI RXFYL RTLSPTT RTNRPTR RTOPPTQ RLZJ[ RLYK[ RNYO[ RNZP[ RT[YZ RV[YY RW[YX RX[YU",
  3006: " 70G[LFL[ RMGMZ RNFN[ RIFYFYL RNPTP RTLTT RI[Q[ RJFLG RKFLH ROFNH RPFNG RTFYG RVFYH RWFYI RXFYL RTLSPTT RTNRPTR RTOPPTQ RLZJ[ RLYK[ RNYO[ RNZP[",
  3007: " 60G^XIYFYLXIVGTFQFNGLIKKJNJSKVLXNZQ[T[VZXZY[YS RMILKKNKSLVMX RQFOGMJLNLSMWOZQ[ RXTXY RWSWYVZ RTS\\S RUSWT RVSWU RZSYU R[SYT",
  3008: " 81F^KFK[ RLGLZ RMFM[ RWFW[ RXGXZ RYFY[ RHFPF RTF\\F RMPWP RH[P[ RT[\\[ RIFKG RJFKH RNFMH ROFMG RUFWG RVFWH RZFYH R[FYG RKZI[ RKYJ[ RMYN[ RMZO[ RWZU[ RWYV[ RYYZ[ RYZ[[",
  3009: " 39LXQFQ[ RRGRZ RSFS[ RNFVF RN[V[ ROFQG RPFQH RTFSH RUFSG RQZO[ RQYP[ RSYT[ RSZU[",
  3010: " 45JYSFSWRZQ[ RTGTWSZ RUFUWTZQ[O[MZLXLVMUNUOVOWNXMX RMVMWNWNVMV RPFXF RQFSG RRFSH RVFUH RWFUG",
  3011: " 69F\\KFK[ RLGLZ RMFM[ RXGMR RPPW[ RQPX[ RQNY[ RHFPF RUF[F RH[P[ RT[[[ RIFKG RJFKH RNFMH ROFMG RWFXG RZFXG RKZI[ RKYJ[ RMYN[ RMZO[ RWYU[ RWYZ[",
  3012: " 52I[NFN[ ROGOZ RPFP[ RKFSF RK[Z[ZU RLFNG RMFNH RQFPH RRFPG RNZL[ RNYM[ RPYQ[ RPZR[ RU[ZZ RW[ZY RX[ZX RY[ZU",
  3013: " 63E_JFJZ RJFQ[ RKFQX RLFRX RXFQ[ RXFX[ RYGYZ RZFZ[ RGFLF RXF]F RG[M[ RU[][ RHFJG R[FZH R\\FZG RJZH[ RJZL[ RXZV[ RXYW[ RZY[[ RZZ\\[",
  3014: " 39F^KFKZ RKFY[ RLFXX RMFYX RYGY[ RHFMF RVF\\F RH[N[ RIFKG RWFYG R[FYG RKZI[ RKZM[",
  3015: " 54G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RMILKKNKSLVMX RWXXVYSYNXKWI RQFOGMJLNLSMWOZQ[ RS[UZWWXSXNWJUGSF",
  3016: " 59G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZMYOXPUQNQ RXHYJYMXO RUFWGXIXNWPUQ RI[Q[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
  3017: " 77G]QFNGLIKKJOJRKVLXNZQ[S[VZXXYVZRZOYKXIVGSFQF RMILKKNKSLVMX RWXXVYSYNXKWI RQFOGMJLNLSMWOZQ[ RS[UZWWXSXNWJUGSF RNXOVQURUTVUXV^W`Y`Z^Z\\ RV\\W^X_Y_ RUXW]X^Y^Z]",
  3018: " 80G]LFL[ RMGMZ RNFN[ RIFUFXGYHZJZLYNXOUPNP RXHYJYLXN RUFWGXIXMWOUP RRPTQUSWYX[Z[[Y[W RWWXYYZZZ RTQURXXYYZY[X RI[Q[ RJFLG RKFLH ROFNH RPFNG RLZJ[ RLYK[ RNYO[ RNZP[",
  3019: " 44H\\XIYFYLXIVGSFPFMGKIKLLNOPURWSXUXXWZ RLLMNOOUQWRXT RMGLILKMMONUPXRYTYWXYWZT[Q[NZLXKUK[LX",
  3020: " 57H\\JFJL RQFQ[ RRGRZ RSFS[ RZFZL RJFZF RN[V[ RKFJL RLFJI RMFJH ROFJG RUFZG RWFZH RXFZI RYFZL RQZO[ RQYP[ RSYT[ RSZU[",
  3021: " 45F^KFKULXNZQ[S[VZXXYUYG RLGLVMX RMFMVNYOZQ[ RHFPF RVF\\F RIFKG RJFKH RNFMH ROFMG RWFYG R[FYG",
  3022: " 34H\\KFR[ RLFRXR[ RMFSX RYGR[ RIFPF RUF[F RJFLH RNFMH ROFMG RWFYG RZFYG",
  3023: " 55F^JFN[ RKFNVN[ RLFOV RRFOVN[ RRFV[ RSFVVV[ RTFWV RZGWVV[ RGFOF RRFTF RWF]F RHFKG RIFKH RMFLH RNFLG RXFZG R\\FZG",
  3024: " 54H\\KFW[ RLFX[ RMFY[ RXGLZ RIFPF RUF[F RI[O[ RT[[[ RJFMH RNFMH ROFMG RVFXG RZFXG RLZJ[ RLZN[ RWZU[ RWYV[ RWYZ[",
  3025: " 48G]JFQQQ[ RKFRQRZ RLFSQS[ RYGSQ RHFOF RVF\\F RN[V[ RIFKG RNFLG RWFYG R[FYG RQZO[ RQYP[ RSYT[ RSZU[",
  3026: " 41H\\YFKFKL RWFK[ RXFL[ RYFM[ RK[Y[YU RLFKL RMFKI RNFKH RPFKG RT[YZ RV[YY RW[YX RX[YU",
  3051: " 38H\\UFIZ RSJT[ RTHUZ RUFUHVYV[ RLUTU RF[L[ RQ[X[ RIZG[ RIZK[ RTZR[ RTYS[ RVYW[",
  3052: " 78F^OFI[ RPFJ[ RQFK[ RLFWFZG[I[KZNYOVP RYGZIZKYNXO RWFXGYIYKXNVP RNPVPXQYSYUXXVZR[F[ RWQXSXUWXUZ RVPWRWUVXTZR[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
  3053: " 41H]ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[S[UZWXXV RQHOJNLMOLSLWMY RTFRGPJOLNOMSMXNZP[",
  3054: " 63F]OFI[ RPFJ[ RQFK[ RLFUFXGYHZKZOYSWWUYSZO[F[ RWGXHYKYOXSVWTY RUFWHXKXOWSUWRZO[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
  3055: " 80F]OFI[ RPFJ[ RQFK[ RULST RLF[FZL RNPTP RF[U[WV RMFPG RNFOH RRFPH RSFPG RWFZG RXFZH RYFZI RZFZL RULSPST RTNRPSR RTOQPSQ RJZG[ RJYH[ RKYL[ RJZM[ RP[UZ RR[UY RUYWV",
  3056: " 70F\\OFI[ RPFJ[ RQFK[ RULST RLF[FZL RNPTP RF[N[ RMFPG RNFOH RRFPH RSFPG RWFZG RXFZH RYFZI RZFZL RULSPST RTNRPSR RTOQPSQ RJZG[ RJYH[ RKYL[ RJZM[",
  3057: " 65H^ZH[H\\F[L[JZHYGWFTFQGOIMLLOKSKVLYMZP[R[UZWXYT RQHOJNLMOLSLWMY RVXWWXT RTFRGPJOLNOMSMXNZP[ RR[TZVWWT RTT\\T RUTWU RVTWW RZTXV R[TXU",
  3058: " 81E_NFH[ ROFI[ RPFJ[ RZFT[ R[FU[ R\\FV[ RKFSF RWF_F RLPXP RE[M[ RQ[Y[ RLFOG RMFNH RQFOH RRFOG RXF[G RYFZH R]F[H R^F[G RIZF[ RIYG[ RJYK[ RIZL[ RUZR[ RUYS[ RVYW[ RUZX[",
  3059: " 39KYTFN[ RUFO[ RVFP[ RQFYF RK[S[ RRFUG RSFTH RWFUH RXFUG ROZL[ ROYM[ RPYQ[ ROZR[",
  3060: " 47I\\WFRWQYO[ RXFTSSVRX RYFUSSXQZO[M[KZJXJVKULUMVMWLXKX RKVKWLWLVKV RTF\\F RUFXG RVFWH RZFXH R[FXG",
  3061: " 72F]OFI[ RPFJ[ RQFK[ R\\GMR RQOU[ RROV[ RSNWZ RLFTF RYF_F RF[N[ RR[Y[ RMFPG RNFOH RRFPH RSFPG RZF\\G R^F\\G RJZG[ RJYH[ RKYL[ RJZM[ RUZS[ RUYT[ RVYX[",
  3062: " 49H\\QFK[ RRFL[ RSFM[ RNFVF RH[W[YU ROFRG RPFQH RTFRH RUFRG RLZI[ RLYJ[ RMYN[ RLZO[ RR[WZ RT[XX RV[YU",
  3063: " 68D`MFGZ RMGNYN[ RNFOY ROFPX R[FPXN[ R[FU[ R\\FV[ R]FW[ RJFOF R[F`F RD[J[ RR[Z[ RKFMG RLFMH R^F\\H R_F\\G RGZE[ RGZI[ RVZS[ RVYT[ RWYX[ RVZY[",
  3064: " 43F_OFIZ ROFV[ RPFVX RQFWX R\\GWXV[ RLFQF RYF_F RF[L[ RMFPG RNFPH RZF\\G R^F\\G RIZG[ RIZK[",
  3065: " 56G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF ROIMLLOKSKWLY RUXWUXRYNYJXH RSFQGOJNLMOLSLXMZN[ RQ[SZUWVUWRXNXIWGVF",
  3066: " 60F]OFI[ RPFJ[ RQFK[ RLFXF[G\\I\\K[NYPUQMQ RZG[I[KZNXP RXFYGZIZKYNWPUQ RF[N[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
  3067: " 78G]SFPGNILLKOJSJVKYLZN[Q[TZVXXUYRZNZKYHXGVFSF ROIMLLOKSKWLY RUXWUXRYNYJXH RSFQGOJNLMOLSLXMZN[ RQ[SZUWVUWRXNXIWGVF RLXMVOUPURVSXT]U^V^W] RT^U_V_ RSXS_T`V`W]W\\",
  3068: " 78F^OFI[ RPFJ[ RQFK[ RLFWFZG[I[KZNYOVPNP RYGZIZKYNXO RWFXGYIYKXNVP RRPTQURWXXYYYZX RWYXZYZ RURVZW[Y[ZXZW RF[N[ RMFPG RNFOH RRFPH RSFPG RJZG[ RJYH[ RKYL[ RJZM[",
  3069: " 44G^ZH[H\\F[L[JZHYGVFRFOGMIMLNNPPVSWUWXVZ RNLONVRWT ROGNINKOMUPWRXTXWWYVZS[O[LZKYJWJUI[JYKY",
  3070: " 54G]TFN[ RUFO[ RVFP[ RMFKL R]F\\L RMF]F RK[S[ RNFKL RPFLI RRFMG RYF\\G RZF\\H R[F\\I R\\F\\L ROZL[ ROYM[ RPYQ[ ROZR[",
  3071: " 48F_NFKQJUJXKZN[R[UZWXXU\\G ROFLQKUKYLZ RPFMQLULYN[ RKFSF RYF_F RLFOG RMFNH RQFOH RRFOG RZF\\G R^F\\G",
  3072: " 35H\\NFNHOYO[ ROGPX RPFQW R[GO[ RLFSF RXF^F RMFNH RQFPH RRFOG RYF[G R]F[G",
  3073: " 57E_MFMHKYK[ RNGLX ROFMW RUFMWK[ RUFUHSYS[ RVGTX RWFUW R]GUWS[ RJFRF RUFWF RZF`F RKFNG RLFMH RPFNI RQFNG R[F]G R_F]G",
  3074: " 54G]NFT[ ROFU[ RPFV[ R[GIZ RLFSF RXF^F RF[L[ RQ[X[ RMFOH RQFPH RRFPG RYF[G R]F[G RIZG[ RIZK[ RTZR[ RTYS[ RUYW[",
  3075: " 51G]MFQPN[ RNFRPO[ ROFSPP[ R\\GSP RKFRF RYF_F RK[S[ RLFNG RPFOH RQFNG RZF\\G R^F\\G ROZL[ ROYM[ RPYQ[ ROZR[",
  3076: " 35G]ZFH[ R[FI[ R\\FJ[ R\\FNFLL RH[V[XU ROFLL RPFMI RRFNG RR[VZ RT[WX RU[XU",
  3101: " 54I]NPNOOOOQMQMONNPMTMVNWOXQXXYZZ[ RVOWQWXXZ RTMUNVPVXWZZ[[[ RVRUSPTMULWLXMZP[S[UZVX RNUMWMXNZ RUSQTOUNWNXOZP[",
  3102: " 47G\\LFL[MZOZ RMGMY RIFNFNZ RNPONQMSMVNXPYSYUXXVZS[Q[OZNX RWPXRXVWX RSMUNVOWRWVVYUZS[ RJFLG RKFLH",
  3103: " 34H[WQWPVPVRXRXPVNTMQMNNLPKSKULXNZQ[S[VZXX RMPLRLVMX RQMONNOMRMVNYOZQ[",
  3104: " 52H]VFV[[[ RWGWZ RSFXFX[ RVPUNSMQMNNLPKSKULXNZQ[S[UZVX RMPLRLVMX RQMONNOMRMVNYOZQ[ RTFVG RUFVH RXYY[ RXZZ[",
  3105: " 41H[MSXSXQWOVNSMQMNNLPKSKULXNZQ[S[VZXX RWRWQVO RMPLRLVMX RVSVPUNSM RQMONNOMRMVNYOZQ[",
  3106: " 40KYWHWGVGVIXIXGWFTFRGQHPKP[ RRHQKQZ RTFSGRIR[ RMMVM RM[U[ RPZN[ RPYO[ RRYS[ RRZT[",
  3107: " 89I\\XNYOZNYMXMVNUO RQMONNOMQMSNUOVQWSWUVVUWSWQVOUNSMQM ROONQNSOU RUUVSVQUO RQMPNOPOTPVQW RSWTVUTUPTNSM RNUMVLXLYM[N\\Q]U]X^Y_ RN[Q\\U\\X] RLYMZP[U[X\\Y^Y_XaUbObLaK_K^L\\O[ RObMaL_L^M\\O[",
  3108: " 65G^LFL[ RMGMZ RIFNFN[ RNQOOPNRMUMWNXOYRY[ RWOXRXZ RUMVNWQW[ RI[Q[ RT[\\[ RJFLG RKFLH RLZJ[ RLYK[ RNYO[ RNZP[ RWZU[ RWYV[ RYYZ[ RYZ[[",
  3109: " 43LXQFQHSHSFQF RRFRH RQGSG RQMQ[ RRNRZ RNMSMS[ RN[V[ ROMQN RPMQO RQZO[ RQYP[ RSYT[ RSZU[",
  3110: " 41KXRFRHTHTFRF RSFSH RRGTG RRMR^QaPb RSNS]R` ROMTMT]S`RaPbMbLaL_N_NaMaM` RPMRN RQMRO",
  3111: " 61G]LFL[ RMGMZ RIFNFN[ RWNNW RRSY[ RRTX[ RQTW[ RTM[M RI[Q[ RT[[[ RJFLG RKFLH RUMWN RZMWN RLZJ[ RLYK[ RNYO[ RNZP[ RWYU[ RVYZ[",
  3112: " 31LXQFQ[ RRGRZ RNFSFS[ RN[V[ ROFQG RPFQH RQZO[ RQYP[ RSYT[ RSZU[",
  3113: " 99AcFMF[ RGNGZ RCMHMH[ RHQIOJNLMOMQNROSRS[ RQORRRZ ROMPNQQQ[ RSQTOUNWMZM\\N]O^R^[ R\\O]R]Z RZM[N\\Q\\[ RC[K[ RN[V[ RY[a[ RDMFN REMFO RFZD[ RFYE[ RHYI[ RHZJ[ RQZO[ RQYP[ RSYT[ RSZU[ R\\ZZ[ R\\Y[[ R^Y_[ R^Z`[",
  3114: " 65G^LML[ RMNMZ RIMNMN[ RNQOOPNRMUMWNXOYRY[ RWOXRXZ RUMVNWQW[ RI[Q[ RT[\\[ RJMLN RKMLO RLZJ[ RLYK[ RNYO[ RNZP[ RWZU[ RWYV[ RYYZ[ RYZ[[",
  3115: " 46H\\QMNNLPKSKULXNZQ[S[VZXXYUYSXPVNSMQM RMPLRLVMX RWXXVXRWP RQMONNOMRMVNYOZQ[ RS[UZVYWVWRVOUNSM",
  3116: " 60G\\LMLb RMNMa RIMNMNb RNPONQMSMVNXPYSYUXXVZS[Q[OZNX RWPXRXVWX RSMUNVOWRWVVYUZS[ RIbQb RJMLN RKMLO RLaJb RL`Kb RN`Ob RNaPb",
  3117: " 55H\\VNVb RWOWa RUNWNXMXb RVPUNSMQMNNLPKSKULXNZQ[S[UZVX RMPLRLVMX RQMONNOMRMVNYOZQ[ RSb[b RVaTb RV`Ub RX`Yb RXaZb",
  3118: " 43IZNMN[ RONOZ RKMPMP[ RWOWNVNVPXPXNWMUMSNQPPS RK[S[ RLMNN RMMNO RNZL[ RNYM[ RPYQ[ RPZR[",
  3119: " 43J[WOXMXQWOVNTMPMNNMOMQNSPTUUWVXY RNNMQ RNRPSUTWU RXVWZ RMONQPRUSWTXVXYWZU[Q[OZNYMWM[NY",
  3120: " 22KZPHPVQYRZT[V[XZYX RQHQWRY RPHRFRWSZT[ RMMVM",
  3121: " 43G^LMLVMYNZP[S[UZVYWW RMNMWNY RIMNMNWOZP[ RWMW[\\[ RXNXZ RTMYMY[ RJMLN RKMLO RYYZ[ RYZ[[",
  3122: " 31I[LMR[ RMMRY RNMSY RXNSYR[ RJMQM RTMZM RKMNO RPMNN RVMXN RYMXN",
  3123: " 45F^JMN[ RKMNX RLMOX RRMOXN[ RRMV[ RSMVX RRMTMWX RZNWXV[ RGMOM RWM]M RHMKN RNMLN RXMZN R\\MZN",
  3124: " 48H\\LMV[ RMMW[ RNMX[ RWNMZ RJMQM RTMZM RJ[P[ RS[Z[ RKMMN RPMNN RUMWN RYMWN RMZK[ RMZO[ RVZT[ RWZY[",
  3125: " 40H[LMR[ RMMRY RNMSY RXNSYP_NaLbJbIaI_K_KaJaJ` RJMQM RTMZM RKMNO RPMNN RVMXN RYMXN",
  3126: " 41I[VML[ RWMM[ RXMN[ RXMLMLQ RL[X[XW RMMLQ RNMLP ROMLO RQMLN RS[XZ RU[XY RV[XX RW[XW",
  3151: " 50G]WMUTUXVZW[Y[[Y\\W RXMVTVZ RWMYMWTVX RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RNNLQKTKWLY RPMNOMQLTLWMZN[",
  3152: " 52I\\PFNMMSMWNYOZQ[S[VZXWYTYRXOWNUMSMQNPOOQNT RQFOMNQNWOZ RVYWWXTXQWO RMFRFPMNT RS[UYVWWTWQVNUM RNFQG ROFPH",
  3153: " 34I[WQWPVPVRXRXPWNUMRMONMQLTLVMYNZP[R[UZWW ROONQMTMWNY RRMPOOQNTNWOZP[",
  3154: " 58G]YFVQUUUXVZW[Y[[Y\\W RZFWQVUVZ RVF[FWTVX RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RMOLQKTKWLY RPMNOMQLTLWMZN[ RWFZG RXFYH",
  3155: " 33I[MVQUTTWRXPWNUMRMONMQLTLVMYNZP[R[UZWX ROONQMTMWNY RRMPOOQNTNWOZP[",
  3156: " 45JZZHZGYGYI[I[GZFXFVGTISKRNQRO[N^M`Kb RTJSMRRP[O^ RXFVHUJTMSRQZP]O_MaKbIbHaH_J_JaIaI` RNMYM",
  3157: " 57H]XMT[S^QaOb RYMU[S_ RXMZMV[T_RaObLbJaI`I^K^K`J`J_ RVTVQUNSMQMNNLQKTKVLYMZO[Q[SZTYUWVT RNOMQLTLWMY RQMOONQMTMWNZO[",
  3158: " 41G]OFI[K[ RPFJ[ RLFQFK[ RMTOPQNSMUMWNXPXSVX RWNWRVVVZ RWPUUUXVZW[Y[[Y\\W RMFPG RNFOH",
  3159: " 35KXSFSHUHUFSF RTFTH RSGUG RLQMOOMQMRNSPSSQX RRNRRQVQZ RRPPUPXQZR[T[VYWW",
  3160: " 45KXUFUHWHWFUF RVFVH RUGWG RMQNOPMRMSNTPTSRZQ]P_NaLbJbIaI_K_KaJaJ` RSNSSQZP]O_ RSPRTP[O^N`Lb",
  3161: " 49G]OFI[K[ RPFJ[ RLFQFK[ RYOYNXNXPZPZNYMWMUNQROS RMSOSQTRUTYUZWZ RQUSYTZ ROSPTRZS[U[WZYW RMFPG RNFOH",
  3162: " 26LXTFQQPUPXQZR[T[VYWW RUFRQQUQZ RQFVFRTQX RRFUG RSFTH",
  3163: " 61@cAQBODMFMGNHPHSF[ RGNGSE[ RGPFTD[F[ RHSJPLNNMPMRNSPSSQ[ RRNRSP[ RRPQTO[Q[ RSSUPWNYM[M]N^P^S\\X R]N]R\\V\\Z R]P[U[X\\Z][_[aYbW",
  3164: " 42F^GQHOJMLMMNNPNSL[ RMNMSK[ RMPLTJ[L[ RNSPPRNTMVMXNYPYSWX RXNXRWVWZ RXPVUVXWZX[Z[\\Y]W",
  3165: " 46H\\QMNNLQKTKVLYMZP[S[VZXWYTYRXOWNTMQM RNOMQLTLWMY RVYWWXTXQWO RQMOONQMTMWNZP[ RS[UYVWWTWQVNTM",
  3166: " 66G]HQIOKMMMNNOPOSNWKb RNNNSMWJb RNPMTIb ROTPQQORNTMVMXNYOZRZTYWWZT[R[PZOWOT RXOYQYTXWWY RVMWNXQXTWWVYT[ RFbNb RJaGb RJ`Hb RK`Lb RJaMb",
  3167: " 57G\\WMQb RXMRb RWMYMSb RUTUQTNRMPMMNKQJTJVKYLZN[P[RZSYTWUT RMOLQKTKWLY RPMNOMQLTLWMZN[ RNbVb RRaOb RR`Pb RS`Tb RRaUb",
  3168: " 30I[JQKOMMOMPNQPQTO[ RPNPTN[ RPPOTM[O[ RYOYNXNXPZPZNYMWMUNSPQT",
  3169: " 47J[XPXOWOWQYQYOXNUMRMONNONQOSQTTUVVWX RONNQ RORQSTTVU RWVVZ RNOOQQRTSVTWVWXVZS[P[MZLYLWNWNYMYMX",
  3170: " 23KYTFQQPUPXQZR[T[VYWW RUFRQQUQZ RTFVFRTQX RNMXM",
  3171: " 42F^GQHOJMLMMNNPNSLX RMNMRLVLZ RMPKUKXLZN[P[RZTXVU RXMVUVXWZX[Z[\\Y]W RYMWUWZ RXMZMXTWX",
  3172: " 29H\\IQJOLMNMONPPPSNX RONORNVNZ ROPMUMXNZP[R[TZVXXUYQYMXMXNYP",
  3173: " 48CaDQEOGMIMJNKPKSIX RJNJRIVIZ RJPHUHXIZK[M[OZQXRU RTMRURXSZU[W[YZ[X]U^Q^M]M]N^P RUMSUSZ RTMVMTTSX",
  3174: " 51G]JQLNNMPMRNSPSR RPMQNQRPVOXMZK[I[HZHXJXJZIZIY RRORRQVQY RZOZNYNYP[P[NZMXMVNTPSRRVRZS[ RPVPXQZS[U[WZYW",
  3175: " 49G]HQIOKMMMNNOPOSMX RNNNRMVMZ RNPLULXMZO[Q[SZUXWT RYMU[T^RaPb RZMV[T_ RYM[MW[U_SaPbMbKaJ`J^L^L`K`K_",
  3176: " 39H\\YMXOVQNWLYK[ RXOOOMPLR RVORNONNO RVORMOMMOLR RLYUYWXXV RNYRZUZVY RNYR[U[WYXV",
  3200: " 50H\\QFNGLJKOKRLWNZQ[S[VZXWYRYOXJVGSFQF RNHMJLNLSMWNY RVYWWXSXNWJVH RQFOGNIMNMSNXOZQ[ RS[UZVXWSWNVIUGSF",
  3201: " 28H\\QHQ[ RRHRZ RSFS[ RSFPINJ RM[W[ RQZO[ RQYP[ RSYT[ RSZU[",
  3202: " 62H\\LJLKMKMJLJ RLIMINJNKMLLLKKKJLHMGPFTFWGXHYJYLXNUPPRNSLUKXK[ RWHXJXLWN RTFVGWJWLVNTPPR RKYLXNXSYWYYX RNXSZWZXY RNXS[W[XZYXYV",
  3203: " 76H\\LJLKMKMJLJ RLIMINJNKMLLLKKKJLHMGPFTFWGXIXLWNTO RVGWIWLVN RSFUGVIVLUNSO RQOTOVPXRYTYWXYWZT[P[MZLYKWKVLUMUNVNWMXLX RWRXTXWWY RSOUPVQWTWWVZT[ RLVLWMWMVLV",
  3204: " 28H\\SIS[ RTHTZ RUFU[ RUFJUZU RP[X[ RSZQ[ RSYR[ RUYV[ RUZW[",
  3205: " 55H\\MFKPMNPMSMVNXPYSYUXXVZS[P[MZLYKWKVLUMUNVNWMXLX RWPXRXVWX RSMUNVOWRWVVYUZS[ RLVLWMWMVLV RMFWF RMGUG RMHQHUGWF",
  3206: " 69H\\VIVJWJWIVI RWHVHUIUJVKWKXJXIWGUFRFOGMILKKOKULXNZQ[S[VZXXYUYTXQVOSNQNOONPMR RNIMKLOLUMXNY RWXXVXSWQ RRFPGOHNJMNMUNXOZQ[ RS[UZVYWVWSVPUOSN",
  3207: " 43H\\KFKL RYFYIXLTQSSRWR[ RSRRTQWQ[ RXLSQQTPWP[R[ RKJLHNFPFUIWIXHYF RMHNGPGRH RKJLINHPHUI",
  3208: " 79H\\PFMGLILLMNPOTOWNXLXIWGTFPF RNGMIMLNN RVNWLWIVG RPFOGNINLONPO RTOUNVLVIUGTF RPOMPLQKSKWLYMZP[T[WZXYYWYSXQWPTO RMQLSLWMY RWYXWXSWQ RPONPMSMWNZP[ RT[VZWWWSVPTO",
  3209: " 69H\\MWMXNXNWMW RWOVQURSSQSNRLPKMKLLINGQFSFVGXIYLYRXVWXUZR[O[MZLXLWMVNVOWOXNYMY RMPLNLKMI RVHWIXLXRWVVX RQSORNQMNMKNHOGQF RSFUGVIWLWSVWUYTZR[",
  3316: "100E`HQHRISKSMRMOLMJJJHLF RLOJK RKSLRLPJMIKIIJGLFOFQGRHSJSU RSWS\\R^P_M_L^L\\M[N\\M] RQHRJR\\Q^ ROFPGQJQU RQWQ\\P^O_ RSJXF RXFZI[K\\O\\R[UYXV[ RWGZK[N[O RVHXJZM[P[SZVYX RWYUVSU RQUOVMX RWZUWSVPV RV[TXSW RQWOWMX",
  3404: " 47J[QFNINKOLSNVPWRWUVXTZ ROJOKSMVOWP ROHOIPJUMWOXRXUWXTZQ[ RRNNPNXMY ROPOXRZ RPOPXRYSZ RMYNYPZQ[",
  3405: " 27KXPUVQSMOPNRNWOYQ[UY RUQRN RPPOROWPYQZ RTRROQOPQPVQXSZ",
  2668: " 24LZLVNSPRRSRUP[ RPRQSQUO[ RRUTSVRWRVU RVRVUWWXWZV",
  2670: " 20NVNVPSRO RUFOXOZQ[SZTYVV RVFPXPZQ[ RPNVN"
};

// src/drawing.ts
function export_mock_svg(dr) {
  let width = dr.w;
  let height = dr.h;
  let elements = dr.elements;
  let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
  for (let i2 = 0; i2 < elements.length; i2++) {
    let elt = elements[i2];
    let { tag, x, y, w, h } = elt;
    if (tag == "note_head") {
      if (elt.stem_dir < 0) {
        if (elt.twisted) {
          o += `<rect x="${x}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
        } else {
          o += `<rect x="${x - 10}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
        }
      } else {
        if (!elt.twisted) {
          o += `<rect x="${x}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
        } else {
          o += `<rect x="${x - 10}" y="${y - 2}" width="${10}" height="${4}" fill="blue"/>`;
        }
      }
      o += `<text x="${x}" y="${y}" font-size="8" fill="red">${elt.duration}</text>`;
    } else if (tag == "rest") {
      o += `<rect x="${x - w / 2}" y="${y - h / 2}" width="${w}" height="${h}" fill="rgba(0,255,0,0.2)" stroke="black"/>`;
      o += `<text x="${x - w / 2}" y="${y - h / 2}" font-size="8">${elt.duration}</text>`;
    } else if (tag == "accidental" || tag == "clef" || tag == "timesig_digit") {
      o += `<rect x="${x - w / 2}" y="${y - h / 2}" width="${w}" height="${h}" fill="rgba(255,255,0,0.2)" stroke="black"/>`;
    } else if (tag == "beam") {
      o += `<line x1="${x}" y1="${y}" x2="${x + w}" y2="${y + h}" stroke="brown" stroke-width="3"/>`;
    } else if (tag == "line") {
      o += `<line x1="${x}" y1="${y}" x2="${x + w}" y2="${y + h}" stroke="black"/>`;
    } else if (tag == "dbg") {
      o += `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${elt.color}" opacity="0.1"/>`;
    } else {
      o += `<rect x="${x}" y="${y}" width="${w || 1}" height="${h || 1}" fill="rgba(0,0,0,0.2)" stroke="black"/>`;
      o += `<text x="${x}" y="${y}" font-size="5">${tag}</text>`;
    }
  }
  o += `</svg>`;
  return o;
}
function xform(polylines, fn) {
  return polylines.map((p) => p.map((xy) => fn(xy[0], xy[1])));
}
function cubic_bezier(x0, y0, x1, y1, x2, y2, x3, y3, t) {
  let s = 1 - t;
  let s2 = s * s;
  let s3 = s * s2;
  let t2 = t * t;
  let t3 = t2 * t;
  return [
    s3 * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t3 * x3,
    s3 * y0 + 3 * s2 * t * y1 + 3 * s * t2 * y2 + t3 * y3
  ];
}
var symbols = {};
(function make_symbols() {
  function note_var(p2, stem_dir, twisted) {
    if (stem_dir < 0) {
      if (twisted) {
        p2 = xform(p2, (u, v) => [u + 5, v]);
      } else {
        p2 = xform(p2, (u, v) => [u - 6, v]);
      }
    } else {
      if (twisted) {
        p2 = xform(p2, (u, v) => [u - 6, v]);
      } else {
        p2 = xform(p2, (u, v) => [u + 5, v]);
      }
    }
    return p2;
  }
  let p;
  {
    p = HERSHEY(2370).polylines;
    symbols["note_whole_up_twist"] = note_var(p, -1, true);
    symbols["note_whole_down_twist"] = note_var(p, 1, true);
    symbols["note_whole_up"] = note_var(p, -1, false);
    symbols["note_whole_down"] = note_var(p, 1, false);
  }
  {
    p = HERSHEY(2371).polylines;
    p = xform(p, (u, v) => scale_axis(u, v, 1, 0.9, 0.4634));
    p = p.slice(0, 1).concat(xform(p.slice(0, 1), (u, v) => scale_axis(u, v, 1, 0.75, 0.4634)));
    p = xform(p, (u, v) => [u * 0.82 + 0.5, v]);
    symbols["note_half_up_twist"] = note_var(p, -1, true);
    symbols["note_half_down_twist"] = note_var(p, 1, true);
    symbols["note_half_up"] = note_var(p, -1, false);
    symbols["note_half_down"] = note_var(p, 1, false);
  }
  {
    p = HERSHEY(2372).polylines;
    p = xform(p, (u, v) => scale_axis(u, v, 1, 0.8, 0.4634));
    symbols["note_fill_up_twist"] = note_var(p, -1, true);
    symbols["note_fill_down_twist"] = note_var(p, 1, true);
    symbols["note_fill_up"] = note_var(p, -1, false);
    symbols["note_fill_down"] = note_var(p, 1, false);
  }
  {
    p = HERSHEY(2317).polylines;
    symbols["dot"] = xform(p, (u, v) => [u * 1.1, v * 1.1]);
  }
  {
    p = HERSHEY(2325).polylines;
    symbols["acc_flat"] = xform(p, (u, v) => [u * 0.7, v + 0.5]);
  }
  {
    p = HERSHEY(2324).polylines;
    symbols["acc_nat"] = xform(p, (u, v) => [u * 0.7, v]);
  }
  {
    p = HERSHEY(2323).polylines;
    p = xform(p, (u, v) => [u * 0.9, v * 1.1 - u * 0.2]);
    p[3] = xform(p.slice(3, 4), (u, v) => [u, v + 0.15])[0];
    p[5] = xform(p.slice(5, 6), (u, v) => [u, v + 0.15])[0];
    symbols["acc_sharp"] = p;
  }
  {
    p = HERSHEY(2380).polylines;
    symbols["clef_g"] = xform(p, (u, v) => rotate(u, v, -0.15));
  }
  {
    p = HERSHEY(2381).polylines;
    symbols["clef_f"] = xform(p, (u, v) => [u - 9, v]);
  }
  {
    p = HERSHEY(2382).polylines;
    symbols["clef_c"] = xform(p, (u, v) => [u, v * 0.9]);
  }
  {
    p = HERSHEY(2376).polylines;
    symbols["rest_whole"] = xform(p, (u, v) => [u * 0.85, v * 1.25 + 2.25]);
  }
  {
    p = HERSHEY(2377).polylines;
    symbols["rest_half"] = xform(p, (u, v) => [u, v * 1.25 + 1]);
  }
  {
    p = HERSHEY(2378).polylines;
    symbols["rest_quarter"] = xform(p, (u, v) => rotate(u, v, -0.1));
  }
  {
    p = HERSHEY(2379).polylines;
    symbols["rest_8"] = xform(p, (u, v) => [u, v]);
  }
  {
    p = HERSHEY(2379).polylines;
    let q = xform(p, (u, v) => [u, v]);
    q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
    q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
    p = xform(p, (u, v) => [u - 3.07, v + 10]);
    symbols["rest_16"] = q.concat(p);
  }
  {
    p = HERSHEY(2379).polylines;
    let q = xform(p, (u, v) => [u, v]);
    q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
    q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
    let a = xform(q, (u, v) => [u + 3.07, v - 10]);
    let c = xform(p, (u, v) => [u - 3.07, v + 10]);
    symbols["rest_32"] = a.concat(q).concat(c);
  }
  {
    p = HERSHEY(2379).polylines;
    let q = xform(p, (u, v) => [u, v]);
    q[q.length - 1][q[q.length - 1].length - 1][0] += 0.93;
    q[q.length - 1][q[q.length - 1].length - 1][1] -= 3;
    let a = xform(q, (u, v) => [u + 4.07, v - 10]);
    let b = xform(q, (u, v) => [u + 1, v]);
    let c = xform(p, (u, v) => [u - 2.07, v + 10]);
    let d = xform(p, (u, v) => [u - 5.14, v + 20]);
    symbols["rest_64"] = a.concat(b).concat(c).concat(d);
  }
  {
    p = HERSHEY(2368).polylines;
    p = xform(p, (u, v) => [u + 5, (v + 2.5) * 1.5]);
    symbols["flag_up"] = p;
    p = xform(p, (u, v) => [u, v]);
    p[0].pop();
    p[0].pop();
    p[0][p[0].length - 1][1] += 3;
    symbols["flag_mid_up"] = p;
  }
  {
    p = HERSHEY(2369).polylines;
    p = xform(p, (u, v) => [u + 5, (v - 2.5) * 1.5]);
    symbols["flag_down"] = p;
    p = xform(p, (u, v) => [u, v]);
    p[p.length - 1].shift();
    p[p.length - 1].shift();
    p[p.length - 1][0][1] -= 3;
    symbols["flag_mid_down"] = p;
  }
  {
    for (let i2 = 0; i2 < 10; i2++) {
      p = HERSHEY(3200 + i2).polylines;
      symbols["timesig_digit_" + i2] = xform(p, (u, v) => [u, v * 0.85 + 1.1]);
    }
  }
  {
    for (let i2 = 0; i2 < 10; i2++) {
      p = HERSHEY(2200 + i2).polylines;
      symbols["tuplet_digit_" + i2] = xform(p, (u, v) => [u * 0.5, v * 0.5]);
    }
  }
  {
    p = HERSHEY(3103).polylines;
    symbols["timesig_c"] = xform(p, (u, v) => [u, v * 1.2 - 2.5]);
  }
  {
    p = [[]];
    for (let i2 = 0; i2 < 8; i2++) {
      let a = i2 / 7 * Math.PI;
      p[0].push([Math.cos(a) * 6, 1 - Math.sin(a) * 6]);
    }
    p.push([
      [-1, 1],
      [0, 0],
      [1, 1],
      [0, 2]
    ]);
    symbols["fermata"] = p;
  }
  {
    p = [];
    p.push([
      [-8, 2],
      [-5, -1],
      [-2, 2],
      [1, -1],
      [4, 2],
      [7, -1]
    ]);
    p.push([
      [-4, -2],
      [-1, 1]
    ]);
    p.push([
      [2, -2],
      [5, 1]
    ]);
    symbols["mordent"] = p;
  }
  {
    p = HERSHEY(2274).polylines.slice(-2);
    p = xform(p, (u, v) => rotate(-u * 0.4, v * 0.6, Math.PI / 2));
    symbols["turn"] = p;
  }
  {
    p = xform(HERSHEY(2670).polylines, (u, v) => [u * 0.8 - 4, v * 0.8]).concat(
      xform(HERSHEY(2668).polylines, (u, v) => [u * 0.8 + 4.5, v * 0.8 - 0.5])
    );
    symbols["trill"] = p;
  }
  {
    p = xform(HERSHEY(2218).polylines, (u, v) => [u, v + 8]);
    symbols["flageolet"] = p;
  }
  {
    p = xform(HERSHEY(3316).polylines, (u, v) => [u * 0.8 - 11, v * 0.8 - 3]).concat(xform(HERSHEY(3405).polylines, (u, v) => [u * 0.8 + 0, v * 0.8])).concat(xform(HERSHEY(3404).polylines, (u, v) => [u * 0.8 + 8, v * 0.8])).concat([
      [
        [14, 6],
        [15, 5],
        [16, 6],
        [15, 7]
      ]
    ]);
    symbols["pedal_on"] = xform(p, (u, v) => [u, v + 3]);
  }
  {
    p = [];
    for (let i2 = 0; i2 < 8; i2++) {
      let a = i2 / 8 * Math.PI * 2;
      p = p.concat(
        xform(
          [
            [
              [2, -2],
              [3, 0],
              [7, -0.5],
              [9, -2],
              [11, 0],
              [9, 2],
              [7, 0.5],
              [3, 0],
              [2, 2]
            ]
          ],
          (u, v) => rotate(u * 0.8, v * 0.8, a)
        )
      );
    }
    symbols["pedal_off"] = p;
  }
  {
    p = xform(HERSHEY(2407).polylines, (u, v) => [(u - 5) * 1.25, v / 78 + 0.5]);
    p = xform(p, (u, v) => {
      return v < 0.5 ? [u - 2 * (v / 0.5) - 2, v] : [u - 2 * (1 - v) / 0.5 - 2, v];
    });
    symbols["brace"] = p;
  }
})();
function scale_axis(x, y, sx, sy, th) {
  let u = x * Math.cos(th) - y * Math.sin(th);
  let v = x * Math.sin(th) + y * Math.cos(th);
  u *= sx;
  v *= sy;
  return [
    u * Math.cos(-th) - v * Math.sin(-th),
    u * Math.sin(-th) + v * Math.cos(-th)
  ];
}
function rotate(x, y, th) {
  let u = x * Math.cos(th) - y * Math.sin(th);
  let v = x * Math.sin(th) + y * Math.cos(th);
  return [u, v];
}
function build_slur_bezier(elt) {
  let { tag, x, y, w, h } = elt;
  elt.pts = [];
  elt.pts1 = [];
  let n = 20;
  let sh = 0;
  let x0 = elt.x;
  let y0 = elt.y;
  let x3 = elt.x + elt.w;
  let y3 = elt.y1;
  let a = Math.atan2(y3 - y0, x3 - x0) + Math.PI / 2 * elt.dir;
  let hx = Math.cos(a) * h;
  let hy = Math.sin(a) * h;
  let m0x = x0 * 0.8 + x3 * 0.2;
  let m0y = y0 * 0.8 + y3 * 0.2;
  let m1x = x0 * 0.2 + x3 * 0.8;
  let m1y = y0 * 0.2 + y3 * 0.8;
  let x1a = m0x + hx;
  let y1a = m0y + hy;
  let x2a = m1x + hx;
  let y2a = m1y + hy;
  let x1b = elt.x + elt.w * 0.2;
  let y1b = elt.y + elt.dir * h;
  let x2b = elt.x + elt.w * 0.8;
  let y2b = elt.y1 + elt.dir * h;
  let x1 = x1a * 0.5 + x1b * 0.5;
  let y1 = y1a * 0.5 + y1b * 0.5;
  let x2 = x2a * 0.5 + x2b * 0.5;
  let y2 = y2a * 0.5 + y2b * 0.5;
  y0 += sh;
  y1 += sh;
  y2 += sh;
  y3 += sh;
  elt.control = [
    [x0, y0],
    [x1, y1],
    [x2, y2],
    [x3, y3]
  ];
  let p = [];
  for (let i2 = 0; i2 < n; i2++) {
    let t = i2 / (n - 1);
    elt.pts.push(cubic_bezier(x0, y0, x1, y1, x2, y2, x3, y3, t));
  }
  p = [];
  for (let i2 = 2; i2 < n - 2; i2++) {
    let t = 1 - i2 / (n - 1);
    elt.pts1.push(
      cubic_bezier(x0, y0, x1, y1 - elt.dir, x2, y2 - elt.dir, x3, y3, t)
    );
  }
}
function build_cue(elt) {
  let { tag, x, y, w, h } = elt;
  elt.pts = [];
  function push_all(p) {
    for (let i2 = 0; i2 < p.length; i2++) {
      if (p[i2].length <= 1) continue;
      elt.pts.push(p[i2]);
    }
  }
  if (elt.text == CUE.PEDAL_ON) {
    let p = symbols["pedal_on"];
    let scl = elt.h / 24;
    push_all(xform(p, (u, v) => [x + u * scl, y + v * scl + h / 2]));
  } else if (elt.text == CUE.PEDAL_OFF) {
    let p = symbols["pedal_off"];
    let scl = elt.h / 24;
    push_all(xform(p, (u, v) => [x + u * scl, y + v * scl + h / 2]));
  } else if (elt.text == CUE.PIANISSISSIMO || elt.text == CUE.PIANISSIMO || elt.text == CUE.PIANO || elt.text == CUE.MEZZO_PIANO || elt.text == CUE.MEZZO_FORTE || elt.text == CUE.FORTE || elt.text == CUE.FORTISSIMO || elt.text == CUE.FORTISSISSIMO || elt.text == CUE.SFORZANDO) {
    let v = get_text_width(elt.text, FONT.TRIPLEX_ITALIC);
    let scl = elt.h / 30;
    let dx = -v / 2 * scl;
    for (let i2 = 0; i2 < elt.text.length; i2++) {
      if (elt.text[i2] == " ") {
        dx += 10 * scl;
        continue;
      }
      let a = ascii_map(elt.text[i2], FONT.TRIPLEX_ITALIC);
      if (a === void 0) {
        continue;
      }
      let e = HERSHEY(a);
      push_all(
        xform(e.polylines, (u, v2) => [
          x + dx + (u - e.xmin) * scl,
          y + (v2 + 14) * scl
        ])
      );
      dx += (e.xmax - e.xmin - 3) * scl;
    }
  } else {
    let v = get_text_width(elt.text, FONT.DUPLEX_ITALIC);
    let scl = elt.h / 40;
    let dx = 0;
    for (let i2 = 0; i2 < elt.text.length; i2++) {
      if (elt.text[i2] == " ") {
        dx += 10 * scl;
        continue;
      }
      let a = ascii_map(elt.text[i2], FONT.DUPLEX_ITALIC);
      if (a === void 0) {
        continue;
      }
      let e = HERSHEY(a);
      push_all(
        xform(e.polylines, (u, v2) => [
          x + dx + (u - e.xmin) * scl,
          y + (v2 + 18) * scl
        ])
      );
      dx += (e.xmax - e.xmin) * scl;
    }
  }
}
function bounding_box(p) {
  let xmin = Infinity;
  let ymin = Infinity;
  let xmax = -Infinity;
  let ymax = -Infinity;
  for (let i2 = 0; i2 < p.length; i2++) {
    if (Array.isArray(p[i2][0])) {
      for (let j = 0; j < p[i2].length; j++) {
        xmin = Math.min(xmin, p[i2][j][0]);
        ymin = Math.min(ymin, p[i2][j][1]);
        xmax = Math.max(xmax, p[i2][j][0]);
        ymax = Math.max(ymax, p[i2][j][1]);
      }
    } else {
      xmin = Math.min(xmin, p[i2][0]);
      ymin = Math.min(ymin, p[i2][1]);
      xmax = Math.max(xmax, p[i2][0]);
      ymax = Math.max(ymax, p[i2][1]);
    }
  }
  return { x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin };
}
function box_overlap(a, b) {
  return a.x <= b.x + b.w && a.x + a.w >= b.x && a.y <= b.y + b.h && a.y + a.h >= b.y;
}
function point_in_box(x, y, b) {
  return b.x <= x && x <= b.x + b.w && b.y <= y && y <= b.y + b.h;
}
function cue_evade_slur(elements) {
  let slurs = [];
  let cues = [];
  for (let i2 = 0; i2 < elements.length; i2++) {
    if (elements[i2].tag == "cue") {
      if (!elements[i2].pts) {
        build_cue(elements[i2]);
      }
      if (!elements[i2].bbox) {
        elements[i2].bbox = bounding_box(elements[i2].pts);
      }
      cues.push(elements[i2]);
    } else if (elements[i2].tag == "slur") {
      if (!elements[i2].pts) {
        build_slur_bezier(elements[i2]);
      }
      if (!elements[i2].bbox) {
        elements[i2].bbox = bounding_box(elements[i2].pts);
      }
      slurs.push(elements[i2]);
    } else if (elements[i2].tag == "cresc") {
      let { x, y, w, h, x1, y1, w1, h1 } = elements[i2];
      elements[i2].bbox = bounding_box([
        [x, y],
        [x + w, y + h],
        [x1, y1],
        [x1 + w1, y1 + h1]
      ]);
      cues.push(elements[i2]);
    }
  }
  function resolve_(cue, depth = 5) {
    if (depth <= 0) {
      return;
    }
    for (let j = 0; j < slurs.length; j++) {
      if (box_overlap(cue.bbox, slurs[j].bbox)) {
        let hit = false;
        let dir = null;
        for (let k = 0; k < slurs[j].pts.length; k++) {
          if (point_in_box(slurs[j].pts[k][0], slurs[j].pts[k][1], cue.bbox)) {
            hit = true;
            dir = cue.bbox.y + cue.bbox.h / 2 < slurs[j].bbox.y + slurs[j].bbox.h / 2 ? -1 : 1;
            break;
          }
        }
        if (hit) {
          let d = dir * Math.min(4, Math.max(2, depth));
          cue.y += d;
          cue.bbox.y += d;
          if (cue.y1 != void 0) {
            cue.y1 += d;
          }
          cue.pts = null;
          return resolve_(cue, depth - 1);
        }
      }
    }
  }
  for (let i2 = 0; i2 < cues.length; i2++) {
    resolve_(cues[i2]);
  }
}
function slur_evade_note(elements) {
  let slurs = [];
  let notes = [];
  for (let i2 = 0; i2 < elements.length; i2++) {
    if (elements[i2].tag == "note_head") {
      let elt = elements[i2];
      let { x, y, w, h } = elt;
      x -= 1;
      y -= 1;
      w += 2;
      h += 2;
      if (!elt.bbox) {
        if (elt.stem_dir < 0) {
          if (elt.twisted) {
            elt.bbox = { x, y: y - h / 2, w, h };
          } else {
            elt.bbox = { x: x - w, y: y - h / 2, w, h };
          }
        } else {
          if (!elt.twisted) {
            elt.bbox = { x, y: y - h / 2, w, h };
          } else {
            elt.bbox = { x: x - w, y: y - h / 2, w, h };
          }
        }
      }
      notes.push(elements[i2]);
    } else if (elements[i2].tag == "slur") {
      if (!elements[i2].pts) {
        build_slur_bezier(elements[i2]);
      }
      if (!elements[i2].bbox) {
        elements[i2].bbox = bounding_box(elements[i2].pts);
      }
      slurs.push(elements[i2]);
    }
  }
  function resolve_(slur, depth = 5) {
    if (depth <= 0) {
      return;
    }
    for (let j = 0; j < notes.length; j++) {
      if (box_overlap(slur.bbox, notes[j].bbox)) {
        let hit = false;
        let dir = slur.dir;
        for (let k = 0; k < slur.pts.length; k++) {
          if (point_in_box(slur.pts[k][0], slur.pts[k][1], notes[j].bbox)) {
            hit = true;
            break;
          }
        }
        if (hit) {
          let d = dir * Math.min(4, Math.max(2, depth));
          slur.y += d;
          slur.y1 += d;
          slur.bbox.y += d;
          slur.pts.forEach((xy) => {
            xy[1] += d;
          });
          slur.pts1.forEach((xy) => {
            xy[1] += d;
          });
          return resolve_(slur, depth - 1);
        }
      }
    }
  }
  for (let i2 = 0; i2 < slurs.length; i2++) {
    if (slurs[i2].adjacent) {
      continue;
    }
    resolve_(slurs[i2]);
  }
}
function hf_drawing_polylines(elements, width, height) {
  let polylines = [];
  function push_all(p) {
    for (let i2 = 0; i2 < p.length; i2++) {
      if (p[i2].length <= 1) continue;
      polylines.push(p[i2]);
    }
  }
  for (let i2 = 0; i2 < elements.length; i2++) {
    let elt = elements[i2];
    let { tag, x, y, w, h } = elt;
    if (tag == "note_head") {
      let p;
      let key = (elt.stem_dir < 0 ? "_up" : "_down") + (elt.twisted ? "_twist" : "");
      if (elt.duration >= NOTE_LENGTH.WHOLE) {
        key = "note_whole" + key;
      } else if (elt.duration >= NOTE_LENGTH.HALF) {
        key = "note_half" + key;
      } else {
        key = "note_fill" + key;
      }
      p = symbols[key];
      if (elt.mini) p = xform(p, (u, v) => [u / 2, v / 2]);
      push_all(xform(p, (u, v) => [x + u, y + v]));
    } else if (tag == "dot") {
      let p = symbols["dot"];
      if (elt.mini) p = xform(p, (u, v) => [u / 2, v / 2]);
      push_all(xform(p, (u, v) => [x + u, y + v]));
    } else if (tag == "accidental") {
      let p;
      if (elt.type == ACCIDENTAL.FLAT) {
        p = symbols["acc_flat"];
      } else if (elt.type == ACCIDENTAL.NATURAL) {
        p = symbols["acc_nat"];
      } else if (elt.type == ACCIDENTAL.SHARP) {
        p = symbols["acc_sharp"];
      }
      if (elt.mini) p = xform(p, (u, v) => [u / 2, v / 2]);
      push_all(xform(p, (u, v) => [x + u, y + v]));
    } else if (tag == "clef") {
      let p;
      if (elt.type == CLEF.TREBLE) {
        p = symbols["clef_g"];
      } else if (elt.type == CLEF.BASS) {
        p = symbols["clef_f"];
      } else {
        p = symbols["clef_c"];
      }
      push_all(xform(p, (u, v) => [x + u, y + v]));
    } else if (tag == "rest") {
      if (elt.duration == NOTE_LENGTH.WHOLE) {
        let p = symbols["rest_whole"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.HALF) {
        let p = symbols["rest_half"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.QUARTER) {
        let p = symbols["rest_quarter"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.EIGHTH) {
        let p = symbols["rest_8"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.SIXTEENTH) {
        let p = symbols["rest_16"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.THIRTYSECOND) {
        let p = symbols["rest_32"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (elt.duration == NOTE_LENGTH.SIXTYFOURTH) {
        let p = symbols["rest_64"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      }
    } else if (tag == "flag") {
      if (elt.stem_dir < 0) {
        let p = elt.is_last ? symbols["flag_up"] : symbols["flag_mid_up"];
        if (elt.mini) p = xform(p, (u, v) => [u / 2, v / 2]);
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else {
        let p = elt.is_last ? symbols["flag_down"] : symbols["flag_mid_down"];
        if (elt.mini) p = xform(p, (u, v) => [u / 2, v / 2]);
        push_all(xform(p, (u, v) => [x + u, y + v]));
      }
    } else if (tag == "beam") {
      for (let j = 0.3; j < 4.66; j += 1.09) {
        polylines.push([
          [x, y - j * elt.stem_dir],
          [x + w, y + h - j * elt.stem_dir]
        ]);
      }
    } else if (tag == "line") {
      polylines.push([
        [x, y],
        [x + w, y + h]
      ]);
    } else if (tag == "cresc") {
      let p = [
        [
          [x, y],
          [x + w, y + h]
        ],
        [
          [elt.x1, elt.y1],
          [elt.x1 + elt.w1, elt.y1 + elt.h1]
        ]
      ];
      push_all(p);
    } else if (tag == "slur") {
      if (!elt.pts) {
        build_slur_bezier(elt);
      }
      polylines.push(elt.pts);
      polylines.push(elt.pts1);
    } else if (tag == "timesig_digit") {
      let p = symbols["timesig_digit_" + elt.value];
      push_all(xform(p, (u, v) => [x + u, y + v]));
    } else if (tag == "timesig_c") {
      let p = symbols["timesig_c"];
      push_all(xform(p, (u, v) => [x + u, y + v]));
      if (elt.type == "cut") {
        polylines.push([
          [x, y - 14],
          [x, y + 14]
        ]);
      }
    } else if (tag == "tuplet_label") {
      let digits = elt.label.toString().split("");
      let mid = x + w / 2;
      let mw = digits.length;
      let dw = 8;
      let dp = 4;
      let ml = mid - mw / 2 * dw - dp;
      let mr = mid + mw / 2 * dw + dp;
      if (ml >= x && mr <= x + w) {
        polylines.push([
          [x, y],
          [x, y + h],
          [ml, y + h]
        ]);
        polylines.push([
          [mr, y + h],
          [x + w, y + h],
          [x + w, y]
        ]);
      }
      for (let i3 = 0; i3 < digits.length; i3++) {
        let p = symbols["tuplet_digit_" + digits[i3]];
        push_all(xform(p, (u, v) => [ml + dp + dw * i3 + u + 4, y + h + v]));
      }
    } else if (tag == "lyric") {
      let scl = w / get_text_width(elt.text);
      let dx = -4 * scl;
      for (let i3 = 0; i3 < elt.text.length; i3++) {
        if (elt.text[i3] == " ") {
          dx += 10 * scl;
          continue;
        }
        let a = ascii_map(elt.text[i3]);
        if (a === void 0) {
          continue;
        }
        let e = HERSHEY(a);
        push_all(
          xform(e.polylines, (u, v) => [
            x + dx + (u - e.xmin) * scl,
            y + (v + 12) * scl
          ])
        );
        dx += (e.xmax - e.xmin) * scl;
      }
    } else if (tag == "bold_text") {
      let scl = w / get_text_width(elt.text, FONT.TRIPLEX, -2);
      if (isNaN(scl)) scl = 1;
      let dx = 0;
      for (let i3 = 0; i3 < elt.text.length; i3++) {
        if (elt.text[i3] == " ") {
          dx += 10 * scl;
          continue;
        }
        let a = ascii_map(elt.text[i3], FONT.TRIPLEX);
        if (a === void 0) {
          continue;
        }
        let e = HERSHEY(a);
        push_all(
          xform(e.polylines, (u, v) => [
            x + dx + (u - e.xmin) * scl,
            y + (v + 12) * scl
          ])
        );
        dx += (e.xmax - e.xmin - 2) * scl;
      }
    } else if (tag == "regular_text") {
      let scl = w / get_text_width(elt.text, FONT.DUPLEX, -2);
      if (isNaN(scl)) scl = 1;
      let dx = 0;
      for (let i3 = 0; i3 < elt.text.length; i3++) {
        if (elt.text[i3] == " ") {
          dx += 10 * scl;
          continue;
        }
        let a = ascii_map(elt.text[i3], FONT.DUPLEX);
        if (a === void 0) {
          continue;
        }
        let e = HERSHEY(a);
        push_all(
          xform(e.polylines, (u, v) => [
            x + dx + (u - e.xmin) * scl,
            y + (v + 12) * scl
          ])
        );
        dx += (e.xmax - e.xmin - 2) * scl;
      }
    } else if (tag == "bracket") {
      if (elt.type == BRACKET.BRACE) {
        let p = symbols["brace"];
        push_all(xform(p, (u, v) => [x + u, y + v * h]));
      } else if (elt.type == BRACKET.BRACKET) {
        polylines.push([
          [x + 5, y - 12],
          [x - 2, y - 8],
          [x - 8, y - 7],
          [x - 8, y + h + 7],
          [x - 2, y + h + 8],
          [x + 5, y + h + 12]
        ]);
        polylines.push([
          [x + 5, y - 12],
          [x - 1, y - 8],
          [x - 7, y - 6],
          [x - 7, y + h + 6],
          [x - 1, y + h + 8],
          [x + 5, y + h + 12]
        ]);
        polylines.push([
          [x - 6, y - 5],
          [x - 6, y + h + 5]
        ]);
      }
    } else if (tag == "articulation") {
      let a = Math.abs(elt.type);
      if (a == ARTICULATION.STACCATO) {
        let p = symbols["dot"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (a == ARTICULATION.ACCENT) {
        let p = [
          [x - 5, y - 3],
          [x + 5, y],
          [x - 5, y + 3]
        ];
        polylines.push(p);
      } else if (a == ARTICULATION.SPICCATO) {
        let p = [
          [x - 1, y - 3],
          [x, y + 3],
          [x + 1, y - 3],
          [x - 1, y - 3]
        ];
        polylines.push(p);
      } else if (a == ARTICULATION.TENUTO) {
        let p = [
          [x - 4, y],
          [x + 4, y]
        ];
        polylines.push(p);
      } else if (a == ARTICULATION.MARCATO) {
        let p = [
          [x - 3, y + 3],
          [x, y - 3],
          [x + 3, y + 3]
        ];
        polylines.push(p);
      } else if (a == ARTICULATION.UP_BOW) {
        let p = [
          [x - 3, y - 3],
          [x, y + 3],
          [x + 3, y - 3]
        ];
        polylines.push(p);
      } else if (a == ARTICULATION.TREMBLEMENT) {
        let p = [
          [
            [x - 4, y],
            [x + 4, y]
          ],
          [
            [x, y - 4],
            [x, y + 4]
          ]
        ];
        push_all(p);
      } else if (a == ARTICULATION.FERMATA) {
        let p = symbols["fermata"];
        push_all(xform(p, (u, v) => [x + u, y + v * elt.dir]));
      } else if (a == ARTICULATION.MORDENT) {
        let p = symbols["mordent"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (a == ARTICULATION.TURN) {
        let p = symbols["turn"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (a == ARTICULATION.TRILL) {
        let p = symbols["trill"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else if (a == ARTICULATION.FLAGEOLET) {
        let p = symbols["flageolet"];
        push_all(xform(p, (u, v) => [x + u, y + v]));
      } else {
        let p = HERSHEY(ascii_map(elt.type.toString(), FONT.TRIPLEX)).polylines;
        push_all(xform(p, (u, v) => [x + u / 2, y + v / 2]));
      }
      if (elt.type < 0) {
        let p = [
          [x, y - 5],
          [x, y + 5]
        ];
        polylines.push(p);
      }
    } else if (tag == "squiggle") {
      let p = [];
      let q = [];
      let f = false;
      let h2 = Math.ceil(h / 8) * 8;
      let y2 = y - (h2 - h) / 2;
      for (let i3 = 0; i3 < h2; i3 += 4) {
        p.push([f ? x + 2 : x - 2, y2 + i3]);
        if (f && i3 + 4 < h2) {
          q.push([
            [x + 2.8, i3 + y2 + 0.8],
            [x - 1.2, i3 + y2 + 4.8]
          ]);
        }
        f = !f;
      }
      polylines.push(p);
      push_all(q);
    } else if (tag == "cue") {
      if (!elt.pts) {
        build_cue(elt);
      }
      push_all(elt.pts);
    }
  }
  return polylines;
}
function round_polylines(polylines, accuracy = 2) {
  let n = Math.pow(10, accuracy);
  for (let i2 = 0; i2 < polylines.length; i2++) {
    for (let j = 0; j < polylines[i2].length; j++) {
      let [x, y] = polylines[i2][j];
      x = Math.round(x * n) / n;
      y = Math.round(y * n) / n;
      polylines[i2][j][0] = x;
      polylines[i2][j][1] = y;
    }
  }
}
function export_svg(dr, { background = "white" } = {}) {
  let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${dr.w}" height="${dr.h}">`;
  if (background) {
    o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="${background}"></rect>`;
  }
  o += `<path stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none" d="`;
  for (let i2 = 0; i2 < dr.polylines.length; i2++) {
    o += "M ";
    for (let j = 0; j < dr.polylines[i2].length; j++) {
      o += dr.polylines[i2][j] + " ";
    }
  }
  o += `"/>`;
  o += `</svg>`;
  return o;
}
function export_animated_svg(dr, {
  background = "white",
  speed = 1e-3
} = {}) {
  let width = dr.w;
  let height = dr.h;
  let polylines = dr.polylines;
  let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">`;
  if (background) {
    o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="${background}"></rect>`;
  }
  let lengths = [];
  let acc_lengths = [];
  let total_l = 0;
  for (let i2 = 0; i2 < polylines.length; i2++) {
    let l = 0;
    for (let j = 1; j < polylines[i2].length; j++) {
      l += Math.hypot(
        polylines[i2][j - 1][0] - polylines[i2][j][0],
        polylines[i2][j - 1][1] - polylines[i2][j][1]
      );
    }
    lengths.push(l);
    acc_lengths.push(total_l);
    total_l += l;
  }
  for (let i2 = 0; i2 < polylines.length; i2++) {
    let l = lengths[i2];
    o += `
    <path
      stroke="black"
      stroke-width="1.5"
      fill="none"
      stroke-dasharray="${l}"
      stroke-dashoffset="${l}"
      d="M`;
    for (let j = 0; j < polylines[i2].length; j++) {
      o += polylines[i2][j] + " ";
    }
    let t = speed * l;
    o += `">
    <animate id="a${i2}"
      attributeName="stroke-dashoffset"
      fill="freeze"
      from="${l}" to="${0}" dur="${t}s"
      begin="${acc_lengths[i2] * speed}s;a${i2}.end+${1 + speed * total_l}s"/>
    />
    <animate id="b${i2}"
      attributeName="stroke-dashoffset"
      fill="freeze"
      from="${0}" to="${l}" dur="${1}s"
      begin="${speed * total_l}s;b${i2}.end+${speed * total_l}s"/>
    />
    </path>`;
  }
  o += `</svg>`;
  return o;
}
function export_pdf(dr) {
  let width = dr.w;
  let height = dr.h;
  let polylines = dr.polylines;
  var head = `%PDF-1.1
%%\xA5\xB1\xEB
1 0 obj
<< /Type /Catalog
/Pages 2 0 R
>>endobj
    2 0 obj
<< /Type /Pages
/Kids [3 0 R]
/Count 1
/MediaBox [0 0 ${width} ${height}]
>>
endobj
    3 0 obj
<< /Type /Page
/Parent 2 0 R
/Resources
<< /Font
<< /F1
<< /Type /Font
    /Subtype /Type1
/BaseFont /Times-Roman
>>
>>
>>
/Contents [`;
  var pdf = "";
  var count = 4;
  for (var i2 = 0; i2 < polylines.length; i2++) {
    pdf += `${count} 0 obj 
<< /Length 0 >>
 stream
 1 j 1 J 1.5 w
`;
    for (var j = 0; j < polylines[i2].length; j++) {
      var [x, y] = polylines[i2][j];
      pdf += `${x} ${height - y} ${j ? "l" : "m"} `;
    }
    pdf += "\nS\nendstream\nendobj\n";
    head += `${count} 0 R `;
    count++;
  }
  head += "]\n>>\nendobj\n";
  pdf += "\ntrailer\n<< /Root 1 0 R \n /Size 0\n >>startxref\n\n%%EOF\n";
  return head + pdf;
}
function xiaolinwu(data2, w, h, x0, y0, x1, y1) {
  function plot(x, y, c) {
    data2[y * w + x] = 1 - (1 - data2[y * w + x]) * (1 - c);
  }
  function ipart(x) {
    return Math.floor(x);
  }
  function round(x) {
    return ipart(x + 0.5);
  }
  function fpart(x) {
    return x - Math.floor(x);
  }
  function rfpart(x) {
    return 1 - fpart(x);
  }
  function drawline(x02, y02, x12, y12) {
    let steep = Math.abs(y12 - y02) > Math.abs(x12 - x02);
    if (steep) {
      ;
      [x02, y02] = [y02, x02];
      [x12, y12] = [y12, x12];
    }
    if (x02 > x12) {
      ;
      [x02, x12] = [x12, x02];
      [y02, y12] = [y12, y02];
    }
    let dx = x12 - x02;
    let dy = y12 - y02;
    let gradient = dy / dx;
    if (dx == 0) {
      gradient = 1;
    }
    let xend = round(x02);
    let yend = y02 + gradient * (xend - x02);
    let xgap = rfpart(x02 + 0.5);
    let xpxl1 = xend;
    let ypxl1 = ipart(yend);
    if (steep) {
      plot(ypxl1, xpxl1, rfpart(yend) * xgap);
      plot(ypxl1 + 1, xpxl1, fpart(yend) * xgap);
    } else {
      plot(xpxl1, ypxl1, rfpart(yend) * xgap);
      plot(xpxl1, ypxl1 + 1, fpart(yend) * xgap);
    }
    let intery = yend + gradient;
    xend = round(x12);
    yend = y12 + gradient * (xend - x12);
    xgap = fpart(x12 + 0.5);
    let xpxl2 = xend;
    let ypxl2 = ipart(yend);
    if (steep) {
      plot(ypxl2, xpxl2, rfpart(yend) * xgap);
      plot(ypxl2 + 1, xpxl2, fpart(yend) * xgap);
    } else {
      plot(xpxl2, ypxl2, rfpart(yend) * xgap);
      plot(xpxl2, ypxl2 + 1, fpart(yend) * xgap);
    }
    if (steep) {
      for (let x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
        plot(ipart(intery), x, rfpart(intery));
        plot(ipart(intery) + 1, x, fpart(intery));
        intery = intery + gradient;
      }
    } else {
      for (let x = xpxl1 + 1; x <= xpxl2 - 1; x++) {
        plot(x, ipart(intery), rfpart(intery));
        plot(x, ipart(intery) + 1, fpart(intery));
        intery = intery + gradient;
      }
    }
  }
  drawline(x0, y0, x1, y1);
}
function encode_gif(data2, w, h) {
  let bytes = [];
  bytes.push(71, 73, 70, 56, 57, 97);
  bytes.push(w & 255);
  bytes.push(w >> 8 & 255);
  bytes.push(h & 255);
  bytes.push(h >> 8 & 255);
  bytes.push(246);
  bytes.push(0, 0);
  for (let i2 = 0; i2 < 127; i2++) {
    bytes.push(i2 * 2, i2 * 2, i2 * 2);
  }
  bytes.push(255, 255, 255);
  bytes.push(44, 0, 0, 0, 0);
  bytes.push(w & 255);
  bytes.push(w >> 8 & 255);
  bytes.push(h & 255);
  bytes.push(h >> 8 & 255);
  bytes.push(0, 7);
  let n = ~~(w * h / 126);
  let inc = n * 126;
  let exc = w * h - inc;
  for (let i2 = 0; i2 < n; i2++) {
    bytes.push(127);
    bytes.push(128);
    for (let j = 0; j < 126; j++) {
      bytes.push(~~(data2[i2 * 126 + j] * 127));
    }
  }
  if (exc) {
    bytes.push(exc + 1);
    bytes.push(128);
    for (let i2 = 0; i2 < exc; i2++) {
      bytes.push(~~(data2[inc + i2] * 127));
    }
  }
  bytes.push(1, 129, 0, 59);
  return bytes;
}
function export_gif(dr, { scale = 1, iter = 2 } = {}) {
  let scl = 1 / scale;
  let w = ~~(dr.w / scl);
  let h = ~~(dr.h / scl);
  let polylines = dr.polylines;
  let data2 = new Array(w * h).fill(0);
  for (var i2 = 0; i2 < polylines.length; i2++) {
    for (var j = 0; j < polylines[i2].length - 1; j++) {
      let x0 = polylines[i2][j][0] / scl;
      let y0 = polylines[i2][j][1] / scl;
      let x1 = polylines[i2][j + 1][0] / scl;
      let y1 = polylines[i2][j + 1][1] / scl;
      for (let k = 0; k < iter; k++) xiaolinwu(data2, w, h, x0, y0, x1, y1);
    }
  }
  for (let i3 = 0; i3 < data2.length; i3++) {
    data2[i3] = 1 - data2[i3];
  }
  let bytes = encode_gif(data2, w, h);
  return bytes;
}

// src/config.ts
var CONFIG = {
  PAGE_WIDTH: 1200,
  LINE_HEIGHT: 9,
  NOTE_WIDTH: 12,
  REST_WIDTH_MUL: 1,
  CLEF_WIDTH_MUL: 2,
  TIMESIG_WIDTH_MUL: 2,
  KEYSIG_WIDTH_MUL: 0.8,
  ACCIDENTAL_WIDTH_MUL: 1.2,
  LEDGER_WIDTH_MUL: 0.75,
  INTER_NOTE_WIDTH: 4,
  DURATION_BASED_SPACING: 0.05,
  FLAG_SPACING: 0.72,
  MEASURE_PAD_FRONT: 12,
  MEASURE_PAD_BACK: 12,
  INTER_STAFF_HEIGHT: 70,
  INTER_ROW_HEIGHT: 100,
  STEM_LENGTH: 2.5,
  PAGE_MARGIN_X: 100,
  PAGE_MARGIN_Y: 50,
  TITLE_TEXT_SIZE: 34,
  SUBTITLE_TEXT_SIZE: 20,
  TITLE_LINE_SPACING: 12,
  TEMPO_COMPOSER_TEXT_SIZE: 14,
  INSTRUMENT_TEXT_SIZE: 16,
  MEASURE_NUMBER_TEXT_SIZE: 12,
  INSTRUMENT_PAD_RIGHT: 20,
  BEAM_MAX_SLOPE: 0.4,
  LINES_PER_STAFF: 5,
  GRACE_WIDTH_MUL: 0.4,
  LYRIC_SCALE: 0.6,
  LYRIC_SPACING: 12,
  CUE_TEXT_SIZE: 22,
  CUE_HEIGHT: 22,
  SQUIGGLE_WIDTH_MUL: 1.5,
  JUSTIFY_ALIGN_MIN: 0.75,
  SLUR_ARC_MUL: 1,
  SHOW_SOLO_INSTRUMENT: 0,
  SHOW_MEASURE_NUMBER: 1,
  HEADBUTT_RESOLVE: 1,
  HEADBUTT_MERGE: 1,
  CUE_EVADE: 1,
  SLUR_EVADE: 1,
  JOIN_STAFF_LINES: 1,
  TUPLET_LABEL_SPACING: 1.1,
  WHOLE_HALF_REST_LEDGERS: 0,
  TIMESIG_COMMON_TIME_C: 0,
  BEAM_POLICY: 3,
  DEBUG_BLOCKS: 0
};
var NOTE_LENGTH_MODIFIER = 1.5;
var FONT_INHERENT_HEIGHT = 24;
function CONTENT_WIDTH() {
  return CONFIG.PAGE_WIDTH - CONFIG.PAGE_MARGIN_X * 2;
}

// src/utils.ts
function on_staff(line) {
  return line * CONFIG.LINE_HEIGHT / 2;
}
function calc_num_flags(length, has_modifier2) {
  return Math.max(
    0,
    ~~(4 - Math.log2(!has_modifier2 ? length : length / NOTE_LENGTH_MODIFIER))
  );
}
function interval_overlap(x1, x2, y1, y2) {
  return x1 < y2 && y1 < x2;
}
function slot_pos(measure, begin, out) {
  let slots = measure.slots;
  let r = 0;
  let s = measure.pad.left;
  let t = 0;
  if (measure.staves.some((x) => x.flags.need_clef)) {
    s += CONFIG.CLEF_WIDTH_MUL * CONFIG.NOTE_WIDTH;
    t++;
    s += measure.pad.inter;
  }
  if (measure.staves.some((x) => x.flags.need_timesig)) {
    s += CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH;
    t++;
    s += measure.pad.inter;
  }
  if (measure.staves.some((x) => x.flags.need_keysig)) {
    let num_acc = 0;
    for (let i2 = 0; i2 < measure.staves.length; i2++) {
      num_acc = Math.max(num_acc, measure.staves[i2].key_signature[1]);
    }
    s += num_acc * CONFIG.KEYSIG_WIDTH_MUL * CONFIG.NOTE_WIDTH;
    t++;
    s += measure.pad.inter;
  }
  for (let i2 = 0; i2 < begin; i2++) {
    if (slots[i2].left_grace) {
      s += measure.pad.inter * 2;
      r += slots[i2].left_grace;
      t += 2;
    }
    let w_real = slots[i2].left_note + slots[i2].right_note + slots[i2].mid_note + slots[i2].left_deco + slots[i2].right_deco + slots[i2].left_squiggle;
    let w = w_real + slots[i2].right_spacing;
    r += w;
    if (w_real) {
      s += measure.pad.inter;
      t++;
    }
  }
  if (slots[begin]) {
    if (slots[begin].left_grace) {
      s += measure.pad.inter * 2;
      r += slots[begin].left_grace;
      t += 2;
    }
    r += slots[begin].left_note + slots[begin].left_deco + slots[begin].left_squiggle;
  } else if (begin >= slots.length) {
    s += measure.pad.right - measure.pad.inter;
    t--;
  } else if (begin < 0) {
    s -= measure.pad.left;
  }
  if (out) {
    out[0] = r;
    out[1] = t;
    out[2] = s;
  }
  return r * CONFIG.NOTE_WIDTH + s;
}

// src/render.ts
var id_registry = {};
function draw_staff(measure, staff_idx, no_staff_lines = false) {
  let staff = measure.staves[staff_idx];
  let notes = staff.notes;
  let rests = staff.rests;
  let result = [];
  let slots = measure.slots;
  let ledgers = new Array(measure.duration).fill(null).map((_) => /* @__PURE__ */ new Set());
  function put_ledgers_as_necessary(begin, line) {
    if (line < 0) {
      for (let i2 = Math.floor((line + 1) / 2) * 2; i2 < 0; i2 += 2) {
        ledgers[begin].add(i2);
      }
    } else if (line > 9) {
      for (let i2 = 10; i2 < ~~(line / 2) * 2 + 1; i2 += 2) {
        ledgers[begin].add(i2);
      }
    }
  }
  function draw_ledgers() {
    for (let i2 = 0; i2 < ledgers.length; i2++) {
      let slot = slots[i2];
      let slot_x = slot_pos(measure, i2);
      for (let line of ledgers[i2]) {
        result.push({
          tag: "line",
          type: "ledger",
          x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - CONFIG.LEDGER_WIDTH_MUL / 2 * CONFIG.NOTE_WIDTH,
          y: on_staff(line),
          w: CONFIG.NOTE_WIDTH * (CONFIG.LEDGER_WIDTH_MUL + slot.left_note + slot.mid_note + slot.right_note),
          h: 0
        });
      }
    }
  }
  function note_head_center_x(note, slot_x) {
    let slot = slots[note.begin];
    let x = slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note);
    if (note.stem_dir < 0) {
      if (note.twisted) {
        x += CONFIG.NOTE_WIDTH / 2;
      } else {
        x -= CONFIG.NOTE_WIDTH / 2;
      }
    } else {
      if (note.twisted) {
        x -= CONFIG.NOTE_WIDTH / 2;
      } else {
        x += CONFIG.NOTE_WIDTH / 2;
      }
    }
    return x;
  }
  function draw_note(note, slot_x, line) {
    let slot = slots[note.begin];
    let head_note = note;
    let tail_note = note;
    let modifier_x = slot_x + CONFIG.NOTE_WIDTH * (slot.mid_note + slot.right_note + 0.5);
    slot_x += note.slot_shift;
    modifier_x += note.modifier_shift;
    while (head_note.prev_in_chord != null) {
      head_note = notes[head_note.prev_in_chord];
    }
    while (tail_note.next_in_chord != null) {
      tail_note = notes[tail_note.next_in_chord];
    }
    if (note.id) {
      let x = slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note);
      let reg = {
        note,
        staff_idx,
        measure,
        row: null,
        col: null,
        chord_head_x: note_head_center_x(head_note, slot_x),
        chord_head_y: on_staff(head_note.staff_pos),
        head_x: note_head_center_x(note, slot_x),
        tail_x: x,
        head_y: on_staff(note.staff_pos),
        tail_y: null
      };
      let n = note;
      while (n.next_in_chord !== null) {
        n = staff.notes[n.next_in_chord];
      }
      let y1 = on_staff(n.staff_pos);
      y1 += n.stem_len * n.stem_dir * CONFIG.LINE_HEIGHT;
      reg.tail_y = y1;
      reg.chord_head_x += staff.coords.x;
      reg.chord_head_y += staff.coords.y;
      reg.head_x += staff.coords.x;
      reg.head_y += staff.coords.y;
      reg.tail_x += staff.coords.x;
      reg.tail_y += staff.coords.y;
      reg.row = staff.coords.row;
      reg.col = staff.coords.col;
      id_registry[note.id] = reg;
    }
    if (note.modifier) {
      result.push({
        tag: "dot",
        type: "modifier",
        x: modifier_x,
        y: on_staff(line % 2 ? line : line + (note.voice % 2 ? 1 : -1)),
        w: 0,
        h: 0
      });
    }
    if (note.articulation) {
      if (note.articulation != ARTICULATION.ARPEGGIATED) {
        let [xx, yy] = note.articulation_pos;
        let x = xx ? slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note) : note_head_center_x(note, slot_x);
        let y = on_staff(yy);
        result.push({
          tag: "articulation",
          type: note.articulation,
          dir: (xx ? -1 : 1) * note.stem_dir,
          x,
          y,
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT
        });
      } else {
        let lh = head_note.staff_pos;
        let lt = tail_note.staff_pos;
        let ya = on_staff(lh - note.stem_dir);
        let line_b = Math.round(lt + note.stem_dir);
        let yb = on_staff(line_b);
        let y0 = Math.min(ya, yb);
        let y1 = Math.max(ya, yb);
        result.push({
          tag: "squiggle",
          type: "arpeggiated_chord",
          x: slot_x - (slot.left_deco + slot.left_note + slot.left_squiggle / 2) * CONFIG.NOTE_WIDTH,
          y: y0,
          w: 0,
          h: y1 - y0
        });
      }
    }
    result.push({
      tag: "note_head",
      x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
      y: on_staff(line),
      w: CONFIG.NOTE_WIDTH,
      h: CONFIG.LINE_HEIGHT,
      twisted: note.twisted,
      stem_dir: note.stem_dir,
      duration: note.duration
    });
    if (!note.beamed && note.stem_len != 0 && note.duration < NOTE_LENGTH.WHOLE) {
      let y0 = note.stem_len * note.stem_dir;
      let y1 = 0;
      let y = y0;
      let h = y1 - y;
      result.push({
        tag: "line",
        type: "note_stem",
        x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
        y: on_staff(line + y * 2),
        w: 0,
        h: CONFIG.LINE_HEIGHT * h
      });
    }
    if (!note.beamed && note.flag_count) {
      let flagcnt = note.flag_count;
      for (let i2 = 0; i2 < flagcnt; i2++) {
        let y = (note.stem_len - i2 * CONFIG.FLAG_SPACING) * note.stem_dir * 2;
        result.push({
          tag: "flag",
          x: slot_x + CONFIG.NOTE_WIDTH * (Number(note.stem_dir < 0) * slot.mid_note),
          y: on_staff(line + y),
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT,
          stem_dir: note.stem_dir,
          is_last: i2 == flagcnt - 1
        });
      }
    }
  }
  function draw_accidental(acc, slot_x, line) {
    result.push({
      tag: "accidental",
      type: acc,
      x: slot_x,
      y: on_staff(line),
      w: CONFIG.NOTE_WIDTH,
      h: CONFIG.LINE_HEIGHT
    });
  }
  function draw_rest(rest, slot_x) {
    let dur = rest.duration;
    if (rest.tuplet) {
      dur = rest.tuplet.display_duration;
    }
    let y = rest.staff_pos;
    if (CONFIG.WHOLE_HALF_REST_LEDGERS) {
      if (dur == NOTE_LENGTH.WHOLE) {
        let slot = slots[rest.begin];
        let line2 = y - 2;
        result.push({
          tag: "line",
          type: "ledger",
          x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - 0.5 * CONFIG.NOTE_WIDTH,
          y: on_staff(line2),
          w: CONFIG.NOTE_WIDTH * (1 + slot.left_note + slot.mid_note + slot.right_note),
          h: 0
        });
      } else if (dur == NOTE_LENGTH.HALF) {
        let slot = slots[rest.begin];
        let line2 = y;
        result.push({
          tag: "line",
          type: "ledger",
          x: slot_x - slot.left_note * CONFIG.NOTE_WIDTH - 0.5 * CONFIG.NOTE_WIDTH,
          y: on_staff(line2),
          w: CONFIG.NOTE_WIDTH * (1 + slot.left_note + slot.mid_note + slot.right_note),
          h: 0
        });
      }
    } else if (dur == NOTE_LENGTH.WHOLE || dur == NOTE_LENGTH.HALF) {
      y = Math.min(Math.max(y, 2), 8);
    }
    let line = on_staff(y);
    result.push({
      tag: "rest",
      x: slot_x + CONFIG.NOTE_WIDTH / 2,
      y: line,
      w: CONFIG.NOTE_WIDTH,
      h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1),
      duration: dur
    });
  }
  function draw_beam(notes_spanned) {
    if (!notes_spanned.length) {
      return;
    }
    let beat_length = ~~(NOTE_LENGTH.WHOLE / staff.time_signature[1]);
    let stem_dir = notes_spanned[0].stem_dir;
    let flagcnts = [];
    for (let i2 = 0; i2 < notes_spanned.length; i2++) {
      flagcnts.push(notes_spanned[i2].flag_count);
    }
    let pts = notes_spanned.map((n) => {
      let stem_length = n.stem_len;
      let x = slot_pos(measure, n.begin) + CONFIG.NOTE_WIDTH * (Number(n.stem_dir < 0) * slots[n.begin].mid_note) + n.slot_shift;
      return { x, y: on_staff(2 * stem_dir * stem_length + n.staff_pos) };
    });
    let lengths = notes_spanned.map((x) => x.flag_count);
    let bins = new Array(pts.length * 2 - 2).fill(0);
    for (let i2 = 0; i2 < pts.length; i2++) {
      let flagcnt = flagcnts[i2];
      let last_len = lengths[i2 - 1];
      let next_len = lengths[i2 + 1];
      if (i2 == 0) {
        bins[i2 * 2] = flagcnt;
      } else if (i2 == pts.length - 1) {
        bins[i2 * 2 - 1] = flagcnt;
      } else {
        if (Math.abs(lengths[i2] - last_len) <= Math.abs(lengths[i2] - next_len)) {
          bins[i2 * 2 - 1] = flagcnt;
        } else {
          bins[i2 * 2] = flagcnt;
        }
        if (CONFIG.BEAM_POLICY == 3) {
          let same_beat_l = ~~(notes_spanned[i2 - 1].begin / beat_length) == ~~(notes_spanned[i2].begin / beat_length);
          let same_beat_r = ~~(notes_spanned[i2].begin / beat_length) == ~~(notes_spanned[i2 + 1].begin / beat_length);
          if (!same_beat_l && i2 != 1) {
            bins[i2 * 2 - 1] = 1;
          }
          if (!same_beat_r && i2 != pts.length - 2) {
            bins[i2 * 2] = 1;
          }
        }
      }
    }
    for (let i2 = 0; i2 < bins.length; i2++) {
      if (bins[i2] == 0) {
        let [i0, i1] = [~~(i2 / 2), ~~(i2 / 2) + 1];
        bins[i2] = Math.min(lengths[i0], lengths[i1]);
      }
    }
    let runs = [[1, 0, bins.length]];
    let on = -1;
    for (let i2 = 2; i2 <= 4; i2++) {
      for (let j = 0; j < bins.length; j++) {
        if (bins[j] >= i2 && on < 0) {
          on = j;
        }
        if (bins[j] < i2 && on >= 0) {
          runs.push([i2, on, j]);
          on = -1;
        }
      }
      if (on >= 0) {
        runs.push([i2, on, bins.length]);
        on = -1;
      }
    }
    for (let i2 = 0; i2 < runs.length; i2++) {
      let [t0, t1] = [runs[i2][1] / 2, runs[i2][2] / 2];
      let [i0, i1] = [~~t0, ~~t1];
      let [f0, f1] = [t0 - i0, t1 - i1];
      if (f0 > 0) {
        f0 += 0.2;
      }
      if (f1 > 0) {
        f1 -= 0.2;
      }
      let [j0, j1] = [
        Math.min(i0 + 1, pts.length - 1),
        Math.min(i1 + 1, pts.length - 1)
      ];
      let p0 = [pts[i0].x, pts[i0].y];
      let p1 = [pts[j0].x, pts[j0].y];
      let q0 = [pts[i1].x, pts[i1].y];
      let q1 = [pts[j1].x, pts[j1].y];
      let p = [p0[0] * (1 - f0) + p1[0] * f0, p0[1] * (1 - f0) + p1[1] * f0];
      let q = [q0[0] * (1 - f1) + q1[0] * f1, q0[1] * (1 - f1) + q1[1] * f1];
      result.push({
        tag: "beam",
        x: p[0],
        y: p[1] - (runs[i2][0] - 1) * stem_dir * CONFIG.LINE_HEIGHT * CONFIG.FLAG_SPACING,
        w: q[0] - p[0],
        h: q[1] - p[1],
        stem_dir
      });
    }
    for (let i2 = 0; i2 < bins.length; i2++) {
      let [i0, i1] = [~~(i2 / 2), ~~(i2 / 2) + 1];
      let [x0, v0, y0] = [pts[i0].x, pts[i0].y, pts[i0].y];
      let [x1, v1, y1] = [pts[i1].x, pts[i1].y, pts[i1].y];
      if (i2 % 2 == 0) {
        let u0 = v0 - notes_spanned[i0].stem_len * notes_spanned[i0].stem_dir * CONFIG.LINE_HEIGHT;
        result.push({
          tag: "line",
          type: "note_stem",
          x: x0,
          y: y0,
          w: 0,
          h: u0 - y0
        });
      } else if (i2 == bins.length - 1) {
        let u1 = v1 - notes_spanned[i1].stem_len * notes_spanned[i1].stem_dir * CONFIG.LINE_HEIGHT;
        result.push({
          tag: "line",
          type: "note_stem",
          x: x1,
          y: y1,
          w: 0,
          h: u1 - y1
        });
      }
    }
  }
  function draw_clef() {
    result.push({
      tag: "clef",
      type: staff.clef,
      x: measure.pad.inter + CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL / 2,
      y: on_staff(
        {
          [CLEF.TREBLE]: 6,
          [CLEF.BASS]: 2,
          [CLEF.ALTO]: 4,
          [CLEF.BARITONE]: 0,
          [CLEF.SOPRANO]: 8,
          [CLEF.TENOR]: 2,
          [CLEF.MEZZO_SOPRANO]: 6
        }[staff.clef]
      ),
      w: CONFIG.CLEF_WIDTH_MUL * CONFIG.NOTE_WIDTH,
      h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1)
    });
  }
  function draw_key_signature() {
    let { accidental, count } = staff.flags.need_keysig;
    let is_cancel = false;
    if (accidental == ~ACCIDENTAL.SHARP || accidental == ~ACCIDENTAL.FLAT) {
      is_cancel = true;
      accidental = ~accidental;
    }
    let targ_notes = Array.from(
      ORDER_OF_ACCIDENTALS[accidental].slice(0, count)
    );
    let octs = accidental == ACCIDENTAL.SHARP ? [6, 6, 6, 6, 5, 6, 5] : [5, 6, 5, 6, 5, 6, 5];
    let x = measure.pad.inter + Number(staff.flags.need_clef) * (CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL + measure.pad.inter);
    for (let i2 = 0; i2 < targ_notes.length; i2++) {
      let n;
      if (staff.clef == CLEF.TREBLE) {
        n = targ_notes[i2] + "_" + octs[i2];
      } else if (staff.clef == CLEF.BASS) {
        n = targ_notes[i2] + "_" + (octs[i2] - 2);
      } else if (staff.clef == CLEF.SOPRANO) {
        n = targ_notes[i2] + "_" + (octs[i2] - 1);
      } else if (staff.clef == CLEF.ALTO) {
        n = targ_notes[i2] + "_" + (octs[i2] - 1);
      } else if (staff.clef == CLEF.TENOR) {
        n = targ_notes[i2] + "_" + (octs[i2] - 1);
      } else if (staff.clef == CLEF.BARITONE) {
        n = targ_notes[i2] + "_" + (octs[i2] - 1);
      } else if (staff.clef == CLEF.MEZZO_SOPRANO) {
        n = targ_notes[i2] + "_" + (octs[i2] - 1);
      } else {
        n = targ_notes[i2] + "_" + octs[i2];
      }
      let line = note_name_to_staff_pos(n, staff.clef);
      result.push({
        tag: "accidental",
        type: is_cancel ? ACCIDENTAL.NATURAL : accidental,
        x: x + i2 * CONFIG.NOTE_WIDTH * CONFIG.KEYSIG_WIDTH_MUL + 3,
        y: on_staff(line),
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT
      });
    }
  }
  function draw_time_signature() {
    let x = measure.pad.inter + Number(staff.flags.need_clef) * (CONFIG.NOTE_WIDTH * CONFIG.CLEF_WIDTH_MUL + measure.pad.inter);
    if (staff.flags.need_keysig) {
      x += staff.flags.need_keysig.count * CONFIG.NOTE_WIDTH * CONFIG.KEYSIG_WIDTH_MUL + measure.pad.inter;
    }
    x += CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH / 2;
    function draw_digit(d, x2, line) {
      result.push({
        tag: "timesig_digit",
        value: d,
        x: x2,
        y: on_staff(line),
        w: CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) / 2
      });
    }
    function draw_num(n, x2, line) {
      let digits = Array.from(n.toString()).map(Number);
      let u = CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH * 0.5;
      for (let i2 = 0; i2 < digits.length; i2++) {
        draw_digit(digits[i2], x2 - digits.length * u / 2 + i2 * u + u / 2, line);
      }
    }
    if (CONFIG.TIMESIG_COMMON_TIME_C && (staff.time_signature[0] == 2 && staff.time_signature[1] == 2 || staff.time_signature[0] == 4 && staff.time_signature[1] == 4)) {
      result.push({
        tag: "timesig_c",
        type: staff.time_signature[0] - 2 ? "common" : "cut",
        x,
        y: on_staff(4),
        w: CONFIG.TIMESIG_WIDTH_MUL * CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) / 2
      });
    } else {
      draw_num(staff.time_signature[0], x, 2);
      draw_num(staff.time_signature[1], x, 6);
    }
  }
  function draw_tuplets() {
    let tuplets = {};
    function register_note_or_rest(n, is_rest) {
      if (!n.tuplet) {
        return;
      }
      let r = tuplets[n.tuplet.id];
      if (!r) {
        r = tuplets[n.tuplet.id] = {
          label: n.tuplet.label,
          stem_dir: -1,
          xmin: Infinity,
          xmax: -Infinity,
          ymin: Infinity,
          ymax: -Infinity
        };
      }
      let slot = slots[n.begin];
      let slot_x = slot_pos(measure, n.begin);
      if (is_rest) {
        let rest = n;
        let y0 = on_staff(rest.staff_pos);
        r.xmin = Math.min(r.xmin, slot_x);
        r.xmax = Math.max(r.xmax, slot_x + slot.mid_note * CONFIG.NOTE_WIDTH);
        r.ymin = Math.min(r.ymin, y0 - CONFIG.LINE_HEIGHT * 2);
        r.ymax = Math.max(r.ymax, y0 + CONFIG.LINE_HEIGHT * 2);
      } else {
        let note = n;
        r.stem_dir = note.stem_dir;
        let y = on_staff(note.staff_pos);
        let y0 = y + CONFIG.LINE_HEIGHT / 2;
        let y1 = y + note.stem_len * note.stem_dir * CONFIG.LINE_HEIGHT + Math.max(0, note.flag_count - 1) * CONFIG.FLAG_SPACING * note.stem_dir * CONFIG.LINE_HEIGHT;
        if (note.stem_dir < 0) {
          r.xmin = Math.min(
            r.xmin,
            slot_x - (slot.left_note - 0.5) * CONFIG.NOTE_WIDTH
          );
          r.xmax = Math.max(r.xmax, slot_x + slot.mid_note * CONFIG.NOTE_WIDTH);
        } else {
          r.xmin = Math.min(r.xmin, slot_x);
          r.xmax = Math.max(
            r.xmax,
            slot_x + (slot.mid_note + slot.right_note - 0.5) * CONFIG.NOTE_WIDTH
          );
        }
        r.ymin = Math.min(r.ymin, y0, y1);
        r.ymax = Math.max(r.ymax, y0, y1);
      }
    }
    for (let i2 = 0; i2 < staff.notes.length; i2++) {
      register_note_or_rest(staff.notes[i2], false);
    }
    for (let i2 = 0; i2 < staff.rests.length; i2++) {
      register_note_or_rest(staff.rests[i2], true);
    }
    for (let k in tuplets) {
      let { label, stem_dir, ymin, ymax, xmin, xmax } = tuplets[k];
      let y = stem_dir < 0 ? ymin : ymax;
      result.push({
        tag: "tuplet_label",
        label,
        x: xmin,
        y: y + stem_dir * CONFIG.LINE_HEIGHT * CONFIG.TUPLET_LABEL_SPACING,
        w: xmax - xmin,
        h: stem_dir * CONFIG.LINE_HEIGHT / 2
      });
    }
  }
  function draw_lyric(note, slot_x) {
    let ymax_sans_lyric;
    ymax_sans_lyric = staff.coords.local_y_max - CONFIG.LYRIC_SPACING - CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT;
    result.push({
      tag: "lyric",
      text: note.lyric,
      x: slot_x,
      y: ymax_sans_lyric,
      w: get_text_width(note.lyric) * CONFIG.LYRIC_SCALE,
      h: FONT_INHERENT_HEIGHT * CONFIG.LYRIC_SCALE
    });
  }
  function draw_cue(nr, slot_x) {
    let slot = slots[nr.begin];
    let ymax_sans_cue;
    ymax_sans_cue = staff.coords.local_y_max - (staff.flags.need_lyric ? CONFIG.LYRIC_SPACING * 2 + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT;
    let x = slot_x;
    if (nr.cue.position == 0) {
      x += CONFIG.NOTE_WIDTH * slot.mid_note / 2;
    } else if (nr.cue.position == -1) {
      x -= CONFIG.NOTE_WIDTH * (slot.left_note + slot.left_deco + slot.left_squiggle + slot.left_grace) + measure.pad.inter / 2;
    } else if (nr.cue.position == 1) {
      x += CONFIG.NOTE_WIDTH * (slot.mid_note + slot.right_deco + slot.right_note) + measure.pad.inter / 2;
    }
    result.push({
      tag: "cue",
      text: nr.cue.data,
      x,
      y: ymax_sans_cue - (CONFIG.CUE_TEXT_SIZE - CONFIG.CUE_HEIGHT) / 2,
      w: CONFIG.NOTE_WIDTH,
      h: CONFIG.CUE_TEXT_SIZE
    });
  }
  if (CONFIG.DEBUG_BLOCKS) {
    ;
    (function draw_dbg() {
      for (let i2 = 0; i2 < slots.length; i2++) {
        let slot_x = slot_pos(measure, i2);
        result.push({
          tag: "dbg",
          color: ["red", "blue", "green"][~~(Math.random() * 3)],
          x: slot_x,
          y: staff.coords.local_y_min,
          w: slots[i2].mid_note * CONFIG.NOTE_WIDTH,
          h: staff.coords.local_y_max - staff.coords.local_y_min
        });
      }
    })();
  }
  if (!no_staff_lines) {
    let measure_render_width = slot_pos(measure, measure.duration);
    for (let i2 = 0; i2 < CONFIG.LINES_PER_STAFF; i2++) {
      result.push({
        tag: "line",
        type: "staff_line",
        x: 0,
        y: i2 * CONFIG.LINE_HEIGHT,
        w: measure_render_width,
        h: 0
      });
    }
  }
  if (staff.flags.need_clef) {
    draw_clef();
  }
  if (staff.flags.need_keysig) {
    draw_key_signature();
  }
  if (staff.flags.need_timesig) {
    draw_time_signature();
  }
  for (let i2 = 0; i2 < notes.length; i2++) {
    let note = notes[i2];
    let line = note.staff_pos;
    let slot_x = slot_pos(measure, note.begin);
    let slot = slots[note.begin];
    put_ledgers_as_necessary(note.begin, line);
    draw_note(note, slot_x, line);
    if (note.lyric) {
      draw_lyric(note, slot_x);
    }
    if (note.cue) {
      draw_cue(note, slot_x);
    }
    if (note.accidental !== null) {
      let x = slot.acc_pack.intervals[staff_idx].find((a) => a.idx == i2).x;
      draw_accidental(
        note.accidental,
        slot_x - CONFIG.NOTE_WIDTH * slot.left_note - CONFIG.NOTE_WIDTH * CONFIG.ACCIDENTAL_WIDTH_MUL * 0.6 - CONFIG.NOTE_WIDTH * CONFIG.ACCIDENTAL_WIDTH_MUL * x * 0.8,
        line
      );
    }
  }
  let beams = staff.beams;
  for (let b of beams) {
    let notes_spanned = [];
    for (let i2 = 0; i2 < b.length; i2++) {
      notes_spanned.push(notes[b[i2]]);
    }
    if (!notes_spanned.length) {
      continue;
    }
    draw_beam(notes_spanned);
  }
  for (let i2 = 0; i2 < rests.length; i2++) {
    let rest = rests[i2];
    let slot_x = slot_pos(measure, rest.begin);
    draw_rest(rest, slot_x);
    if (rest.cue) {
      draw_cue(rest, slot_x);
    }
  }
  draw_tuplets();
  draw_ledgers();
  translate_elements(result, staff.coords.x, staff.coords.y);
  for (let i2 = 0; i2 < staff.grace.length; i2++) {
    if (!staff.grace[i2]) {
      continue;
    }
    let nw0 = CONFIG.NOTE_WIDTH;
    CONFIG.NOTE_WIDTH *= CONFIG.GRACE_WIDTH_MUL;
    let ret = draw_staff(staff.grace[i2], 0, true);
    CONFIG.NOTE_WIDTH = nw0;
    ret.forEach((x) => {
      x.mini = true;
      result.push(x);
    });
  }
  return result;
}
function translate_elements(elts, x, y) {
  for (let i2 = 0; i2 < elts.length; i2++) {
    elts[i2].x += x;
    elts[i2].y += y;
    if (elts[i2].x1) {
      elts[i2].x1 += x;
    }
    if (elts[i2].y1) {
      elts[i2].y1 += y;
    }
  }
}
function draw_measures(score2) {
  let measures = score2.measures;
  let result = [];
  let human_measure_count = 0;
  for (let i2 = 0; i2 < measures.length; i2++) {
    let staves = measures[i2].staves;
    if (CONFIG.SHOW_MEASURE_NUMBER) {
      if (staves[0] && measures[i2].duration >= staves[0].time_signature[0] * (64 / staves[0].time_signature[1])) {
        human_measure_count++;
      } else if (staves[0] && measures[i2 + 1] && measures[i2 + 1].staves[0] && measures[i2 + 1].staves[0].key_signature[0] == staves[0].key_signature[0] && measures[i2 + 1].staves[0].key_signature[1] == staves[0].key_signature[1] && measures[i2].duration + measures[i2 + 1].duration == staves[0].time_signature[0] * (64 / staves[0].time_signature[1])) {
        human_measure_count++;
      }
    }
    if (measures[i2].is_first_col) {
      let staff_count2 = 0;
      for (let j = 0; j < score2.instruments.length; j++) {
        if (!staves[staff_count2]) {
          break;
        }
        let y0 = staves[staff_count2].coords.y;
        let y1 = staves[staff_count2 + score2.instruments[j].names.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
        if (!j && i2 && CONFIG.SHOW_MEASURE_NUMBER) {
          let t = human_measure_count.toString();
          let w = get_text_width(t, FONT.DUPLEX, -2) * CONFIG.MEASURE_NUMBER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
          result.push({
            tag: "regular_text",
            type: "measure_number",
            text: t,
            x: staves[0].coords.x - w / 2,
            y: y0 - CONFIG.MEASURE_NUMBER_TEXT_SIZE - 14,
            w,
            h: CONFIG.MEASURE_NUMBER_TEXT_SIZE
          });
        }
        if (!i2 && score2.indent) {
          if (new Set(score2.instruments[j].names).size == 1) {
            let w = get_text_width(score2.instruments[j].names[0], FONT.DUPLEX, -2) * CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
            result.push({
              tag: "regular_text",
              type: "instrument",
              text: score2.instruments[j].names[0],
              x: staves[0].coords.x - w - CONFIG.INSTRUMENT_PAD_RIGHT,
              y: (y0 + y1) / 2 - CONFIG.INSTRUMENT_TEXT_SIZE / 2,
              w,
              h: CONFIG.INSTRUMENT_TEXT_SIZE
            });
          } else {
            for (let k = 0; k < score2.instruments[j].names.length; k++) {
              let z0 = staves[staff_count2 + k].coords.y;
              let z1 = staves[staff_count2 + k].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
              let w = get_text_width(
                score2.instruments[j].names[k],
                FONT.DUPLEX,
                -2
              ) * CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
              result.push({
                tag: "regular_text",
                type: "instrument",
                text: score2.instruments[j].names[k],
                x: staves[0].coords.x - w - CONFIG.INSTRUMENT_PAD_RIGHT,
                y: (z0 + z1) / 2 - CONFIG.INSTRUMENT_TEXT_SIZE / 2,
                w,
                h: CONFIG.INSTRUMENT_TEXT_SIZE
              });
            }
          }
        }
        if (score2.instruments[j].bracket != BRACKET.NONE) {
          result.push({
            tag: "bracket",
            type: score2.instruments[j].bracket,
            x: staves[0].coords.x,
            y: y0,
            w: 0,
            h: y1 - y0
          });
        }
        staff_count2 += score2.instruments[j].names.length;
      }
      if (staves.length > 1) {
        result.push({
          tag: "line",
          type: "barline",
          x: staves[0].coords.x,
          y: staves[0].coords.y,
          w: 0,
          h: staves[staves.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) - staves[0].coords.y
        });
      }
      if (CONFIG.JOIN_STAFF_LINES) {
        let last_measure_of_row = (score2.first_col_measure_indices[staves[0].coords.row + 1] ?? measures.length) - 1;
        let x1 = measures[last_measure_of_row].staves[0].coords.x + measures[last_measure_of_row].staves[0].coords.w;
        for (let j = 0; j < staves.length; j++) {
          let y0 = staves[j].coords.y;
          for (let k = 0; k < CONFIG.LINES_PER_STAFF; k++) {
            result.push({
              tag: "line",
              type: "staff_line",
              x: staves[0].coords.x,
              y: y0 + k * CONFIG.LINE_HEIGHT,
              w: x1 - staves[0].coords.x,
              h: 0
            });
          }
        }
      }
    }
    for (let j = 0; j < staves.length; j++) {
      let ret = draw_staff(measures[i2], j, CONFIG.JOIN_STAFF_LINES);
      ret.forEach((x) => result.push(x));
    }
    if (!score2.instruments.length) {
      result.push({
        tag: "line",
        type: "barline",
        x: staves[0].coords.x + staves[0].coords.w,
        y: staves[0].coords.y,
        w: 0,
        h: staves[staves.length - 1].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) - staves[0].coords.y
      });
    }
    let staff_count = 0;
    for (let j = 0; j < score2.instruments.length; j++) {
      for (let k = 0; k < score2.instruments[j].names.length; k++) {
        let z0 = staves[staff_count + k].coords.y;
        let z1 = staves[staff_count + k].coords.y + CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
        let z2 = staves[staff_count + k + 1] ? staves[staff_count + k + 1].coords.y : z1;
        if (measures[i2].barline == BARLINE.SINGLE || measures[i2].barline == BARLINE.REPEAT_BEGIN) {
          result.push({
            tag: "line",
            type: "barline",
            x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w,
            y: z0,
            w: 0,
            h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
          });
        }
        if (measures[i2].barline == BARLINE.DOUBLE) {
          result.push({
            tag: "line",
            type: "barline",
            x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w,
            y: z0,
            w: 0,
            h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
          });
          result.push({
            tag: "line",
            type: "barline",
            x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 4,
            y: z0,
            w: 0,
            h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
          });
        }
        if (measures[i2].barline == BARLINE.END || measures[i2].barline == BARLINE.REPEAT_END || measures[i2].barline == BARLINE.REPEAT_END_BEGIN) {
          for (let l = 0; l < 4; l++) {
            result.push({
              tag: "line",
              type: "barline",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - l,
              y: z0,
              w: 0,
              h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
            });
          }
          result.push({
            tag: "line",
            type: "barline",
            x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 8,
            y: z0,
            w: 0,
            h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
          });
          if (measures[i2].barline != BARLINE.END) {
            result.push({
              tag: "dot",
              type: "barline_repeat",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 12,
              y: z0 + CONFIG.LINE_HEIGHT * 1.5,
              w: 0,
              h: 0
            });
            result.push({
              tag: "dot",
              type: "barline_repeat",
              x: staves[staff_count + k].coords.x + staves[staff_count + k].coords.w - 12,
              y: z0 + CONFIG.LINE_HEIGHT * 2.5,
              w: 0,
              h: 0
            });
          }
        }
        if (measures[i2].barline == BARLINE.REPEAT_BEGIN || measures[i2].barline == BARLINE.REPEAT_END_BEGIN) {
          let x0 = measures[i2 + 1].staves[staff_count + k].coords.x + slot_pos(measures[i2 + 1], -1);
          let y0 = measures[i2 + 1].staves[staff_count + k].coords.y;
          let xl = staves[staff_count + k].coords.x + staves[staff_count + k].coords.w;
          let adj = measures[i2].barline == BARLINE.REPEAT_END_BEGIN && Math.abs(x0 - xl) < 0.01;
          if (!adj) {
            for (let l = 1; l < 4; l++) {
              result.push({
                tag: "line",
                type: "barline",
                x: x0 + l,
                y: y0,
                w: 0,
                h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
              });
            }
          }
          result.push({
            tag: "line",
            type: "barline",
            x: x0 + 8 - 3 * Number(adj),
            y: y0,
            w: 0,
            h: (score2.instruments[j].connect_barlines[k] ? z2 : z1) - z0
          });
          result.push({
            tag: "dot",
            type: "barline_repeat",
            x: x0 + 12 - 3 * Number(adj),
            y: y0 + CONFIG.LINE_HEIGHT * 1.5,
            w: 0,
            h: 0
          });
          result.push({
            tag: "dot",
            type: "barline_repeat",
            x: x0 + 12 - 3 * Number(adj),
            y: y0 + CONFIG.LINE_HEIGHT * 2.5,
            w: 0,
            h: 0
          });
        }
      }
      staff_count += score2.instruments[j].names.length;
    }
  }
  return result;
}
function draw_slurs(score2) {
  let result = [];
  let row_yoffsets = score2.measures.filter((x) => x.is_first_col).map((x) => x.staves[0].coords.y);
  for (let i2 = 0; i2 < score2.slurs.length; i2++) {
    let notes_ybounds = function(notes) {
      if (!notes.length) {
        return null;
      }
      let ymin2 = Infinity;
      let ymax2 = -Infinity;
      for (let i3 = 0; i3 < notes.length; i3++) {
        let y02 = on_staff(notes[i3].staff_pos);
        let y12 = y02 + notes[i3].stem_dir * notes[i3].stem_len * CONFIG.LINE_HEIGHT;
        if (notes[i3].accidental != null) {
          y02 -= CONFIG.LINE_HEIGHT;
          y12 += CONFIG.LINE_HEIGHT;
        }
        ymin2 = Math.min(y02, y12, ymin2);
        ymax2 = Math.max(y02, y12, ymax2);
      }
      return [ymin2, ymax2];
    }, share_measure_ybound_in_slur = function() {
      let m0 = score2.first_col_measure_indices[lreg.row] + lreg.col;
      let m1 = score2.first_col_measure_indices[rreg.row] + rreg.col;
      if (m0 != m1) {
        return null;
      }
      let b0 = get_begin(lreg);
      let b1 = get_begin(rreg);
      let notes = score2.measures[m0].staves[lreg.staff_idx].notes.filter(
        (x) => b0 < x.begin && x.begin < b1
      );
      return notes_ybounds(notes);
    }, get_begin = function(reg) {
      let m = score2.first_col_measure_indices[reg.row] + reg.col;
      if (score2.measures[m] != reg.measure) {
        for (let i3 = 0; i3 < score2.measures[m].staves[reg.staff_idx].grace.length; i3++) {
          if (score2.measures[m].staves[reg.staff_idx].grace[i3] == reg.measure) {
            return i3;
          }
        }
      }
      return reg.note.begin;
    }, self_measure_ybound_in_slur = function(reg, sign) {
      let m = score2.first_col_measure_indices[reg.row] + reg.col;
      let begin = reg.note.begin;
      if (score2.measures[m] != reg.measure) {
        for (let i3 = 0; i3 < score2.measures[m].staves[reg.staff_idx].grace.length; i3++) {
          if (score2.measures[m].staves[reg.staff_idx].grace[i3] == reg.measure) {
            begin = i3;
            break;
          }
        }
      }
      let notes = score2.measures[m].staves[reg.staff_idx].notes.filter(
        (x) => Math.sign(x.begin - begin) == sign
      );
      return notes_ybounds(notes);
    }, inter_ybound_in_slur = function(situation) {
      let m0 = score2.first_col_measure_indices[lreg.row] + lreg.col;
      let m1 = score2.first_col_measure_indices[rreg.row] + rreg.col;
      if (situation == 1) {
        if (score2.first_col_measure_indices[lreg.row + 1] && score2.first_col_measure_indices[lreg.row + 1] < m1) {
          m1 = score2.first_col_measure_indices[lreg.row + 1];
        }
      } else if (situation == 2) {
        if (score2.first_col_measure_indices[rreg.row] && score2.first_col_measure_indices[rreg.row] > m0) {
          m0 = score2.first_col_measure_indices[rreg.row] - 1;
        }
      }
      if (m0 + 1 >= m1) {
        return null;
      }
      let ymin2 = Infinity;
      let ymax2 = -Infinity;
      for (let i3 = m0 + 1; i3 < m1; i3++) {
        let [ya, yb] = notes_ybounds(
          score2.measures[i3].staves[lreg.staff_idx].notes
        );
        if (ya == null) {
          ya = 0;
          yb = CONFIG.LINE_HEIGHT * 4;
        }
        ymin2 = Math.min(ymin2, ya);
        ymax2 = Math.max(ymax2, yb);
      }
      return [ymin2, ymax2];
    }, compute_slur = function(situation) {
      dy = null;
      ymin = ymax = null;
      if (!is_tie && lreg.staff_idx == rreg.staff_idx) {
        let m0 = score2.first_col_measure_indices[lreg.row] + lreg.col;
        let m1 = score2.first_col_measure_indices[rreg.row] + rreg.col;
        if (m0 <= m1) {
          if (m0 == m1) {
            let ret = share_measure_ybound_in_slur();
            if (ret) [ymin, ymax] = ret;
          } else {
            let rets;
            if (situation == 0) {
              rets = [
                self_measure_ybound_in_slur(lreg, 1),
                inter_ybound_in_slur(0),
                self_measure_ybound_in_slur(rreg, -1)
              ];
              if (rreg.measure.staves[rreg.staff_idx].flags.need_clef) {
                rets.push([
                  CONFIG.LINE_HEIGHT,
                  CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1)
                ]);
              }
            } else if (situation == 1) {
              rets = [
                self_measure_ybound_in_slur(lreg, 1),
                inter_ybound_in_slur(1)
              ];
            } else if (situation == 2) {
              rets = [
                inter_ybound_in_slur(2),
                self_measure_ybound_in_slur(rreg, -1)
              ];
            }
            for (let i3 = 0; i3 < rets.length; i3++) {
              if (rets[i3] == null) {
                continue;
              }
              if (ymin === null) {
                ;
                [ymin, ymax] = rets[i3];
              } else {
                ymin = Math.min(rets[i3][0], ymin);
                ymax = Math.max(rets[i3][1], ymax);
              }
            }
          }
          if (ymin !== null) {
            let yl = y0 - lreg.measure.staves[lreg.staff_idx].coords.y;
            let yr = y1 - rreg.measure.staves[rreg.staff_idx].coords.y;
            let ya;
            let yb;
            if (situation == 0) {
              ya = yl;
              yb = yr;
            } else if (situation == 1) {
              ya = yb = yl;
            } else if (situation == 2) {
              ya = yb = yr;
            }
            if (dir == -1) {
              dy = (Math.max(ya, yb) + (ya + yb) / 2) / 2 - ymin;
            } else {
              dy = ymax - (Math.min(ya, yb) + (ya + yb) / 2) / 2;
            }
            dy *= 1.2;
            dy = Math.max(dy, 0);
            dy += CONFIG.LINE_HEIGHT * 2;
          }
        }
      }
    };
    let { left, right, is_tie } = score2.slurs[i2];
    let lreg = id_registry[left];
    let rreg = id_registry[right];
    let x0, y0, x1, y1, dir;
    let sh_lh = lreg.note.articulation ? 4 : 7;
    let sh_lt = lreg.note.articulation ? 2 : 5;
    let sh_rh = rreg.note.articulation ? 4 : 7;
    let sh_rt = rreg.note.articulation ? 2 : 5;
    let l_is_grace = score2.measures[score2.first_col_measure_indices[lreg.row] + lreg.col] != lreg.measure;
    if (is_tie) {
      if (lreg.note.voice == 0 && rreg.note.voice == 0 && lreg.measure.staves[lreg.staff_idx].voices == 1 && rreg.measure.staves[rreg.staff_idx].voices == 1 && lreg.note.stem_dir == rreg.note.stem_dir) {
        if (lreg.note.next_in_chord == null && lreg.note.prev_in_chord != null && rreg.note.next_in_chord == null && rreg.note.prev_in_chord != null) {
          dir = lreg.note.stem_dir;
        } else {
          dir = -lreg.note.stem_dir;
        }
        ;
        [x0, y0] = [lreg.head_x, lreg.head_y + sh_lh * dir];
        [x1, y1] = [rreg.head_x, rreg.head_y + sh_rh * dir];
      } else {
        if (Math.max(lreg.note.voice, rreg.note.voice) % 2) {
          dir = 1;
          [x0, y0] = [lreg.head_x, lreg.head_y + sh_lh];
          [x1, y1] = [rreg.head_x, rreg.head_y + sh_rh];
        } else {
          dir = -1;
          [x0, y0] = [lreg.head_x, lreg.head_y - sh_lh];
          [x1, y1] = [rreg.head_x, rreg.head_y - sh_rh];
        }
      }
    } else {
      sh_lh = lreg.note.articulation ? lreg.note.articulation == ARTICULATION.STACCATO ? Math.abs(
        lreg.note.articulation_pos[1] * CONFIG.LINE_HEIGHT / 2 - (lreg.chord_head_y - lreg.measure.staves[lreg.staff_idx].coords.y)
      ) + 5 : 4 : 7;
      sh_rh = rreg.note.articulation ? rreg.note.articulation == ARTICULATION.STACCATO ? Math.abs(
        rreg.note.articulation_pos[1] * CONFIG.LINE_HEIGHT / 2 - (rreg.chord_head_y - rreg.measure.staves[rreg.staff_idx].coords.y)
      ) + 5 : 4 : 7;
      if ((lreg.measure.staves[lreg.staff_idx].voices > 1 || rreg.measure.staves[rreg.staff_idx].voices > 1) && lreg.note.stem_dir == rreg.note.stem_dir) {
        if (lreg.note.stem_dir == 1) {
          dir = 1;
          [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
          [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
        } else {
          dir = -1;
          [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
          [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
        }
      } else {
        let head_to_tail_better = Math.abs(lreg.chord_head_y - rreg.tail_y) < Math.abs(lreg.tail_y - rreg.chord_head_y) + 5;
        let tail_to_tail_better = Math.abs(lreg.tail_y - rreg.tail_y) < Math.abs(lreg.chord_head_y - rreg.chord_head_y) - 40;
        if (lreg.note.stem_dir < 0 && rreg.note.stem_dir < 0) {
          if (tail_to_tail_better) {
            dir = -1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
            [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
          } else {
            dir = 1;
            [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y + sh_lh];
            [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y + sh_rh];
          }
        } else if (lreg.note.stem_dir < 0 && rreg.note.stem_dir > 0) {
          if (head_to_tail_better) {
            dir = 1;
            [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y + sh_lh];
            [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
          } else {
            dir = -1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y - sh_lt];
            [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y - sh_rh];
          }
        } else if (lreg.note.stem_dir > 0 && rreg.note.stem_dir > 0) {
          if (tail_to_tail_better) {
            dir = 1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
            [x1, y1] = [rreg.tail_x, rreg.tail_y + sh_rt];
          } else {
            dir = -1;
            [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y - sh_lh];
            [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y - sh_rh];
          }
        } else {
          if (head_to_tail_better) {
            dir = -1;
            [x0, y0] = [lreg.chord_head_x, lreg.chord_head_y - sh_lh];
            [x1, y1] = [rreg.tail_x, rreg.tail_y - sh_rt];
          } else {
            dir = 1;
            [x0, y0] = [lreg.tail_x, lreg.tail_y + sh_lt];
            [x1, y1] = [rreg.chord_head_x, rreg.chord_head_y + sh_rh];
          }
        }
      }
    }
    if (is_tie) {
      x0 += 3;
      x1 -= 3;
    } else {
      x0 += 2;
      x1 -= 2;
    }
    let dy = null;
    let ymin = null;
    let ymax = null;
    if (lreg.row == rreg.row) {
      compute_slur(0);
      let h = Math.min(
        CONFIG.LINE_HEIGHT * (lreg.measure == rreg.measure ? 4.5 : 6.5),
        Math.max(
          CONFIG.LINE_HEIGHT * 1.5,
          dy != null ? 0 : Math.abs(x1 - x0) * 0.05,
          dy != null ? 0 : Math.abs(y1 - y0) * 0.5,
          dy == null ? 0 : dy
        )
      );
      if (is_tie) {
        h *= 0.6;
      }
      result.push({
        tag: "slur",
        x: x0,
        y: y0,
        w: x1 - x0,
        h: h * CONFIG.SLUR_ARC_MUL,
        y1,
        dir,
        adjacent: dy == null
      });
    } else {
      let get_row_left = function(row) {
        let k = score2.first_col_measure_indices[row];
        let slot = score2.measures[k].slots[0];
        let xz2 = slot_pos(score2.measures[k], -1);
        return Math.max(xz2, 0);
      };
      compute_slur(1);
      let h = Math.min(
        CONFIG.LINE_HEIGHT * 6.5,
        Math.max(
          CONFIG.LINE_HEIGHT * 1.5,
          dy != null ? 0 : Math.abs(CONTENT_WIDTH() - x0) * 0.16,
          dy == null ? 0 : dy
        )
      );
      if (is_tie) {
        h *= 0.6;
      }
      let y_1 = y0 + dir * h / 4;
      if (ymin != null) {
        y_1 = y_1 * 0.5 + (lreg.measure.staves[lreg.staff_idx].coords.y + (dir < 0 ? ymin - CONFIG.LINE_HEIGHT / 2 : ymax + CONFIG.LINE_HEIGHT / 2)) * 0.5;
      }
      result.push({
        tag: "slur",
        x: x0,
        y: y0,
        w: CONTENT_WIDTH() - x0,
        h: h * CONFIG.SLUR_ARC_MUL,
        y1: y_1,
        dir
      });
      for (let j = lreg.row + 1; j < rreg.row; j++) {
        let h2 = Math.min(
          CONFIG.LINE_HEIGHT * 7,
          Math.max(CONFIG.LINE_HEIGHT * 1.5, CONTENT_WIDTH() * 0.16)
        );
        let xz2 = get_row_left(j);
        let notes = score2.measures.slice(
          score2.first_col_measure_indices[j],
          score2.first_col_measure_indices[j + 1] || Infinity
        ).map((x) => x.staves[lreg.staff_idx]).map((x) => x.notes).flat();
        let bd = notes_ybounds(notes);
        result.push({
          tag: "slur",
          x: xz2,
          y: row_yoffsets[j] + (dir < 0 ? bd[0] : bd[1]),
          w: CONTENT_WIDTH() - xz2,
          h: h2 * CONFIG.SLUR_ARC_MUL * 3 / 4,
          y1: row_yoffsets[j] + (dir < 0 ? bd[0] : bd[1]),
          dir
        });
      }
      let xz = get_row_left(rreg.row);
      compute_slur(2);
      h = Math.min(
        CONFIG.LINE_HEIGHT * 6.5,
        Math.max(
          CONFIG.LINE_HEIGHT * 1.5,
          dy != null ? 0 : x1 * 0.16,
          dy == null ? 0 : dy
        )
      );
      y_1 = y1 + dir * h / 4;
      if (ymin != null) {
        y_1 = y_1 * 0.5 + (rreg.measure.staves[rreg.staff_idx].coords.y + (dir < 0 ? ymin - CONFIG.LINE_HEIGHT / 2 : ymax + CONFIG.LINE_HEIGHT / 2)) * 0.5;
      }
      result.push({
        tag: "slur",
        x: xz,
        y: y_1,
        w: x1 - xz,
        h: h * CONFIG.SLUR_ARC_MUL,
        y1,
        dir
      });
    }
  }
  return result;
}
function draw_crescs(score2) {
  let result = [];
  for (let i2 = 0; i2 < score2.crescs.length; i2++) {
    let { left, right, val_left, val_right } = score2.crescs[i2];
    let lreg = id_registry[left];
    let rreg = id_registry[right];
    let x0 = lreg.head_x + 3;
    let x1 = rreg.head_x - 3;
    let staff0 = lreg.measure.staves[lreg.staff_idx];
    let staff1 = rreg.measure.staves[rreg.staff_idx];
    let ch = CONFIG.CUE_TEXT_SIZE;
    let y0 = staff0.coords.y + staff0.coords.local_y_max - (staff0.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
    let y1 = staff1.coords.y + staff1.coords.local_y_max - (staff1.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
    if (lreg.row == rreg.row) {
      let u0 = y0 - ch / 2 * val_left;
      let u1 = y0 + ch / 2 * val_left;
      let v0 = y1 - ch / 2 * val_right;
      let v1 = y1 + ch / 2 * val_right;
      result.push({
        tag: "cresc",
        x: x0,
        y: u0,
        w: x1 - x0,
        h: v0 - u0,
        x1: x0,
        y1: u1,
        w1: x1 - x0,
        h1: v1 - u1
      });
    } else {
      let wa = CONTENT_WIDTH() - x0;
      let ws = [0, wa];
      for (let j = lreg.row + 1; j < rreg.row; j++) {
        ws.push(wa += CONTENT_WIDTH());
      }
      ws.push(wa += x1);
      for (let j = 0; j < rreg.row - lreg.row + 1; j++) {
        let is_first = j == 0;
        let is_last = j == rreg.row - lreg.row;
        let t0 = ws[j] / wa;
        let t1 = ws[j + 1] / wa;
        let xl = is_first ? x0 : 0;
        let xr = is_last ? x1 : CONTENT_WIDTH();
        let y;
        if (is_first) {
          y = y0;
        } else if (is_last) {
          y = y1;
        } else {
          for (let k = 0; k < score2.measures.length; k++) {
            if (score2.measures[k].staves[lreg.staff_idx].coords.row == lreg.row + j) {
              let staff = score2.measures[k].staves[lreg.staff_idx];
              y = staff.coords.y + staff.coords.local_y_max - (staff.flags.need_lyric ? 2 * CONFIG.LYRIC_SPACING + CONFIG.LYRIC_SCALE * FONT_INHERENT_HEIGHT : 0) - CONFIG.CUE_HEIGHT / 2;
              break;
            }
          }
        }
        let l = val_left * (1 - t0) + val_right * t0;
        let r = val_left * (1 - t1) + val_right * t1;
        let u0 = y - ch / 2 * l;
        let u1 = y + ch / 2 * l;
        let v0 = y - ch / 2 * r;
        let v1 = y + ch / 2 * r;
        result.push({
          tag: "line",
          type: "cresc_top",
          x: xl,
          y: u0,
          w: xr - xl,
          h: v0 - u0
        });
        result.push({
          tag: "line",
          type: "cresc_bottom",
          x: xl,
          y: u1,
          w: xr - xl,
          h: v1 - u1
        });
      }
    }
  }
  return result;
}
function draw_tempo(tempo) {
  let result = [];
  let dx = 0;
  if (tempo.duration != null && tempo.bpm != null) {
    if (tempo.duration < NOTE_LENGTH.WHOLE) {
      let num_flags = calc_num_flags(tempo.duration, tempo.modifier);
      result.push({
        tag: "note_head",
        x: CONFIG.NOTE_WIDTH,
        y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE,
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT,
        twisted: false,
        stem_dir: -1,
        duration: tempo.duration
      });
      dx += CONFIG.NOTE_WIDTH;
      let eh = (num_flags + 1) * CONFIG.FLAG_SPACING * CONFIG.LINE_HEIGHT;
      result.push({
        tag: "line",
        type: "note_stem",
        x: CONFIG.NOTE_WIDTH,
        y: -eh,
        w: 0,
        h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE + eh
      });
      if (tempo.modifier) {
        result.push({
          tag: "dot",
          type: "modifier",
          x: CONFIG.NOTE_WIDTH * 1.5,
          y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE - CONFIG.LINE_HEIGHT / 2,
          w: 0,
          h: 0
        });
      }
      if (tempo.modifier || num_flags) {
        dx += CONFIG.NOTE_WIDTH;
      }
      for (let i2 = 0; i2 < num_flags; i2++) {
        result.push({
          tag: "flag",
          x: CONFIG.NOTE_WIDTH,
          y: -eh + i2 * CONFIG.FLAG_SPACING * CONFIG.LINE_HEIGHT,
          w: CONFIG.NOTE_WIDTH,
          h: CONFIG.LINE_HEIGHT,
          stem_dir: -1,
          is_last: i2 == num_flags - 1
        });
      }
    } else {
      result.push({
        tag: "note_head",
        x: CONFIG.NOTE_WIDTH,
        y: CONFIG.TEMPO_COMPOSER_TEXT_SIZE / 2,
        w: CONFIG.NOTE_WIDTH,
        h: CONFIG.LINE_HEIGHT,
        twisted: false,
        stem_dir: -1,
        duration: tempo.duration
      });
      dx += CONFIG.NOTE_WIDTH;
    }
    let t = " = " + tempo.bpm;
    let tw = get_text_width(t, FONT.DUPLEX, -2) * CONFIG.TEMPO_COMPOSER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
    result.push({
      tag: "regular_text",
      type: "tempo",
      text: t,
      x: dx,
      y: 0,
      w: tw,
      h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE
    });
    dx += tw + CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
  }
  if (tempo.text != null) {
    let tw = get_text_width(tempo.text, FONT.TRIPLEX, -2) * CONFIG.TEMPO_COMPOSER_TEXT_SIZE / FONT_INHERENT_HEIGHT;
    result.push({
      tag: "bold_text",
      type: "tempo",
      text: tempo.text,
      x: dx,
      y: 0,
      w: tw,
      h: CONFIG.TEMPO_COMPOSER_TEXT_SIZE
    });
  }
  return result;
}
function draw_score(score2) {
  id_registry = {};
  let ret = draw_measures(score2);
  ret.push(...draw_slurs(score2));
  ret.push(...draw_crescs(score2));
  let last_staff = score2.measures[score2.measures.length - 1].staves[score2.measures[score2.measures.length - 1].staves.length - 1];
  let H = last_staff.coords.y + Math.max(
    last_staff.coords.local_y_max,
    CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF + 1)
  );
  let result = [];
  let dy = CONFIG.PAGE_MARGIN_Y;
  for (let i2 = 0; i2 < score2.title.length; i2++) {
    let h = i2 ? CONFIG.SUBTITLE_TEXT_SIZE : CONFIG.TITLE_TEXT_SIZE;
    let w = get_text_width(score2.title[i2], i2 ? FONT.DUPLEX : FONT.TRIPLEX, -2) * h / FONT_INHERENT_HEIGHT;
    result.push({
      ...i2 ? { tag: "regular_text", type: "subtitle" } : { tag: "bold_text", type: "title" },
      text: score2.title[i2],
      x: CONFIG.PAGE_WIDTH / 2 - w / 2,
      y: dy,
      w,
      h
    });
    dy += h + CONFIG.TITLE_LINE_SPACING;
  }
  if (score2.tempo || score2.composer.length) {
    dy += CONFIG.TITLE_LINE_SPACING;
    if (score2.composer.length) {
      let h = CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
      for (let i2 = 0; i2 < score2.composer.length; i2++) {
        let w = get_text_width(score2.composer[i2], FONT.DUPLEX, -2) * h / FONT_INHERENT_HEIGHT;
        result.push({
          tag: "regular_text",
          type: "composer",
          text: score2.composer[i2],
          x: CONFIG.PAGE_WIDTH - CONFIG.PAGE_MARGIN_X - w,
          y: dy,
          w,
          h
        });
        dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
      }
      dy -= CONFIG.TEMPO_COMPOSER_TEXT_SIZE + 4;
    }
    if (score2.tempo) {
      let r = draw_tempo(score2.tempo);
      translate_elements(r, CONFIG.PAGE_MARGIN_X + score2.indent, dy);
      r.forEach((x) => result.push(x));
    }
    dy += CONFIG.TEMPO_COMPOSER_TEXT_SIZE;
  }
  dy += CONFIG.TITLE_LINE_SPACING * 1.2;
  translate_elements(ret, CONFIG.PAGE_MARGIN_X, dy);
  ret.forEach((x) => result.push(x));
  return [result, H + CONFIG.PAGE_MARGIN_Y + dy];
}
function render_score(score2, { compute_polylines = true } = {}) {
  let [elements, h] = draw_score(score2);
  let ret = {
    w: CONFIG.PAGE_WIDTH,
    h,
    elements,
    polylines: null
  };
  if (CONFIG.SLUR_EVADE) {
    slur_evade_note(elements);
  }
  if (CONFIG.CUE_EVADE) {
    cue_evade_slur(elements);
  }
  if (compute_polylines) {
    ret.polylines = hf_drawing_polylines(elements, ret.w, ret.h);
  }
  return ret;
}

// src/compile.ts
function staff_has_cue_lyric(staff, crescs = null) {
  let has_cue = false;
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    if (staff.notes[i2].cue) {
      has_cue = true;
      break;
    }
  }
  if (!has_cue) {
    for (let i2 = 0; i2 < staff.rests.length; i2++) {
      if (staff.rests[i2].cue) {
        has_cue = true;
        break;
      }
    }
  }
  if (!has_cue && crescs && crescs.length) {
    for (let i2 = 0; i2 < staff.notes.length; i2++) {
      if (staff.notes[i2].id) {
        for (let j = 0; j < crescs.length; j++) {
          if (crescs[j].left == staff.notes[i2].id || crescs[j].right == staff.notes[i2].id) {
            has_cue = true;
            break;
          }
        }
        if (has_cue) {
          break;
        }
      }
    }
  }
  let has_lyric = false;
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    if (staff.notes[i2].lyric) {
      has_lyric = true;
      break;
    }
  }
  staff.flags.need_cue = has_cue;
  staff.flags.need_lyric = has_lyric;
}
function calc_staff_flags(score2, measure_idx, staff_idx) {
  let measures = score2.measures;
  if (measure_idx != 0) {
    let ks0 = measures[measure_idx - 1].staves[staff_idx].key_signature;
    let ks1 = measures[measure_idx].staves[staff_idx].key_signature;
    if (ks0[0] != ks1[0] || ks0[1] != ks1[1]) {
      let [acc0, num_acc0] = ks0;
      let [acc1, num_acc1] = ks1;
      if (num_acc0 > 0 && num_acc1 == 0) {
        measures[measure_idx].staves[staff_idx].flags.need_keysig = {
          accidental: ~acc0,
          count: num_acc0
        };
      } else {
        measures[measure_idx].staves[staff_idx].flags.need_keysig = {
          accidental: acc1,
          count: num_acc1
        };
      }
    }
    let ts0 = measures[measure_idx - 1].staves[staff_idx].time_signature;
    let ts1 = measures[measure_idx].staves[staff_idx].time_signature;
    if (ts0[0] != ts1[0] || ts0[1] != ts1[1]) {
      measures[measure_idx].staves[staff_idx].flags.need_timesig = true;
    }
    if (measures[measure_idx - 1].staves[staff_idx].clef != measures[measure_idx].staves[staff_idx].clef) {
      measures[measure_idx].staves[staff_idx].flags.need_clef = true;
    }
  } else {
    let [acc, num_acc] = measures[measure_idx].staves[staff_idx].key_signature;
    measures[measure_idx].staves[staff_idx].flags.need_keysig = {
      accidental: acc,
      count: num_acc
    };
    measures[measure_idx].staves[staff_idx].flags.need_timesig = true;
    measures[measure_idx].staves[staff_idx].flags.need_clef = true;
  }
  staff_has_cue_lyric(measures[measure_idx].staves[staff_idx], score2.crescs);
}
function has_twisted_sibling(notes, idx) {
  let note = notes[idx];
  let does = note.twisted;
  if (does) return does;
  let head_note = note;
  let tail_note = note;
  while (head_note.prev_in_chord != null) {
    head_note = notes[head_note.prev_in_chord];
    if (head_note.twisted) does = true;
  }
  if (does) return does;
  while (tail_note.next_in_chord != null) {
    tail_note = notes[tail_note.next_in_chord];
    if (tail_note.twisted) does = true;
  }
  return does;
}
function compile_measure(measure) {
  function get_index_in_chord(notes, note) {
    let i2 = 0;
    while (note.prev_in_chord !== null) {
      note = notes[note.prev_in_chord];
      i2++;
    }
    return i2;
  }
  for (let j = 0; j < measure.staves.length; j++) {
    let staff = measure.staves[j];
    if (!staff.coords) {
      staff.coords = {
        x: 0,
        y: 0,
        w: 0,
        local_y_min: 0,
        local_y_max: 0,
        col: 0,
        row: 0
      };
    }
    if (!staff.flags) {
      staff.flags = {
        need_keysig: null,
        need_timesig: false,
        need_clef: false,
        need_cue: false,
        need_lyric: false
      };
    }
    for (let b of staff.beams) {
      for (let k of b) {
        ;
        staff.notes[k].beamed = true;
      }
    }
    for (let k = 0; k < staff.notes.length; k++) {
      let note = staff.notes[k];
      let twisted = false;
      let stem_len = CONFIG.STEM_LENGTH;
      let stem_dir = note.stem_dir;
      let flag_count = 0;
      if (note.prev_in_chord !== null) {
        let pd = note.staff_pos - staff.notes[note.prev_in_chord].staff_pos;
        if (Math.abs(pd) <= 1) {
          if (get_index_in_chord(staff.notes, note) % 2) {
            twisted = true;
          }
        }
      }
      if (note.next_in_chord !== null) {
        let pd = note.staff_pos - staff.notes[note.next_in_chord].staff_pos;
        if (!twisted && Math.abs(pd) <= 1) {
          if (get_index_in_chord(staff.notes, note) % 2) {
            twisted = true;
          }
        }
        stem_len = Math.abs(pd) / 2;
      } else {
        if (note.tuplet) {
          flag_count = calc_num_flags(
            note.tuplet.display_duration,
            note.modifier
          );
        } else {
          flag_count = calc_num_flags(note.duration, note.modifier);
        }
      }
      stem_len += flag_count * CONFIG.FLAG_SPACING / 2;
      note.stem_len = stem_len;
      note.flag_count = flag_count;
      note.twisted = twisted;
      note.slot_shift = 0;
      note.modifier_shift = 0;
    }
    let beams = staff.beams;
    for (let b of beams) {
      let notes_spanned = [];
      for (let i2 = 0; i2 < b.length; i2++) {
        notes_spanned.push(staff.notes[b[i2]]);
      }
      if (!notes_spanned.length) {
        continue;
      }
      let flagcnts = [];
      for (let i2 = 0; i2 < notes_spanned.length; i2++) {
        flagcnts.push(notes_spanned[i2].flag_count);
      }
      let extra_len = Math.max(0, Math.max(...flagcnts) - 1) * CONFIG.FLAG_SPACING;
      for (let i2 = 0; i2 < notes_spanned.length; i2++) {
        notes_spanned[i2].stem_len += extra_len - notes_spanned[i2].flag_count * CONFIG.FLAG_SPACING / 6;
      }
    }
    compile_rests(staff);
  }
  for (let j = 0; j < measure.staves.length; j++) {
    let staff = measure.staves[j];
    for (let i2 = 0; i2 < staff.grace.length; i2++) {
      if (staff.grace[i2]) {
        compile_measure(staff.grace[i2]);
        let st = staff.grace[i2].staves[0];
        for (let j2 = 0; j2 < st.notes.length; j2++) {
          if (st.notes[j2].next_in_chord == null) {
            st.notes[j2].stem_len *= 0.6;
          }
        }
        staff.grace[i2].pad = {
          left: 0,
          inter: CONFIG.INTER_NOTE_WIDTH / 2,
          right: 0
        };
      }
    }
  }
  measure.pad = {
    left: CONFIG.MEASURE_PAD_FRONT,
    inter: CONFIG.INTER_NOTE_WIDTH,
    right: CONFIG.MEASURE_PAD_BACK
  };
  make_measure_slots(measure);
  if (CONFIG.HEADBUTT_RESOLVE) {
    for (let j = 0; j < measure.staves.length; j++) {
      let staff = measure.staves[j];
      for (let k = 0; k < staff.notes.length; k++) {
        let try_opt_headbutt = function() {
          if (staff.voices <= 1 || slot.mid_note <= 1 || has_twisted_sibling(staff.notes, k)) {
            return;
          }
          let track = slot.mid_pack.intervals[staff_idx];
          let entry = track.find((a) => a.idx == note_idx);
          if (entry.x > 0) {
            return;
          }
          let collider = null;
          for (let j2 = 0; j2 < track.length; j2++) {
            if (track[j2].idx == entry.idx) continue;
            if (interval_overlap(
              track[j2].top,
              track[j2].bottom,
              entry.top,
              entry.bottom
            )) {
              if (collider) {
                return;
              } else {
                collider = staff.notes[track[j2].idx];
              }
            }
          }
          if (collider) {
            return;
          }
          if (note.stem_dir < 0) {
            note.slot_shift = -CONFIG.NOTE_WIDTH;
            note.modifier_shift = -CONFIG.NOTE_WIDTH;
          } else {
            note.modifier_shift = -CONFIG.NOTE_WIDTH;
          }
        };
        let staff_idx = j;
        let note_idx = k;
        let note = staff.notes[k];
        let slot = measure.slots[note.begin];
        try_opt_headbutt();
      }
    }
  }
}
function make_space_for_barlines(measures) {
  for (let i2 = 0; i2 < measures.length; i2++) {
    let measure = measures[i2];
    if (measure.barline == BARLINE.DOUBLE) {
      measure.pad.right += 4;
    } else if (measure.barline == BARLINE.END) {
      measure.pad.right += 8;
    } else if (measure.barline == BARLINE.REPEAT_END) {
      measure.pad.right += 12;
    } else if (measure.barline == BARLINE.REPEAT_BEGIN) {
      measures[i2 + 1].pad.left += 12;
    } else if (measure.barline == BARLINE.REPEAT_END_BEGIN) {
      measure.pad.right += 12;
      measures[i2 + 1].pad.left += 12;
    }
  }
}
function plan_beams(measure, staff_idx) {
  let staff = measure.staves[staff_idx];
  let beams = staff.beams;
  let notes = staff.notes;
  let slots = measure.slots;
  for (let beam of beams) {
    let notes_spanned = [];
    for (let i2 = 0; i2 < beam.length; i2++) {
      notes_spanned.push(notes[beam[i2]]);
    }
    if (!notes_spanned.length) {
      continue;
    }
    let stem_dir = notes_spanned[0].stem_dir;
    let pts = notes_spanned.map((n) => {
      let stem_length = n.stem_len;
      let x = slot_pos(measure, n.begin) + CONFIG.NOTE_WIDTH * (Number(n.stem_dir < 0) * slots[n.begin].mid_note);
      return { x, y: on_staff(2 * stem_dir * stem_length + n.staff_pos) };
    });
    let [m, b] = least_sq_regress(pts);
    if (Math.abs(m) > CONFIG.BEAM_MAX_SLOPE) {
      m = Math.sign(m) * CONFIG.BEAM_MAX_SLOPE;
      let anchor;
      if (stem_dir < 0) {
        anchor = pts.reduce(
          (acc, a) => a.y <= acc.y ? a : acc,
          { x: 0, y: Infinity }
        );
      } else {
        anchor = pts.reduce(
          (acc, a) => a.y >= acc.y ? a : acc,
          { x: 0, y: -Infinity }
        );
      }
      b = anchor.y - m * anchor.x;
    }
    for (let i2 = 0; i2 < notes_spanned.length; i2++) {
      let d = pts[i2].x * m + b - on_staff(notes_spanned[i2].staff_pos);
      if (Math.sign(d) != notes_spanned[i2].stem_dir) {
        b -= d;
        d = pts[i2].x * m + b - on_staff(notes_spanned[i2].staff_pos);
      }
      if (Math.abs(d) < CONFIG.LINE_HEIGHT * 1.5) {
        b += notes_spanned[i2].stem_dir * CONFIG.LINE_HEIGHT * 1.5;
      }
    }
    for (let i2 = 0; i2 < notes_spanned.length; i2++) {
      let d = pts[i2].x * m + b - on_staff(notes_spanned[i2].staff_pos);
      notes_spanned[i2].stem_len = Math.abs(d) / CONFIG.LINE_HEIGHT;
    }
    beam.m = m;
    beam.b = b;
  }
}
function plan_articulations(measure, staff_idx) {
  let staff = measure.staves[staff_idx];
  for (let k = 0; k < staff.notes.length; k++) {
    let note = staff.notes[k];
    if (note.articulation && note.articulation != ARTICULATION.ARPEGGIATED) {
      let head_note = note;
      let tail_note = note;
      while (head_note.prev_in_chord != null) {
        head_note = staff.notes[head_note.prev_in_chord];
      }
      while (tail_note.next_in_chord != null) {
        tail_note = staff.notes[tail_note.next_in_chord];
      }
      let lh = head_note.staff_pos;
      let lt = tail_note.staff_pos;
      let ya = (lh % 2 ? lh : lh - note.stem_dir) - note.stem_dir * 2;
      let line_b = Math.round(lt + note.stem_len * note.stem_dir * 2);
      let yb = (line_b % 2 ? line_b : line_b + note.stem_dir) + note.stem_dir * 2;
      let xa = 0;
      let xb = 1;
      let x, y;
      if (staff.voices <= 1) {
        if (note.articulation == ARTICULATION.TRILL) {
          ;
          [x, y] = note.stem_dir < 0 ? [xb, yb] : [xa, ya];
        } else {
          ;
          [x, y] = [xa, ya];
        }
      } else if (note.voice % 2) {
        if (note.stem_dir < 0) {
          ;
          [x, y] = [xa, ya];
        } else {
          ;
          [x, y] = [xb, yb];
        }
      } else {
        if (note.stem_dir < 0) {
          ;
          [x, y] = [xb, yb];
        } else {
          ;
          [x, y] = [xa, ya];
        }
      }
      note.articulation_pos = [x, y];
    }
  }
}
function compile_score(score2) {
  let score_ = score2;
  score_.indent = 0;
  let instr_set = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < score2.instruments.length; i2++) {
    for (let j = 0; j < score2.instruments[i2].names.length; j++) {
      instr_set.add(score2.instruments[i2].names[j]);
    }
  }
  let instrs = Array.from(instr_set);
  if (instrs.length > 1 || CONFIG.SHOW_SOLO_INSTRUMENT) {
    let w = 0;
    for (let i2 = 0; i2 < instrs.length; i2++) {
      w = Math.max(w, get_text_width(instrs[i2], FONT.DUPLEX, -2));
    }
    w *= CONFIG.INSTRUMENT_TEXT_SIZE / FONT_INHERENT_HEIGHT;
    score_.indent = w + CONFIG.INSTRUMENT_PAD_RIGHT;
  }
  score_.first_col_measure_indices = [];
  score_.slurred_ids = {};
  for (let i2 = 0; i2 < score_.slurs.length; i2++) {
    score_.slurred_ids[score_.slurs[i2].left] = true;
    score_.slurred_ids[score_.slurs[i2].right] = true;
  }
  for (let i2 = 0; i2 < score_.measures.length; i2++) {
    let measure = score_.measures[i2];
    for (let j = 0; j < measure.staves.length; j++) {
      let staff = measure.staves[j];
      staff.flags = {
        need_keysig: null,
        need_timesig: false,
        need_clef: false,
        need_cue: false,
        need_lyric: false
      };
      calc_staff_flags(score_, i2, j);
    }
    compile_measure(measure);
  }
  make_space_for_barlines(score_.measures);
  plan_measures(score_);
  return score_;
}
function least_sq_regress(pts) {
  let sum_x = 0;
  let sum_y = 0;
  let sum_xsq = 0;
  let sum_xy = 0;
  let n = pts.length;
  for (let p of pts) {
    sum_x += p.x;
    sum_y += p.y;
    sum_xsq += p.x ** 2;
    sum_xy += p.x * p.y;
  }
  let denom = n * sum_xsq - sum_x ** 2;
  if (denom == 0) {
    denom = 1e-4;
  }
  let m = (n * sum_xy - sum_x * sum_y) / denom;
  let b = (sum_y - m * sum_x) / n;
  return [m, b];
}
function pack_add(pack, idx, layer, top, bottom, exemption) {
  if (!exemption) {
    exemption = (_a, _b) => false;
  }
  if (!pack.intervals[layer]) {
    pack.intervals[layer] = [];
  }
  let track = pack.intervals[layer];
  for (let i2 = 0; i2 < 99; i2++) {
    let ok = true;
    for (let j = 0; j < track.length; j++) {
      if (track[j].x != i2) {
        continue;
      }
      if (interval_overlap(track[j].top, track[j].bottom, top, bottom) && !(track[j].top == top && track[j].bottom == bottom && exemption(idx, j))) {
        ok = false;
        break;
      }
    }
    if (ok) {
      track.push({ top, bottom, x: i2, idx });
      return;
    }
  }
}
function pack_width(pack) {
  let x = 0;
  for (let i2 = 0; i2 < pack.intervals.length; i2++) {
    if (!pack.intervals[i2]) continue;
    for (let j = 0; j < pack.intervals[i2].length; j++) {
      x = Math.max(pack.intervals[i2][j].x + 1, x);
    }
  }
  return x;
}
function make_measure_slots(measure) {
  let slots = new Array(Math.max(1, measure.duration)).fill(null).map((x) => ({
    mid_note: 0,
    left_grace: 0,
    left_squiggle: 0,
    left_deco: 0,
    right_deco: 0,
    left_note: 0,
    right_note: 0,
    right_spacing: 0,
    acc_pack: {
      intervals: new Array(measure.staves.length).fill(null).map((_) => [])
    },
    mid_pack: {
      intervals: new Array(measure.staves.length).fill(null).map((_) => [])
    }
  }));
  for (let k = 0; k < measure.staves.length; k++) {
    let merger = function(a, b) {
      return notes[a].duration < NOTE_LENGTH.HALF && notes[b].duration < NOTE_LENGTH.HALF || NOTE_LENGTH.HALF <= notes[a].duration && notes[a].duration < NOTE_LENGTH.WHOLE && NOTE_LENGTH.HALF <= notes[b].duration && notes[b].duration < NOTE_LENGTH.WHOLE;
    };
    let notes = measure.staves[k].notes;
    let rests = measure.staves[k].rests;
    for (let i2 = 0; i2 < notes.length; i2++) {
      let slot = slots[notes[i2].begin];
      if (notes[i2].stem_dir < 0) {
        if (notes[i2].twisted) {
          slot.right_note = 1;
        } else {
          slot.mid_note = 1;
          pack_add(
            slot.mid_pack,
            i2,
            k,
            notes[i2].staff_pos - 1,
            notes[i2].staff_pos + 1,
            CONFIG.HEADBUTT_MERGE && merger
          );
        }
      } else {
        if (notes[i2].twisted) {
          slot.left_note = 1;
        } else {
          slot.mid_note = 1;
          pack_add(
            slot.mid_pack,
            i2,
            k,
            notes[i2].staff_pos - 1,
            notes[i2].staff_pos + 1,
            CONFIG.HEADBUTT_MERGE && merger
          );
        }
      }
      if (notes[i2].modifier) {
        slot.right_deco = Math.max(1, slot.right_deco);
      }
      if (notes.length > 1) {
        let v = CONFIG.DURATION_BASED_SPACING * notes[i2].duration;
        if (!slot.right_spacing) {
          slot.right_spacing = v;
        } else {
          slot.right_spacing = Math.min(v, slot.right_spacing);
        }
      }
      if (notes[i2].flag_count && !notes[i2].beamed && notes[i2].stem_dir < 0 && !notes[i2].twisted) {
        slot.right_deco = Math.max(1, slot.right_deco);
      }
      if (notes[i2].articulation == ARTICULATION.ARPEGGIATED) {
        slot.left_squiggle = CONFIG.SQUIGGLE_WIDTH_MUL;
      }
      if (notes[i2].accidental !== null) {
        pack_add(
          slot.acc_pack,
          i2,
          k,
          notes[i2].staff_pos - 3,
          notes[i2].staff_pos + 2
        );
      }
    }
    for (let i2 = 0; i2 < rests.length; i2++) {
      let slot = slots[rests[i2].begin];
      slot.mid_note = Math.max(slot.mid_note, CONFIG.REST_WIDTH_MUL);
    }
    for (let i2 = 0; i2 < measure.staves[k].grace.length; i2++) {
      if (measure.staves[k].grace[i2]) {
        let slot = slots[i2];
        let d = [0, 0, 0];
        slot_pos(
          measure.staves[k].grace[i2],
          measure.staves[k].grace[i2].duration,
          d
        );
        slot.left_grace = d[0] * CONFIG.GRACE_WIDTH_MUL + d[1] * measure.staves[k].grace[i2].pad.inter / CONFIG.NOTE_WIDTH;
      }
    }
    if (!notes.length) {
      slots[0].mid_note = Math.max(slots[0].mid_note, CONFIG.REST_WIDTH_MUL);
    }
  }
  for (let i2 = 0; i2 < slots.length; i2++) {
    slots[i2].left_deco = pack_width(slots[i2].acc_pack) * CONFIG.ACCIDENTAL_WIDTH_MUL;
  }
  for (let i2 = 0; i2 < slots.length; i2++) {
    slots[i2].mid_note = Math.max(
      slots[i2].mid_note,
      pack_width(slots[i2].mid_pack) * 1
    );
  }
  let lyric_slots = new Array(slots.length).fill(false);
  for (let k = 0; k < measure.staves.length; k++) {
    let notes = measure.staves[k].notes;
    for (let i2 = 0; i2 < notes.length; i2++) {
      if (notes[i2].lyric) {
        lyric_slots[notes[i2].begin] = true;
      }
    }
  }
  for (let k = 0; k < measure.staves.length; k++) {
    let notes = measure.staves[k].notes;
    for (let i2 = 0; i2 < notes.length; i2++) {
      if (notes[i2].lyric) {
        let slot = slots[notes[i2].begin];
        let w = get_text_width(notes[i2].lyric) * CONFIG.LYRIC_SCALE;
        let w0 = (slot.mid_note + slot.right_note + slot.right_deco + slot.right_spacing) * CONFIG.NOTE_WIDTH;
        let n = notes[i2].begin + 1;
        while (!lyric_slots[n] && n < lyric_slots.length) {
          let ww = slots[n].left_deco + slots[n].left_grace + slots[n].left_note + slots[n].left_squiggle + slots[n].mid_note + slots[n].right_deco + slots[n].right_note + slots[n].right_spacing;
          if (ww) {
            w0 += CONFIG.INTER_NOTE_WIDTH;
          }
          w0 += ww * CONFIG.NOTE_WIDTH;
          n++;
        }
        if (w0 < w) {
          let due = (w - w0) / CONFIG.NOTE_WIDTH;
          let spread = due / (n - notes[i2].begin);
          for (let m = notes[i2].begin; m < n; m++) {
            slots[m].right_spacing += spread;
          }
        }
      }
    }
  }
  measure.slots = slots;
}
function estimate_staff_ybound(staff, slurred_ids) {
  let ymin = 0;
  let ymax = (CONFIG.LINES_PER_STAFF - 1) * 2;
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let line = note.staff_pos;
    let y0 = line;
    let y1 = y0;
    if (note.stem_dir < 0) {
      y0 -= note.stem_len * 2;
    } else {
      y1 += note.stem_len * 2;
    }
    if (note.tuplet) {
      if (note.stem_dir < 0) {
        y0 -= 3;
      } else {
        y1 += 3;
      }
    }
    if (note.articulation_pos) {
      y0 = Math.min(y0, note.articulation_pos[1] - 2);
      y1 = Math.max(y1, note.articulation_pos[1] + 2);
    }
    if (note.id && slurred_ids[note.id]) {
      y0 -= 2;
      y1 += 2;
    }
    y0 -= 1;
    y1 += 1;
    ymin = Math.min(ymin, y0);
    ymax = Math.max(ymax, y1);
  }
  for (let i2 = 0; i2 < staff.rests.length; i2++) {
    let rest = staff.rests[i2];
    ymin = Math.min(ymin, rest.staff_pos - 2);
    ymax = Math.max(ymax, rest.staff_pos + 2);
  }
  let ya = on_staff(ymin);
  let yb = on_staff(ymax);
  let { need_cue, need_lyric } = staff.flags;
  let yc = need_cue ? CONFIG.CUE_HEIGHT : 0;
  let yd = need_lyric ? FONT_INHERENT_HEIGHT * CONFIG.LYRIC_SCALE + CONFIG.LYRIC_SPACING * 2 : 0;
  return [ya, yb + yc + yd];
}
function compile_rests(staff) {
  let voice_median_staff_pos = get_median_staff_pos(staff.notes);
  let notes = staff.notes;
  let rests = staff.rests;
  function rest_staff_pos(rest) {
    let y;
    if (staff.voices <= 1) {
      y = 4;
    } else if (staff.voices == 2) {
      if (voice_median_staff_pos[rest.voice] == void 0) {
        if (rest.voice) {
          y = 8;
        } else {
          y = 0;
        }
      } else {
        let other_voice = (rest.voice + 1) % staff.voices;
        if (
          // (voice_median_staff_pos[other_voice] < voice_median_staff_pos[rest.voice]) ||
          //   (
          //     voice_median_staff_pos[other_voice] == voice_median_staff_pos[rest.voice] &&
          other_voice < rest.voice
        ) {
          y = voice_median_staff_pos[rest.voice] + 4;
          for (let i2 = 0; i2 < notes.length; i2++) {
            if (notes[i2].voice != other_voice) {
              continue;
            }
            if (notes[i2].begin == rest.begin) {
              y = Math.max(y, 5 + notes[i2].staff_pos);
            }
          }
          y = ~~(y / 2) * 2;
        } else {
          y = voice_median_staff_pos[rest.voice] - 4;
          for (let i2 = 0; i2 < notes.length; i2++) {
            if (notes[i2].voice != other_voice) {
              continue;
            }
            if (notes[i2].begin == rest.begin) {
              y = Math.min(y, -5 + notes[i2].staff_pos);
            }
          }
          y = ~~(y / 2) * 2;
        }
      }
    } else {
      y = voice_median_staff_pos[rest.voice];
    }
    return y;
  }
  for (let i2 = 0; i2 < rests.length; i2++) {
    rests[i2].staff_pos = rest_staff_pos(rests[i2]);
  }
}
function plan_measures(score2) {
  let measures = score2.measures;
  let measure_widths = [];
  for (let i2 = 0; i2 < measures.length; i2++) {
    let w = [0, 0, 0];
    slot_pos(measures[i2], measures[i2].duration, w);
    w[0] += w[2] / CONFIG.NOTE_WIDTH;
    measure_widths.push(w);
  }
  let rows = [{ count: 0, width: 0, num_inter: 0 }];
  for (let i2 = 0; i2 < measures.length; i2++) {
    if (!i2) {
      measures[i2].is_first_col = true;
      score2.first_col_measure_indices.push(i2);
    }
    let row = rows[rows.length - 1];
    if (row.width + measure_widths[i2][0] <= (CONTENT_WIDTH() - (rows.length == 1 ? score2.indent : 0)) / CONFIG.NOTE_WIDTH) {
      row.count++;
      row.width += measure_widths[i2][0];
      row.num_inter += measure_widths[i2][1];
    } else {
      if (i2) measures[i2 - 1].is_last_col = true;
      measures[i2].is_first_col = true;
      score2.first_col_measure_indices.push(i2);
      for (let j = 0; j < measures[i2].staves.length; j++) {
        measures[i2].staves[j].flags.need_clef = true;
        let [acc, num_acc] = measures[i2].staves[j].key_signature;
        measures[i2].staves[j].flags.need_keysig = {
          accidental: acc,
          count: num_acc
        };
      }
      let w = [0, 0, 0];
      slot_pos(measures[i2], measures[i2].duration, w);
      w[0] += w[2] / CONFIG.NOTE_WIDTH;
      measure_widths[i2] = w;
      row = {
        count: 1,
        width: measure_widths[i2][0],
        num_inter: measure_widths[i2][1]
      };
      rows.push(row);
    }
  }
  let j0 = 0;
  let row_ybounds = [];
  let num_staves = measures.map((x) => x.staves.length).reduce((acc, x) => Math.max(acc, x), 0);
  for (let i2 = 0; i2 < rows.length; i2++) {
    for (let k = 0; k < num_staves; k++) {
      let [has_cue, has_lyric] = [false, false];
      for (let j = j0; j < j0 + rows[i2].count; j++) {
        if (!measures[j].staves[k]) {
          continue;
        }
        has_cue = has_cue || measures[j].staves[k].flags.need_cue;
        has_lyric = has_lyric || measures[j].staves[k].flags.need_lyric;
      }
      for (let j = j0; j < j0 + rows[i2].count; j++) {
        if (!measures[j].staves[k]) {
          continue;
        }
        measures[j].staves[k].flags.need_cue = has_cue;
        measures[j].staves[k].flags.need_lyric = has_lyric;
      }
    }
    j0 += rows[i2].count;
  }
  j0 = 0;
  for (let i2 = 0; i2 < rows.length; i2++) {
    let extra = CONTENT_WIDTH() - (i2 == 0 ? score2.indent : 0) - rows[i2].width * CONFIG.NOTE_WIDTH;
    let nw = extra / rows[i2].num_inter;
    for (let j = j0; j < j0 + rows[i2].count; j++) {
      measures[j].pad.inter += i2 == rows.length - 1 && extra / CONTENT_WIDTH() > 1 - CONFIG.JUSTIFY_ALIGN_MIN ? 0 : nw;
    }
    j0 += rows[i2].count;
  }
  for (let i2 = 0; i2 < measures.length; i2++) {
    let measure = measures[i2];
    for (let j = 0; j < measure.staves.length; j++) {
      plan_beams(measure, j);
      plan_articulations(measure, j);
    }
  }
  j0 = 0;
  for (let i2 = 0; i2 < rows.length; i2++) {
    row_ybounds[i2] = [];
    for (let k = 0; k < num_staves; k++) {
      let [ya, yb] = [0, 0, 0, 0];
      for (let j = j0; j < j0 + rows[i2].count; j++) {
        if (!measures[j].staves[k]) {
          continue;
        }
        let [y0, y1] = estimate_staff_ybound(
          measures[j].staves[k],
          score2.slurred_ids
        );
        ya = Math.min(y0, ya);
        yb = Math.max(y1, yb);
      }
      let ymin = ya;
      let ymax = yb;
      row_ybounds[i2][k] = [ymin, ymax];
    }
    j0 += rows[i2].count;
  }
  let xoff = score2.indent;
  let yoff = -row_ybounds[0][0][0];
  let row_num = 0;
  let col_num = 0;
  if (rows[0] && rows[1] && rows[0].count == 0) {
    xoff = 0;
    yoff = -row_ybounds[1][0][0];
    row_num++;
  }
  for (let i2 = 0; i2 < measures.length; i2++) {
    let yo = 0;
    let staves = measures[i2].staves;
    let w = slot_pos(measures[i2], measures[i2].duration);
    for (let j = 0; j < staves.length; j++) {
      let sp = CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1) + CONFIG.INTER_STAFF_HEIGHT;
      let r = row_ybounds[row_num][j][1];
      let staff_xoff = xoff;
      let staff_yoff = yoff + yo;
      if (j != staves.length - 1) {
        r -= row_ybounds[row_num][j + 1][0];
      }
      sp = Math.max(sp, r);
      if (j != staves.length - 1) {
        yo += sp;
      } else {
        yo += CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
      }
      staves[j].coords.x = staff_xoff;
      staves[j].coords.y = staff_yoff;
      staves[j].coords.row = row_num;
      staves[j].coords.col = col_num;
      staves[j].coords.w = w;
      staves[j].coords.local_y_min = row_ybounds[row_num][j][0];
      staves[j].coords.local_y_max = row_ybounds[row_num][j][1];
      for (let k = 0; k < staves[j].grace.length; k++) {
        if (!staves[j].grace[k]) {
          continue;
        }
        let slot_x = slot_pos(measures[i2], k);
        let slot = measures[i2].slots[k];
        slot_x -= (slot.left_note + slot.left_deco + slot.left_squiggle + slot.left_grace) * CONFIG.NOTE_WIDTH + measures[i2].pad.inter;
        staves[j].grace[k].staves[0].coords.x = staff_xoff + slot_x;
        staves[j].grace[k].staves[0].coords.y = staff_yoff;
        staves[j].grace[k].staves[0].coords.row = row_num;
        staves[j].grace[k].staves[0].coords.col = col_num;
        staves[j].grace[k].staves[0].coords.w = slot_pos(staves[j].grace[k], staves[j].grace[k].duration) * CONFIG.GRACE_WIDTH_MUL;
        staves[j].grace[k].staves[0].coords.local_y_min = row_ybounds[row_num][j][0];
        staves[j].grace[k].staves[0].coords.local_y_max = row_ybounds[row_num][j][1];
      }
    }
    xoff += w;
    col_num++;
    if (measures[i2].is_last_col || i2 == measures.length - 1) {
      xoff = 0;
      let sp = row_ybounds[row_num][row_ybounds[row_num].length - 1][1];
      sp -= CONFIG.LINE_HEIGHT * (CONFIG.LINES_PER_STAFF - 1);
      row_num++;
      col_num = 0;
      if (row_ybounds[row_num]) {
        sp -= row_ybounds[row_num][0][0];
      }
      sp = Math.max(sp + 30, CONFIG.INTER_ROW_HEIGHT);
      yo += sp;
      yoff += yo;
    }
  }
}

// src/fx.ts
var PERLIN_YWRAPB = 4;
var PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
var PERLIN_ZWRAPB = 8;
var PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
var PERLIN_SIZE = 4095;
var perlin_octaves = 4;
var perlin_amp_falloff = 0.5;
var scaled_cosine = function(i2) {
  return 0.5 * (1 - Math.cos(i2 * Math.PI));
};
var p_perlin;
function noise(x, y = 0, z = 0) {
  if (p_perlin == null) {
    p_perlin = new Array(PERLIN_SIZE + 1);
    for (let i2 = 0; i2 < PERLIN_SIZE + 1; i2++) {
      p_perlin[i2] = Math.random();
    }
  }
  if (x < 0) {
    x = -x;
  }
  if (y < 0) {
    y = -y;
  }
  if (z < 0) {
    z = -z;
  }
  let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
  let xf = x - xi;
  let yf = y - yi;
  let zf = z - zi;
  let rxf, ryf;
  let r = 0;
  let ampl = 0.5;
  let n1, n2, n3;
  for (let o = 0; o < perlin_octaves; o++) {
    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
    rxf = scaled_cosine(xf);
    ryf = scaled_cosine(yf);
    n1 = p_perlin[of & PERLIN_SIZE];
    n1 += rxf * (p_perlin[of + 1 & PERLIN_SIZE] - n1);
    n2 = p_perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
    n2 += rxf * (p_perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
    n1 += ryf * (n2 - n1);
    of += PERLIN_ZWRAP;
    n2 = p_perlin[of & PERLIN_SIZE];
    n2 += rxf * (p_perlin[of + 1 & PERLIN_SIZE] - n2);
    n3 = p_perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
    n3 += rxf * (p_perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
    n2 += ryf * (n3 - n2);
    n1 += scaled_cosine(zf) * (n2 - n1);
    r += n1 * ampl;
    ampl *= perlin_amp_falloff;
    xi <<= 1;
    xf *= 2;
    yi <<= 1;
    yf *= 2;
    zi <<= 1;
    zf *= 2;
    if (xf >= 1) {
      xi++;
      xf--;
    }
    if (yf >= 1) {
      yi++;
      yf--;
    }
    if (zf >= 1) {
      zi++;
      zf--;
    }
  }
  return r;
}
function resample_polyline(polyline, l, L) {
  let q = [];
  for (let i2 = 0; i2 < polyline.length - 1; i2++) {
    let a = polyline[i2];
    let b = polyline[i2 + 1];
    let s = Math.hypot(a[0] - b[0], a[1] - b[1]);
    let n = Math.ceil(s / l);
    if (s >= L) {
      n = 1;
    }
    for (let j = 0; j < n; j++) {
      let t = j / n;
      let c = [a[0] * (1 - t) + b[0] * t, a[1] * (1 - t) + b[1] * t];
      q.push(c);
    }
    q.push(b.slice());
  }
  return q;
}
function disturb_polylines(elements, polylines, multiplier = 1) {
  let content_y = 0;
  for (let i2 = 0; i2 < elements.length; i2++) {
    if (elements[i2].type == "composer" || elements[i2].type == "tempo" || elements[i2].type == "title" || elements[i2].type == "subtitle") {
      content_y = Math.max(content_y, elements[i2].y + elements[i2].h);
    }
  }
  let q = [];
  for (let i2 = 0; i2 < polylines.length; i2++) {
    let qq = [];
    let bbox = bounding_box(polylines[i2]);
    if (bbox.y - 4 <= content_y) {
      for (let j = 0; j < polylines[i2].length; j++) {
        let [x, y] = polylines[i2][j];
        x += (noise(x * 0.01, y * 0.01, 1 + i2 * 0.1) * 2 - 1) * 2 * multiplier;
        y += (noise(x * 0.01, y * 0.01, 2 + i2 * 0.1) * 2 - 1) * 2 * multiplier;
        x -= Math.min(y * 0.1, 20) * multiplier;
        y -= Math.min(x * 0.01, 20) * multiplier;
        qq.push([x, y]);
      }
    } else {
      for (let j = 0; j < polylines[i2].length; j++) {
        let [x, y] = polylines[i2][j];
        x += (noise(x * 0.01, y * 0.01, 1 + i2 * 0.1) * 2 - 1) * 6 * multiplier;
        y += (noise(x * 0.01, y * 0.01, 2 + i2 * 0.1) * 2 - 1) * 5 * multiplier;
        x -= Math.min(y * 0.015, 20) * multiplier;
        y -= Math.min(x * 0.01, 20) * multiplier;
        qq.push([x, y]);
      }
    }
    q.push(qq);
  }
  return q;
}
function export_sketch_svg(dr, { noise_mul = 1 } = {}) {
  let p = dr.polylines.map((x) => resample_polyline(x, 5, 500));
  p = disturb_polylines(dr.elements, p, noise_mul);
  let o = `<svg xmlns="http://www.w3.org/2000/svg" width="${dr.w}" height="${dr.h}">`;
  o += `<rect x="0" y="0" width="${dr.w}" height="${dr.h}" fill="antiquewhite"></rect>`;
  for (let i2 = 0; i2 < p.length; i2++) {
    o += `<path stroke="#2B1100" stroke-opacity="${Math.random() * 0.1 + 0.6}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" d="M `;
    for (let j = 0; j < p[i2].length; j++) {
      o += p[i2][j] + " ";
    }
    o += `"/>`;
  }
  o += `</svg>`;
  return o;
}

// src/midicompile.ts
var MAX_VOICES = 2;
var NOTE_LENGTH2 = {
  WHOLE: 32,
  HALF: 16,
  QUARTER: 8,
  EIGHTH: 4,
  SIXTEENTH: 2,
  THIRTYSECOND: 1
};
var NOTE_LENGTH_QUANT = 2;
var NOTE_LENGTH_MODIFIER2 = 1.5;
var NAME2PITCH = {
  Ab_0: 8,
  Ab_1: 20,
  Ab_2: 32,
  Ab_3: 44,
  Ab_4: 56,
  Ab_5: 68,
  Ab_6: 80,
  Ab_7: 92,
  Ab_8: 104,
  Ab_9: 116,
  F_3: 41,
  Ds_8: 99,
  Ds_9: 111,
  F_8: 101,
  F_9: 113,
  Gs_3: 44,
  Gs_2: 32,
  Gs_1: 20,
  Gs_0: 8,
  Gs_7: 92,
  Gs_6: 80,
  Gs_5: 68,
  Gs_4: 56,
  G_10: 127,
  Gs_9: 116,
  Gs_8: 104,
  E_3: 40,
  E_2: 28,
  E_1: 16,
  E_0: 4,
  E_7: 88,
  E_6: 76,
  E_5: 64,
  E_4: 52,
  E_9: 112,
  E_8: 100,
  As_9: 118,
  As_8: 106,
  Ds_0: 3,
  Ds_1: 15,
  Ds_6: 75,
  Ds_7: 87,
  Ds_4: 51,
  Ds_5: 63,
  As_1: 22,
  As_0: 10,
  As_3: 46,
  As_2: 34,
  As_5: 70,
  As_4: 58,
  As_7: 94,
  As_6: 82,
  Cs_7: 85,
  Cs_6: 73,
  Cs_5: 61,
  Cs_4: 49,
  Bb_9: 118,
  Cs_2: 25,
  Cs_1: 13,
  Cs_0: 1,
  Bb_5: 70,
  Bb_4: 58,
  Bb_7: 94,
  Bb_6: 82,
  Bb_1: 22,
  Bb_0: 10,
  Cs_9: 109,
  Cs_8: 97,
  Bb_8: 106,
  Bb_3: 46,
  Bb_2: 34,
  A_7: 93,
  A_6: 81,
  A_5: 69,
  A_4: 57,
  A_3: 45,
  A_2: 33,
  A_1: 21,
  A_0: 9,
  F_4: 53,
  A_9: 117,
  A_8: 105,
  B_8: 107,
  B_9: 119,
  F_10: 125,
  B_0: 11,
  B_1: 23,
  B_2: 35,
  B_3: 47,
  B_4: 59,
  B_5: 71,
  B_6: 83,
  B_7: 95,
  Fs_0: 6,
  Fs_1: 18,
  Fs_2: 30,
  Fs_3: 42,
  Fs_4: 54,
  Fs_5: 66,
  F_5: 65,
  Fs_7: 90,
  Fs_8: 102,
  Fs_9: 114,
  Gb_8: 102,
  Gb_9: 114,
  Gb_2: 30,
  Gb_3: 42,
  Gb_0: 6,
  Gb_1: 18,
  Gb_6: 78,
  Gb_7: 90,
  Gb_4: 54,
  Gb_5: 66,
  F_6: 77,
  Fs_6: 78,
  Eb_8: 99,
  Eb_9: 111,
  E_10: 124,
  Eb_4: 51,
  Eb_5: 63,
  Eb_6: 75,
  Eb_7: 87,
  Eb_0: 3,
  Eb_1: 15,
  Eb_2: 27,
  Eb_3: 39,
  D_8: 98,
  D_9: 110,
  D_2: 26,
  D_3: 38,
  D_0: 2,
  D_1: 14,
  D_6: 74,
  D_7: 86,
  D_4: 50,
  D_5: 62,
  F_2: 29,
  G_9: 115,
  G_8: 103,
  G_5: 67,
  G_4: 55,
  G_7: 91,
  G_6: 79,
  G_1: 19,
  G_0: 7,
  G_3: 43,
  G_2: 31,
  Cs_3: 37,
  Db_9: 109,
  Db_8: 97,
  Db_3: 37,
  Db_2: 25,
  Db_1: 13,
  Db_0: 1,
  Db_7: 85,
  Db_6: 73,
  Db_5: 61,
  Db_4: 49,
  C_1: 12,
  C_0: 0,
  C_3: 36,
  C_2: 24,
  C_5: 60,
  C_4: 48,
  C_7: 84,
  C_6: 72,
  C_9: 108,
  C_8: 96,
  Ds_2: 27,
  Ds_3: 39,
  D_10: 122,
  C_10: 120,
  F_7: 89,
  F_0: 5,
  F_1: 17
};
for (let i2 = 0; i2 <= 10; i2++) {
  NAME2PITCH["Es_" + i2] = NAME2PITCH["F_" + i2];
  NAME2PITCH["Fb_" + i2] = NAME2PITCH["E_" + i2];
  NAME2PITCH["Bs_" + i2] = NAME2PITCH["C_" + (i2 + 1)];
  NAME2PITCH["Cb_" + i2] = NAME2PITCH["B_" + (i2 - 1)];
}
function classify_key_signature(key_sig) {
  let [num_acc, is_minor] = key_sig;
  let acc = ACCIDENTAL.NATURAL;
  if (num_acc < 0) {
    acc = ACCIDENTAL.FLAT;
    num_acc = -num_acc;
  } else if (num_acc) {
    acc = ACCIDENTAL.SHARP;
  }
  return [acc, num_acc];
}
function note_duration_overlap(a, b) {
  let x1 = a.begin;
  let x2 = a.begin + a.duration;
  let y1 = b.begin;
  let y2 = b.begin + b.duration;
  return x1 < y2 && y1 < x2;
}
var _pitch2name_cache = {};
function infer_name_from_pitch(pitch, key_signature) {
  let candidates = [];
  let key = pitch | key_signature[0] << 24 | key_signature[1] << 16;
  let val = _pitch2name_cache[key];
  if (val !== void 0) {
    return val;
  }
  for (let name in NAME2PITCH) {
    if (NAME2PITCH[name] == pitch) {
      candidates.push(name);
    }
  }
  if (candidates.length == 0) {
    return null;
  }
  if (candidates.length == 1) {
    _pitch2name_cache[key] = candidates[0];
    return candidates[0];
  }
  let [acc, num_acc] = key_signature;
  let acc_notes = ORDER_OF_ACCIDENTALS[acc].slice(0, num_acc).split("");
  for (let n of acc_notes) {
    for (let i2 = 0; i2 < candidates.length; i2++) {
      if (acc == ACCIDENTAL.SHARP && candidates[i2].startsWith(n + "s")) {
        _pitch2name_cache[key] = candidates[i2];
        return candidates[i2];
      } else if (acc == ACCIDENTAL.FLAT && candidates[i2].startsWith(n + "b")) {
        _pitch2name_cache[key] = candidates[i2];
        return candidates[i2];
      }
    }
  }
  _pitch2name_cache[key] = candidates[0];
  return candidates[0];
}
function compare_wholeness(a, b) {
  for (let i2 = 5; i2 >= 0; i2--) {
    let p = Math.pow(2, i2);
    let ap = a / p;
    let bp = b / p;
    ap -= ~~ap;
    bp -= ~~bp;
    if (ap == 0 && bp == 0) {
      return 0;
    } else if (ap > 0 && bp == 0) {
      return -1;
    } else if (ap == 0 && bp > 0) {
      return 1;
    }
  }
  return 0;
}
function factor_rest_duration(begin, dur, channel) {
  let l = dur;
  let b = begin;
  let rests = [];
  while (l > 0) {
    let ll = 0;
    for (let p = 0; p <= 5; p++) {
      let d = Math.pow(2, p);
      if (l < d) {
        break;
      }
      if (compare_wholeness(b + d, b) > 0) {
        ll = d;
        break;
      }
    }
    if (!ll) {
      for (let p = 5; p >= 0; p--) {
        let d = Math.pow(2, p);
        if (l >= d) {
          ll = d;
          break;
        }
      }
    }
    rests.push({
      begin: b,
      duration: ll,
      voice: channel,
      tuplet: null
    });
    l -= ll;
    b += ll;
  }
  return rests;
}
function find_rests(measure, staff_idx, channels) {
  let measure_length = measure.duration;
  let staff = measure.staves[staff_idx];
  let rests = [];
  let did = false;
  for (let c of channels) {
    let channel_notes = staff.notes.filter((x) => x.voice == c);
    if (!channel_notes.length) {
      continue;
    }
    did = true;
    let bins = new Array(measure_length).fill(true);
    for (let i2 = 0; i2 < measure_length; i2++) {
      for (let m of channel_notes) {
        if (m.voice == c) {
          if (m.begin <= i2 && i2 < m.begin + m.duration) {
            bins[i2] = false;
            break;
          }
        }
      }
    }
    let last_length = 0;
    for (let i2 = 0; i2 < bins.length + 1; i2++) {
      if (i2 < bins.length && bins[i2]) {
        last_length++;
      } else {
        if (last_length > 0) {
          rests.push(...factor_rest_duration(i2 - last_length, last_length, c));
        }
        last_length = 0;
      }
    }
  }
  if (!did) {
    rests.push(...factor_rest_duration(0, measure_length, channels[0]));
  }
  return rests;
}
function get_piece_title(pattern) {
  let title = [];
  for (let track of pattern.tracks) {
    for (let event of track.events) {
      if (event.type == "SEQUENCE_OR_TRACK_NAME") {
        title.push(...event.data["text"].split("\n"));
      }
    }
  }
  return title;
}
function is_note_on_event(evt) {
  return evt.type == "NOTE_ON" && evt.data["velocity"] != 0;
}
function is_note_off_event(evt) {
  return evt.type == "NOTE_OFF" || evt.type == "NOTE_ON" && evt.data["velocity"] == 0;
}
function pattern_to_tick_tables(pattern) {
  let res = pattern.ticks_per_quarter_note;
  let sections = [];
  let track_id = -1;
  let end_of_track = 0;
  let last_time_sig = null;
  let last_key_sig = null;
  for (let track of pattern.tracks) {
    track_id += 1;
    let t = 0;
    for (let event of track.events) {
      t += event.delta_time;
      if (event.type == "TIME_SIGNATURE" && track_id == 0) {
        let ts = [
          event.data["numerator"],
          2 ** event.data["denominator_exp"]
        ];
        if (sections.length == 0 || sections[sections.length - 1][1][0] != null) {
          sections.push([t, [ts, last_key_sig], []]);
        } else {
          sections[sections.length - 1][1][0] = ts;
        }
        last_time_sig = ts;
      } else if (event.type == "KEY_SIGNATURE" && track_id == 0) {
        let ks = classify_key_signature([
          event.data["num_sharps_or_flats"],
          event.data["is_minor"]
        ]);
        if (sections.length == 0 || sections[sections.length - 1][1][1] != null) {
          sections.push([t, [last_time_sig, ks], []]);
        } else {
          sections[sections.length - 1][1][1] = ks;
        }
        last_key_sig = ks;
      } else if (event.type == "END_OF_TRACK") {
        end_of_track = Math.max(t, end_of_track);
      } else {
        for (let i2 = 0; i2 < sections.length; i2++) {
          let idx = sections.length - i2 - 1;
          if (t >= sections[idx][0]) {
            if (event.type == "NOTE_ON" || event.type == "NOTE_OFF") {
              let name;
              if (is_note_on_event(event)) {
                name = "NOTE_ON";
              } else if (is_note_off_event(event)) {
                name = "NOTE_OFF";
              }
              sections[idx][2].push({
                name,
                abs_tick: t - sections[idx][0],
                pitch: event.data["key"],
                channel: (track_id * 16 + event.data["channel"]) * 100
              });
            }
            break;
          }
        }
      }
    }
  }
  let unpaired = [];
  for (let i2 = 0; i2 < sections.length; i2++) {
    for (let j = 0; j < sections[i2][2].length; j++) {
      let note = sections[i2][2][j];
      if (note.name == "NOTE_ON") {
        unpaired.unshift([true, i2, j, note]);
      } else if (note.name == "NOTE_OFF") {
        for (let k = 0; k < unpaired.length; k++) {
          let up = unpaired[k];
          if (up[0] && up[3].channel == note.channel && up[3].pitch == note.pitch) {
            unpaired[k][0] = false;
            sections[up[1]][2][up[2]].duration = note.abs_tick - up[3].abs_tick;
            break;
          }
        }
      }
    }
  }
  let tick_tables = [];
  for (let i2 = 0; i2 < sections.length; i2++) {
    let end_tick = i2 + 1 < sections.length ? sections[i2 + 1][0] : end_of_track;
    tick_tables.push({
      time_signature: sections[i2][1][0],
      key_signature: sections[i2][1][1] ?? [0, 0],
      resolution: res,
      duration: end_tick - sections[i2][0],
      notes: []
    });
    for (let j = 0; j < sections[i2][2].length; j++) {
      let note = sections[i2][2][j];
      if (sections[i2][2][j].name == "NOTE_ON") {
        if (note.duration !== void 0) {
          let dur = note.duration;
          tick_tables[tick_tables.length - 1].notes.push({
            begin: note.abs_tick,
            pitch: note.pitch,
            duration: dur,
            channel: note.channel
          });
        } else {
          console.warn(`WARNING: Unpaired NOTE_ON event, discarding!`, note);
        }
      }
    }
  }
  return tick_tables;
}
function split_voices(measures) {
  function collide(a, b) {
    if (a.begin == b.begin && a.duration == b.duration) {
      return a.pitch == b.pitch;
    }
    return note_duration_overlap(a, b);
  }
  function collide_with_channel(measure, index) {
    let channel = measure.notes[index].channel;
    for (let i2 = 0; i2 < index; i2++) {
      if (measure.notes[i2].channel != channel) {
        continue;
      }
      if (collide(measure.notes[index], measure.notes[i2])) {
        return true;
      }
    }
    return false;
  }
  for (let i2 = 0; i2 < measures.length; i2++) {
    let notes = measures[i2].notes;
    let cross_ties = measures[i2].cross_ties;
    for (let j = 0; j < notes.length; j++) {
      let note = notes[j];
      let skip = false;
      for (let k = 0; k < cross_ties.length; k++) {
        if (note == cross_ties[k].right) {
          skip = true;
          break;
        }
      }
      if (skip) continue;
      while (collide_with_channel(measures[i2], j)) {
        note.channel++;
      }
      for (let k = 0; k < measures[i2].cross_ties.length; k++) {
        if (measures[i2].cross_ties[k].left == note) {
          measures[i2].cross_ties[k].right.channel = note.channel;
        }
      }
    }
  }
}
function classify_note_length(length) {
  let d0 = 1024;
  let l0 = -1;
  let mod = false;
  for (let k in NOTE_LENGTH2) {
    let l = NOTE_LENGTH2[k];
    let d = Math.abs(length - l);
    if (d < d0) {
      l0 = l;
      d0 = d;
    }
  }
  for (let k in NOTE_LENGTH2) {
    let l = ~~(NOTE_LENGTH2[k] * NOTE_LENGTH_MODIFIER2);
    let d = Math.abs(length - l);
    if (d < d0) {
      mod = true;
      l0 = l;
      d0 = d;
    }
  }
  return [l0, mod];
}
function has_modifier(length) {
  if (length == NOTE_LENGTH2.THIRTYSECOND * NOTE_LENGTH_MODIFIER2) return true;
  if (length == NOTE_LENGTH2.SIXTEENTH * NOTE_LENGTH_MODIFIER2) return true;
  if (length == NOTE_LENGTH2.EIGHTH * NOTE_LENGTH_MODIFIER2) return true;
  if (length == NOTE_LENGTH2.QUARTER * NOTE_LENGTH_MODIFIER2) return true;
  if (length == NOTE_LENGTH2.HALF * NOTE_LENGTH_MODIFIER2) return true;
  if (length == NOTE_LENGTH2.WHOLE * NOTE_LENGTH_MODIFIER2) return true;
  return false;
}
function tick2length(tick, resolution) {
  let ticks_per_quarter_note = resolution;
  let num_quarter_notes = tick / ticks_per_quarter_note;
  let num_32nd_notes = num_quarter_notes * (NOTE_LENGTH2.QUARTER / NOTE_LENGTH2.THIRTYSECOND);
  return num_32nd_notes;
}
function length2tick(length, resolution) {
  let num_32nd_notes = length;
  let num_quarter_notes = num_32nd_notes * (NOTE_LENGTH2.THIRTYSECOND * 1 / NOTE_LENGTH2.QUARTER);
  let ticks_per_quarter_note = resolution;
  let num_ticks = num_quarter_notes * ticks_per_quarter_note;
  return ~~num_ticks;
}
function tick_table_to_measures(tick_table) {
  let time_sig = tick_table.time_signature;
  let key_sig = tick_table.key_signature;
  let resolution = tick_table.resolution;
  let notes = tick_table.notes;
  let measures = [];
  function getmeasurelength() {
    let ticks_per_quarter_note = resolution;
    let num_beats = time_sig[0];
    let num_32nd_notes_per_beat = ~~(NOTE_LENGTH2.WHOLE / time_sig[1]);
    let num_32nd_notes = num_32nd_notes_per_beat * num_beats;
    return num_32nd_notes;
  }
  function getmeasureticks() {
    let num_32nd_notes = getmeasurelength();
    return length2tick(num_32nd_notes, resolution);
  }
  let measure_duration = getmeasureticks();
  let measure_length = getmeasurelength();
  function getlength(tick) {
    return ~~tick2length(tick, resolution);
  }
  function empty_measure() {
    return {
      time_signature: time_sig,
      key_signature: key_sig,
      duration: getlength(measure_duration),
      notes: [],
      cross_ties: []
    };
  }
  while (tick_table.duration > measure_duration * measures.length) {
    measures.push(empty_measure());
  }
  for (let i2 = 0; i2 < notes.length; i2++) {
    let note = notes[i2];
    let measure_id = ~~(note.begin / measure_duration);
    while (measure_id >= measures.length) {
      measures.push(empty_measure());
    }
    let begin = getlength(note.begin - measure_id * measure_duration);
    let [length, modifier] = classify_note_length(
      tick2length(note.duration, resolution)
    );
    let channel = note.channel;
    let pitch = note.pitch;
    let nnote = {
      begin,
      channel,
      pitch,
      duration: Math.min(length, measure_length - begin)
    };
    measures[measure_id].notes.push(nnote);
    let carry_cnt = 1;
    let left = nnote;
    while (begin + length > measure_length) {
      if (measure_id + carry_cnt >= measures.length) {
        measures.push(empty_measure());
      }
      let right = {
        begin: 0,
        duration: Math.min(measure_length, begin + length - measure_length),
        channel,
        pitch
      };
      measures[measure_id + carry_cnt].notes.push(right);
      measures[measure_id + carry_cnt - 1].cross_ties.push({ left, right });
      measures[measure_id + carry_cnt].cross_ties.push({ left, right });
      length = begin + length - measure_length;
      begin = 0;
      carry_cnt += 1;
      left = right;
    }
  }
  return measures;
}
function compile_staff(measure, staff_idx) {
  let staff = measure.staves[staff_idx];
  let [measure_acc, num_acc] = staff.key_signature;
  let acc_names = ORDER_OF_ACCIDENTALS[measure_acc].slice(0, num_acc).split("");
  let acc_history = {};
  function get_beat_length(time_sig) {
    let beat_length2 = ~~(NOTE_LENGTH2.WHOLE / time_sig[1]);
    if (time_sig[1] == 4 && time_sig[0] >= 4) {
      beat_length2 *= 2;
    }
    return beat_length2;
  }
  let beat_length = get_beat_length(staff.time_signature);
  let channels = get_existing_voices(
    staff.notes.concat(staff.rests),
    []
  );
  staff.voices = channels.length;
  function get_beat_idx(note) {
    return ~~(note.begin / beat_length);
  }
  function get_notes_in_beat(beat_idx) {
    let notes = [];
    for (let m of staff.notes) {
      if (get_beat_idx(m) == beat_idx) {
        notes.push(m);
      }
    }
    return notes;
  }
  function calc_stem_dir(note) {
    let beat_idx = get_beat_idx(note);
    let notes_in_beat = get_notes_in_beat(beat_idx);
    let avg_line = notes_in_beat.reduce(
      (acc, x) => acc + x.staff_pos,
      0
    ) / notes_in_beat.length;
    if (avg_line < 4) {
      return 1;
    } else {
      return -1;
    }
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let note_name = note.name;
    let note_oct = Number(note_name.split("_")[1]);
    let note_staff = note_name_to_staff_pos(note_name, staff.clef);
    note.octave = note_oct;
    note.staff_pos = note_staff;
    let modifier = has_modifier(note.duration);
    note.modifier = modifier;
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let accidental = null;
    let note = staff.notes[i2];
    let note_name = note.name;
    let note_bname = note_name[0];
    let note_acc = get_note_name_accidental(note_name);
    let key = note_bname + "_" + note.octave;
    if (acc_names.includes(note_bname)) {
      if (note_acc == measure_acc) {
        if (acc_history[key] === void 0 || acc_history[key] === note_acc) {
        } else {
          accidental = note_acc;
          acc_history[key] = note_acc;
        }
      } else {
        accidental = note_acc;
        acc_history[key] = note_acc;
      }
    } else {
      if (note_acc == ACCIDENTAL.NATURAL) {
        if (acc_history[key]) {
          accidental = note_acc;
          acc_history[key] = note_acc;
        }
      } else {
        if (acc_history[key] !== note_acc) {
          accidental = note_acc;
          acc_history[key] = note_acc;
        }
      }
    }
    note.accidental = accidental;
  }
  let channel_median_staff_pos = get_median_staff_pos(staff.notes);
  let channel_to_voice = {};
  let voice_median_staff_pos = {};
  let channels_sorted = Object.entries(channel_median_staff_pos).sort(
    (a, b) => a[1] - b[1]
  );
  for (let i2 = 0; i2 < channels_sorted.length; i2++) {
    channel_to_voice[channels_sorted[i2][0]] = i2;
    voice_median_staff_pos[i2] = channel_median_staff_pos[channels_sorted[i2][0]];
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    staff.notes[i2].voice = channel_to_voice[staff.notes[i2].voice] ?? 0;
  }
  for (let i2 = 0; i2 < staff.rests.length; i2++) {
    staff.rests[i2].voice = channel_to_voice[staff.rests[i2].voice] ?? 0;
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let stem_dir;
    if (staff.voices == 1) {
      stem_dir = calc_stem_dir(note);
    } else {
      stem_dir = note.voice % 2 ? 1 : -1;
    }
    note.stem_dir = stem_dir;
  }
  chord_and_beam_staff(staff, beat_length);
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    staff.notes[i2].duration *= NOTE_LENGTH_QUANT;
    staff.notes[i2].begin *= NOTE_LENGTH_QUANT;
  }
  for (let i2 = 0; i2 < staff.rests.length; i2++) {
    staff.rests[i2].duration *= NOTE_LENGTH_QUANT;
    staff.rests[i2].begin *= NOTE_LENGTH_QUANT;
  }
}
function get_channel_average_pitch(measures) {
  let c2p = {};
  for (let m of measures) {
    for (let n of m.notes) {
      if (!c2p[n.channel]) {
        c2p[n.channel] = [0, 0];
      }
      c2p[n.channel][0] += n.pitch;
      c2p[n.channel][1]++;
    }
  }
  let c2p2 = {};
  for (let k in c2p) {
    c2p2[k] = c2p[k][1] ? c2p[k][0] / c2p[k][1] : 0;
  }
  return c2p2;
}
function assign_clef_from_pitch(pitch) {
  if (pitch > NAME2PITCH["C_5"]) {
    return CLEF.TREBLE;
  } else {
    return CLEF.BASS;
  }
}
function score_from_midi(pattern) {
  let tick_tables = pattern_to_tick_tables(pattern);
  let measures_ = [];
  for (let i2 = 0; i2 < tick_tables.length; i2++) {
    let ms = tick_table_to_measures(tick_tables[i2]);
    for (let j = 0; j < ms.length; j++) {
      measures_.push(ms[j]);
    }
  }
  split_voices(measures_);
  let channel2pitch = get_channel_average_pitch(measures_);
  let channel2clef = {};
  for (let k in channel2pitch) {
    channel2clef[k] = assign_clef_from_pitch(channel2pitch[k]);
  }
  let channels = Object.keys(channel2pitch).map(Number).sort((a, b) => a - b);
  let channel_groups_ = {};
  for (let i2 = 0; i2 < channels.length; i2++) {
    let g = ~~(channels[i2] / 100);
    let g0 = channels[i2] - g * 100;
    let g1 = ~~(g0 / MAX_VOICES);
    let gg = g * 100 + g1;
    if (!channel_groups_[gg]) channel_groups_[gg] = [];
    channel_groups_[gg].push(channels[i2]);
  }
  let channel_groups = Object.values(channel_groups_);
  let score2 = {
    title: get_piece_title(pattern),
    instruments: [],
    //get_piece_instruments(pattern).map(x=>({names:[x],connect_barlines:[false],bracket:BRACKET.NONE})),
    composer: [],
    slurs: [],
    measures: [],
    crescs: []
  };
  for (let i2 = 0; i2 < measures_.length; i2++) {
    let ties = measures_[i2].cross_ties;
    for (let j = 0; j < ties.length; j++) {
      let slur = {
        left: ties[j].left.id ?? short_id(),
        right: ties[j].right.id ?? short_id(),
        is_tie: true
      };
      ties[j].left.id = slur.left;
      ties[j].right.id = slur.right;
      score2.slurs.push(slur);
    }
  }
  for (let i2 = 0; i2 < measures_.length; i2++) {
    let measure = {
      duration: measures_[i2].duration,
      barline: i2 == measures_.length ? BARLINE.END : BARLINE.SINGLE,
      staves: []
    };
    for (let j = 0; j < channel_groups.length; j++) {
      let ch_group = channel_groups[j];
      measure.staves.push({
        clef: channel2clef[ch_group[0]],
        time_signature: measures_[i2].time_signature,
        key_signature: measures_[i2].key_signature,
        notes: [],
        rests: [],
        grace: [],
        voices: null,
        beams: []
      });
      for (let k = 0; k < measures_[i2].notes.length; k++) {
        if (ch_group.includes(measures_[i2].notes[k].channel)) {
          let name = infer_name_from_pitch(
            measures_[i2].notes[k].pitch,
            measures_[i2].key_signature
          );
          let note = {
            begin: measures_[i2].notes[k].begin,
            duration: measures_[i2].notes[k].duration,
            accidental: null,
            modifier: null,
            octave: null,
            name,
            voice: measures_[i2].notes[k].channel,
            staff_pos: null,
            stem_dir: null,
            prev_in_chord: null,
            next_in_chord: null,
            tuplet: null
          };
          if (measures_[i2].notes[k].id) {
            note.id = measures_[i2].notes[k].id;
          }
          measure.staves[j].notes.push(note);
        }
      }
      measure.staves[j].rests.push(...find_rests(measure, j, ch_group));
      compile_staff(measure, j);
    }
    measure.duration *= 2;
    score2.measures.push(measure);
  }
  return score2;
}
function score_to_midi(score2) {
  let meta_track = { events: [] };
  let tracks = [];
  let tied_lefts = {};
  let tied_rights = {};
  for (let i2 = 0; i2 < score2.slurs.length; i2++) {
    if (score2.slurs[i2].is_tie) {
      tied_lefts[score2.slurs[i2].left] = true;
      tied_rights[score2.slurs[i2].right] = true;
    }
  }
  meta_track.events.push({
    type: "SEQUENCE_OR_TRACK_NAME",
    delta_time: 0,
    data: { text: score2.title.concat(score2.composer).join("\n") }
  });
  let instruments = [];
  for (let i2 = 0; i2 < score2.instruments.length; i2++) {
    instruments.push(...score2.instruments[i2].names);
  }
  for (let j = 0; j < score2.measures[0].staves.length; j++) {
    let T = 0;
    for (let i2 = 0; i2 < score2.measures.length; i2++) {
      if (!tracks[j]) {
        tracks[j] = { events: [] };
        if (instruments[j]) {
          tracks[j].events.push({
            type: "INSTRUMENT_NAME",
            delta_time: 0,
            data: { text: instruments[j] }
          });
        }
      }
      if (j == 0) {
        if (i2 == 0 || score2.measures[i2].staves[j].key_signature.toString() != score2.measures[i2 - 1].staves[j].key_signature.toString()) {
          let [acc, num_acc] = score2.measures[i2].staves[j].key_signature;
          meta_track.events.push({
            type: "KEY_SIGNATURE",
            delta_time: T,
            data: { num_sharps_or_flats: acc * num_acc, is_minor: 0 }
          });
        }
        if (i2 == 0 || score2.measures[i2].staves[j].time_signature.toString() != score2.measures[i2 - 1].staves[j].time_signature.toString()) {
          let [numerator, denominator] = score2.measures[i2].staves[j].time_signature;
          let denominator_exp = Math.log2(denominator);
          meta_track.events.push({
            type: "TIME_SIGNATURE",
            delta_time: T,
            data: {
              numerator,
              denominator_exp,
              clocks_per_metronome_click: 24,
              notated_32nd_per_quarter_note: 8
            }
          });
        }
      }
      for (let k = 0; k < score2.measures[i2].staves[j].notes.length; k++) {
        let note = score2.measures[i2].staves[j].notes[k];
        let t0 = note.begin;
        let d = note.duration;
        let v = 100;
        if (note.articulation == ARTICULATION.STACCATO) {
          d /= 2;
        }
        if (note.articulation == ARTICULATION.SPICCATO) {
          d /= 4;
        }
        if (note.articulation == ARTICULATION.ACCENT) {
          v = 125;
        }
        let t1 = t0 + d;
        if (note.prev_in_chord != null || note.next_in_chord != null) {
          let first = note;
          let last = note;
          let count_prev = 0;
          let count_next = 0;
          let is_arp = note.articulation == ARTICULATION.ARPEGGIATED;
          while (first.prev_in_chord != null) {
            first = score2.measures[i2].staves[j].notes[first.prev_in_chord];
            is_arp = is_arp || first.articulation == ARTICULATION.ARPEGGIATED;
            count_prev++;
          }
          while (last.next_in_chord != null) {
            last = score2.measures[i2].staves[j].notes[last.next_in_chord];
            is_arp = is_arp || last.articulation == ARTICULATION.ARPEGGIATED;
            count_next++;
          }
          if (is_arp) {
            let idx;
            if (first.staff_pos < last.staff_pos) {
              idx = count_next;
            } else {
              idx = count_prev;
            }
            t0 += Math.min(2, note.duration / (count_next + count_prev + 1)) * idx;
          }
        }
        if (score2.measures[i2].staves[j].grace[note.begin]) {
          t0 = Math.min(
            t1 - 1,
            Math.max(
              t0,
              note.begin + score2.measures[i2].staves[j].grace[note.begin].duration / 4
            )
          );
        }
        if (note.articulation != ARTICULATION.TRILL && note.articulation != ARTICULATION.TREMBLEMENT) {
          if (!tied_rights[note.id]) {
            tracks[j].events.push({
              type: "NOTE_ON",
              delta_time: T + t0,
              data: { key: NAME2PITCH[note.name], velocity: v, channel: 0 }
            });
          }
          if (!tied_lefts[note.id]) {
            tracks[j].events.push({
              type: "NOTE_OFF",
              delta_time: T + t1,
              data: { key: NAME2PITCH[note.name], velocity: 0, channel: 0 }
            });
          }
        } else {
          let above = String.fromCharCode(note.name[0].charCodeAt(0) + 1);
          if (above == "H") {
            above = "A" + note.name.slice(1);
          } else if (above == "C") {
            above += note.name.slice(1);
            above = above.split("_")[0] + "_" + (note.octave + 1);
          } else {
            above += note.name.slice(1);
          }
          let flip = false;
          for (let i3 = t0; i3 < t1; i3++) {
            tracks[j].events.push({
              type: "NOTE_ON",
              delta_time: T + i3,
              data: {
                key: NAME2PITCH[flip ? above : note.name],
                velocity: v,
                channel: 0
              }
            });
            tracks[j].events.push({
              type: "NOTE_OFF",
              delta_time: T + i3 + 1,
              data: {
                key: NAME2PITCH[flip ? above : note.name],
                velocity: 0,
                channel: 0
              }
            });
            flip = !flip;
          }
        }
      }
      for (let k = 0; k < score2.measures[i2].staves[j].grace.length; k++) {
        if (!score2.measures[i2].staves[j].grace[k]) continue;
        for (let l = 0; l < score2.measures[i2].staves[j].grace[k].staves[0].notes.length; l++) {
          let note = score2.measures[i2].staves[j].grace[k].staves[0].notes[l];
          tracks[j].events.push({
            type: "NOTE_ON",
            delta_time: T + k + note.begin / 4,
            data: { key: NAME2PITCH[note.name], velocity: 100, channel: 0 }
          });
          tracks[j].events.push({
            type: "NOTE_OFF",
            delta_time: T + k + (note.begin + note.duration) / 4,
            data: { key: NAME2PITCH[note.name], velocity: 0, channel: 0 }
          });
        }
      }
      T += score2.measures[i2].duration;
    }
  }
  tracks.unshift(meta_track);
  for (let j = 0; j < tracks.length; j++) {
    tracks[j].events.sort((a, b) => a.delta_time - b.delta_time);
    for (let k = tracks[j].events.length - 1; k > 0; k--) {
      tracks[j].events[k].delta_time -= tracks[j].events[k - 1].delta_time;
    }
  }
  for (let j = 0; j < tracks.length; j++) {
    for (let k = 0; k < tracks[j].events.length; k++) {
      tracks[j].events[k].delta_time = ~~(tracks[j].events[k].delta_time * 6);
    }
    tracks[j].events.push({ type: "END_OF_TRACK", delta_time: 0, data: {} });
  }
  let pattern = {
    magic: "MThd",
    tracks,
    num_tracks: tracks.length,
    format: 1,
    time_format: "METRIC",
    ticks_per_quarter_note: 96
  };
  return pattern;
}

// src/midifmt.ts
var META_EVENT = {
  0: ["SEQUENCE_NUMBER", "value"],
  1: ["TEXT_EVENT", "text"],
  2: ["COPYRIGHT_NOTICE", "text"],
  3: ["SEQUENCE_OR_TRACK_NAME", "text"],
  4: ["INSTRUMENT_NAME", "text"],
  5: ["LYRIC", "text"],
  6: ["MARKER", "text"],
  7: ["CUE_POINT", "text"],
  32: ["CHANNEL_PREFIX", "value"],
  33: ["PORT", "value"],
  47: ["END_OF_TRACK"],
  84: ["SMPTE_OFFSET", "hour", "min", "sec", "frame", "frac_frame"],
  81: ["SET_TEMPO", "data"],
  88: [
    "TIME_SIGNATURE",
    "numerator",
    "denominator_exp",
    "clocks_per_metronome_click",
    "notated_32nd_per_quarter_note"
  ],
  89: ["KEY_SIGNATURE", "num_sharps_or_flats", "is_minor"],
  127: ["SEQUENCER_SPECIFIC_EVENT", "data"]
};
var MIDI_EVENT = {
  8: ["NOTE_OFF", "key", "velocity"],
  9: ["NOTE_ON", "key", "velocity"],
  10: ["POLYPHONIC_KEY_PRESSURE", "key", "pressure"],
  11: ["CONTROL_CHANGE", "controller", "value"],
  12: ["PROGRAM_CHANGE", "value"],
  13: ["CHANNEL_PRESSURE", "value"],
  14: ["PITCH_WHEEL_CHANGE", "lsb", "msb"]
};
var SYSTEM_EVENT = {
  2: ["SONG_POSITION_POINTER", "lsb", "msb"],
  3: ["SONG_SELECT", "value"],
  6: ["TUNE_REQUEST"],
  7: ["END_OF_EXCLUSIVE"],
  8: ["TIMING_CLOCK"],
  10: ["START"],
  11: ["CONTINUE"],
  12: ["STOP"],
  14: ["ACTIVE_SENSING"],
  15: ["RESET"]
};
var META_EVENT_LOOKUP = Object.fromEntries(
  Object.entries(META_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]])
);
var MIDI_EVENT_LOOKUP = Object.fromEntries(
  Object.entries(MIDI_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]])
);
var SYSTEM_EVENT_LOOKUP = Object.fromEntries(
  Object.entries(SYSTEM_EVENT).map((x) => [x[1][0], [x[0], ...x[1].slice(1)]])
);
function parse_midi(bytes) {
  let ptr = 0;
  function read_str(n) {
    let s = String.fromCharCode(...bytes.slice(ptr, ptr + n));
    ptr += n;
    return s;
  }
  function read_u8() {
    return bytes[ptr++];
  }
  function read_u32() {
    let s = (bytes[ptr] << 24 | bytes[ptr + 1] << 16 | bytes[ptr + 2] << 8 | bytes[ptr + 3]) >>> 0;
    ptr += 4;
    return s;
  }
  function read_u16() {
    let s = bytes[ptr] << 8 | bytes[ptr + 1];
    ptr += 2;
    return s;
  }
  function read_u(n_bytes) {
    let s = 0;
    for (let i2 = 0; i2 < n_bytes; i2++) {
      s = (s << 8 | bytes[ptr]) >>> 0;
      ptr++;
    }
    return s;
  }
  function read_vlen() {
    let is_last = false;
    let s = 0;
    do {
      let n = bytes[ptr] & 127;
      s = (s << 7 | n) >>> 0;
      is_last = !(bytes[ptr] >> 7 & 1);
      ptr++;
    } while (!is_last);
    return s;
  }
  let magic = read_str(4);
  let hd_len = read_u32();
  let hd_fmt = read_u16();
  let hd_ntk = read_u16();
  let div_fmt = bytes[ptr] >> 7 & 1;
  let ot = {};
  if (div_fmt) {
    let x = read_u16() & 32767;
    ot.negative_SMPTE_format = -((~(x >> 8) & 127) + 1);
    ot.ticks_per_frame = x & 255;
  } else {
    ot.ticks_per_quarter_note = read_u16() & 32767;
  }
  let o = {
    magic,
    num_tracks: hd_ntk,
    format: hd_fmt,
    time_format: div_fmt ? "TIME_CODE" : "METRIC",
    ...ot,
    tracks: []
  };
  while (read_str(4) == "MTrk") {
    let track_len = read_u32();
    let p0 = ptr;
    let trk = { events: [] };
    while (ptr < p0 + track_len) {
      let dt = read_vlen();
      let e = { type: "UNDEFINED", delta_time: dt, data: {} };
      if (bytes[ptr] == 255) {
        let tmpl = META_EVENT[bytes[++ptr]] ?? ["UNDEFINED"];
        ptr++;
        let len = read_vlen();
        e.type = tmpl[0];
        let chunk = ~~(len / (tmpl.length - 1));
        for (let i2 = 1; i2 < tmpl.length; i2++) {
          if (tmpl[i2] == "text") {
            e.data["text"] = read_str(chunk);
          } else if (tmpl[i2] == "data") {
            e.data = bytes.slice(ptr, ptr + chunk);
            ptr += chunk;
          } else {
            e.data[tmpl[i2]] = read_u(chunk);
            if (tmpl[i2] == "num_sharps_or_flats") {
              let x = e.data[tmpl[i2]];
              if (x > 127) {
                x = -((~x & 255) + 1);
              }
              e.data[tmpl[i2]] = x;
            }
          }
        }
      } else if (bytes[ptr] == 240 || bytes[ptr] == 247) {
        e.type = "SYSEX";
        e.data = [];
        do {
          e.data.push(bytes[ptr++]);
        } while (bytes[ptr] != 240 && bytes[ptr] != 247);
        e.data.push(bytes[ptr++]);
      } else {
        let type = bytes[ptr] >> 4 & 15;
        let chan = bytes[ptr] & 15;
        ptr++;
        let tmpl = ["UNDEFINED"];
        if (type == 15) {
          tmpl = SYSTEM_EVENT[chan] ?? tmpl;
        } else {
          tmpl = MIDI_EVENT[type] ?? tmpl;
        }
        if (tmpl[0] == "UNDEFINED" && trk.events.length) {
          ptr--;
          chan = trk.events[trk.events.length - 1].data["channel"];
          tmpl = Object.values(MIDI_EVENT).find(
            (x) => x[0] == trk.events[trk.events.length - 1].type
          );
        }
        e.type = tmpl[0];
        for (let i2 = 1; i2 < tmpl.length; i2++) {
          e.data[tmpl[i2]] = read_u8();
        }
        e.data["channel"] = chan;
      }
      trk.events.push(e);
    }
    o.tracks.push(trk);
  }
  return o;
}
function export_midi(pattern) {
  let bytes = [];
  function write_str(s) {
    for (let i2 = 0; i2 < s.length; i2++) {
      bytes.push(s.charCodeAt(i2));
    }
  }
  function write_u8(n) {
    return bytes.push(n);
  }
  function write_u32(n) {
    bytes.push(n >> 24 & 255);
    bytes.push(n >> 16 & 255);
    bytes.push(n >> 8 & 255);
    bytes.push(n & 255);
  }
  function write_u16(n) {
    bytes.push(n >> 8 & 255);
    bytes.push(n & 255);
  }
  function write_u(n, n_bytes) {
    for (let i2 = 0; i2 < n_bytes; i2++) {
      bytes.push(n >> (n_bytes - i2 - 1 << 3) & 255);
    }
  }
  function write_vlen(n) {
    let b = [];
    while (n > 0) {
      b.push(n & 127);
      n = n >>> 7;
    }
    if (!b.length) b.push(0);
    b.reverse();
    for (let i2 = 0; i2 < b.length - 1; i2++) {
      b[i2] |= 128;
    }
    bytes.push(...b);
  }
  write_str(pattern.magic);
  write_u32(6);
  write_u16(1);
  write_u16(pattern.num_tracks);
  if (pattern.time_format == "METRIC") {
    write_u16(pattern.ticks_per_quarter_note);
  } else {
    write_u16(
      pattern.ticks_per_frame | ~(-pattern.negative_SMPTE_format - 1) << 8
    );
  }
  for (let i2 = 0; i2 < pattern.tracks.length; i2++) {
    write_str("MTrk");
    let len_pos = bytes.length;
    bytes.push(0, 0, 0, 0);
    for (let j = 0; j < pattern.tracks[i2].events.length; j++) {
      let e = pattern.tracks[i2].events[j];
      write_vlen(e.delta_time);
      if (META_EVENT_LOOKUP[e.type]) {
        let k = META_EVENT_LOOKUP[e.type][0];
        write_u8(255);
        write_u8(Number(k));
        if (META_EVENT[k][1] == "text") {
          write_vlen(e.data["text"].length);
          write_str(e.data["text"]);
        } else if (META_EVENT[k][1] == "value") {
          if (e.type == "SEQUENCE_NUMBER") {
            write_u8(2);
            write_u16(e.data["value"]);
          } else {
            write_u8(1);
            write_u8(e.data["value"]);
          }
        } else if (META_EVENT[k][1] == "data") {
          write_vlen(e.data.length);
          bytes.push(...e.data);
        } else {
          write_vlen(META_EVENT[k].length - 1);
          for (let j2 = 1; j2 < META_EVENT[k].length; j2++) {
            let x = e.data[META_EVENT[k][j2]];
            if (META_EVENT[k][j2] == "num_sharps_or_flats" && x < 0) {
              x = (~-x & 255) + 1;
            }
            bytes.push(x);
          }
        }
      } else if (MIDI_EVENT_LOOKUP[e.type]) {
        let k = Number(MIDI_EVENT_LOOKUP[e.type][0]);
        bytes.push(k << 4 | e.data["channel"]);
        for (let j2 = 1; j2 < MIDI_EVENT[k].length; j2++) {
          write_u8(e.data[MIDI_EVENT[k][j2]]);
        }
      } else if (SYSTEM_EVENT_LOOKUP[e.type]) {
        let k = Number(SYSTEM_EVENT_LOOKUP[e.type][0]);
        bytes.push(15 << 4 | k);
        for (let j2 = 1; j2 < SYSTEM_EVENT[k].length; j2++) {
          write_u8(e.data[SYSTEM_EVENT[k][j2]]);
        }
      } else {
        for (let j2 = 1; j2 < e.data.length; j2++) {
          write_u8(e.data[j2]);
        }
      }
    }
    let n = bytes.length - len_pos - 4;
    bytes[len_pos] = n >> 24 & 255;
    bytes[len_pos + 1] = n >> 16 & 255;
    bytes[len_pos + 2] = n >> 8 & 255;
    bytes[len_pos + 3] = n & 255;
  }
  return bytes;
}

// src/txtfmt.ts
var ARTICULATION_SYMBOL_LOOKUP = {
  ">": ARTICULATION.ACCENT,
  "^": ARTICULATION.MARCATO,
  ".": ARTICULATION.STACCATO,
  "-": ARTICULATION.TENUTO,
  ",": ARTICULATION.SPICCATO,
  "?": ARTICULATION.FERMATA,
  "+": ARTICULATION.TREMBLEMENT,
  t: ARTICULATION.TRILL,
  o: ARTICULATION.FLAGEOLET,
  m: ARTICULATION.MORDENT,
  s: ARTICULATION.TURN,
  v: ARTICULATION.UP_BOW,
  "{": ARTICULATION.ARPEGGIATED
};
var ARTICULATION_SYMBOL = Object.fromEntries(
  Object.entries(ARTICULATION_SYMBOL_LOOKUP).map((x) => [x[1], x[0]])
);
function parse_txt(txt) {
  txt = txt.replace(/[\n\r\t]/g, " ");
  let swap_sp = "\uFFFF";
  let swap_sp_re = new RegExp(swap_sp, "g");
  let swap_qt = "\uFFFE";
  let swap_qt_re = new RegExp(swap_qt, "g");
  txt = txt.replace(/\\'/g, swap_qt);
  txt = txt.split("'").map((x, i3) => i3 % 2 ? x.replace(/ /g, swap_sp) : x).join("'");
  txt = txt.split(";").filter((_, i3) => !(i3 % 2)).join(" ");
  let words = txt.split(" ").filter((x) => x.length).map((x) => x.replace(swap_sp_re, " ").replace(swap_qt_re, "'"));
  let score2 = {
    title: [],
    instruments: [],
    composer: [],
    slurs: [],
    measures: [],
    crescs: []
  };
  let measure;
  let staff;
  let note;
  let rest;
  let slur;
  let cresc;
  let i2 = 0;
  let state = [];
  let begin = 0;
  let voice = 0;
  let begin0 = 0;
  let rest_hidden = false;
  let tup_state = [];
  function curr_state(s) {
    return state[state.length - 1] == s;
  }
  function pop_short_state() {
    let curr = state[state.length - 1];
    if (curr) {
      if (curr == "note") {
        state.pop();
        if (note.tuplet && note.tuplet.display_duration === null) {
          note.tuplet.display_duration = note.duration;
          note.duration = Math.max(
            1,
            ~~(note.duration * tup_state[tup_state.length - 1].mul)
          );
        }
        if (note.tuplet) tup_state[tup_state.length - 1].members.push(note);
        if (curr_state("grace") || state.includes("grace")) {
          if (!staff.grace[begin0]) {
            staff.grace[begin0] = {
              duration: 0,
              barline: BARLINE.NONE,
              staves: [
                {
                  clef: staff.clef,
                  time_signature: [1, 1],
                  key_signature: staff.key_signature,
                  notes: [],
                  grace: [],
                  rests: [],
                  voices: 1,
                  beams: []
                }
              ]
            };
          }
          staff.grace[begin0].staves[0].notes.push(note);
        } else {
          staff.notes.push(note);
        }
        measure.duration = Math.max(measure.duration, begin + note.duration);
        if (!curr_state("chord")) {
          begin += note.duration;
        }
      } else if (curr == "rest") {
        state.pop();
        if (rest.tuplet && rest.tuplet.display_duration === null) {
          rest.tuplet.display_duration = rest.duration;
          rest.duration = Math.max(
            1,
            ~~(rest.duration * tup_state[tup_state.length - 1].mul)
          );
        }
        if (rest.tuplet && !rest_hidden)
          tup_state[tup_state.length - 1].members.push(rest);
        measure.duration = Math.max(measure.duration, begin + rest.duration);
        begin += rest.duration;
        if (!rest_hidden) staff.rests.push(rest);
      } else if (curr == "title" || curr == "composer" || curr == "instruments" || curr == "tempo") {
        state.pop();
      } else if (curr == "slur") {
        state.pop();
        score2.slurs.push(slur);
      } else if (curr == "cresc") {
        state.pop();
        score2.crescs.push(cresc);
      }
    }
  }
  function switch_state(s) {
    pop_short_state();
    state.push(s);
  }
  function parse_dur(x) {
    if (x[x.length - 1] == ".") {
      return [96 / Number(x.slice(0, -1)), true];
    } else {
      return [64 / Number(x), false];
    }
  }
  while (i2 < words.length) {
    let x = words[i2];
    if (x == "end") {
      pop_short_state();
      if (curr_state("staff")) {
        compile_staff2(staff);
        measure.staves.push(staff);
      } else if (curr_state("measure")) {
        score2.measures.push(measure);
      } else if (curr_state("chord")) {
        if (state.includes("grace")) {
          begin += staff.grace[begin0].staves[0].notes[staff.grace[begin0].staves[0].notes.length - 1].duration;
        } else {
          begin += staff.notes[staff.notes.length - 1].duration;
        }
      } else if (curr_state("voice")) {
        voice++;
        begin = 0;
      } else if (curr_state("grace")) {
        staff.grace[begin0].duration = Math.max(
          staff.grace[begin0].duration,
          begin
        );
        compile_staff2(staff.grace[begin0].staves[0], -1);
        begin = begin0;
      } else if (curr_state("tuplet")) {
        let tup = tup_state.pop();
        let sum = tup.members[tup.members.length - 1].begin - tup.begin + tup.members[tup.members.length - 1].duration;
        let remain = tup.dur - sum;
        for (let i3 = tup.members.length - 1; i3 >= 0; i3--) {
          if (tup.members[i3].begin == tup.members[tup.members.length - 1].begin) {
            tup.members[i3].duration += remain;
          } else {
            break;
          }
        }
        begin = tup.begin + tup.dur;
      }
      state.pop();
    } else if (x == "title") {
      switch_state("title");
    } else if (x == "composer") {
      switch_state("composer");
    } else if (x == "instruments") {
      switch_state("instruments");
    } else if (x == "tempo") {
      switch_state("tempo");
    } else if (x == "measure") {
      switch_state("measure");
      measure = {
        duration: 0,
        barline: BARLINE.SINGLE,
        staves: []
      };
    } else if (x == "staff") {
      switch_state("staff");
      staff = {
        clef: CLEF.TREBLE,
        time_signature: [4, 4],
        key_signature: [0, 0],
        notes: [],
        grace: [],
        rests: [],
        voices: 1,
        beams: []
      };
      if (score2.measures[score2.measures.length - 1]) {
        if (score2.measures[score2.measures.length - 1].staves[measure.staves.length]) {
          let prev = score2.measures[score2.measures.length - 1].staves[measure.staves.length];
          staff.time_signature[0] = prev.time_signature[0];
          staff.time_signature[1] = prev.time_signature[1];
          staff.key_signature[0] = prev.key_signature[0];
          staff.key_signature[1] = prev.key_signature[1];
          staff.clef = prev.clef;
        }
      }
      begin = 0;
      voice = 0;
    } else if (x == "note") {
      switch_state("note");
      note = {
        begin: null,
        duration: null,
        accidental: null,
        modifier: false,
        octave: null,
        name: null,
        voice: null,
        staff_pos: null,
        stem_dir: null,
        prev_in_chord: null,
        next_in_chord: null,
        tuplet: null
      };
      if (state[state.length - 2] == "grace" && staff.grace[begin0] && staff.grace[begin0].staves[0].notes.length) {
        let notes = staff.grace[begin0].staves[0].notes;
        if (notes[notes.length - 1]) {
          Object.assign(note, notes[notes.length - 1]);
        }
      } else {
        if (staff.notes[staff.notes.length - 1]) {
          Object.assign(note, staff.notes[staff.notes.length - 1]);
        }
      }
      note.begin = begin;
      note.accidental = null;
      note.voice = voice;
      if (note.id) {
        delete note.id;
      }
      if (note.lyric) {
        delete note.lyric;
      }
      if (note.articulation) {
        delete note.articulation;
      }
      if (note.cue) {
        delete note.cue;
      }
      if (state[state.length - 2] != "grace") {
        let tup = tup_state[tup_state.length - 1];
        if (note.tuplet && tup) {
          if (note.tuplet.id != tup.id) {
            note.tuplet = {
              id: tup.id,
              display_duration: null,
              label: tup.num
            };
          }
        } else if (tup && !note.tuplet) {
          note.tuplet = { id: tup.id, display_duration: null, label: tup.num };
        } else if (!tup && note.tuplet) {
          note.tuplet = null;
        }
      } else {
        note.tuplet = null;
      }
    } else if (x == "rest") {
      switch_state("rest");
      rest = {
        begin: null,
        duration: null,
        voice: null,
        tuplet: null
      };
      rest_hidden = false;
      if (staff.rests[staff.rests.length - 1]) {
        Object.assign(rest, staff.rests[staff.rests.length - 1]);
      }
      rest.begin = begin;
      rest.voice = voice;
      if (rest.cue) {
        delete rest.cue;
      }
      if (state[state.length - 2] != "grace") {
        let tup = tup_state[tup_state.length - 1];
        if (rest.tuplet && tup) {
          if (rest.tuplet.id != tup.id) {
            rest.tuplet = {
              id: tup.id,
              display_duration: null,
              label: tup.num
            };
          }
        } else if (tup && !rest.tuplet) {
          rest.tuplet = { id: tup.id, display_duration: null, label: tup.num };
        } else if (!tup && rest.tuplet) {
          rest.tuplet = null;
        }
      } else {
        rest.tuplet = null;
      }
    } else if (x == "chord") {
      switch_state("chord");
    } else if (x == "grace") {
      switch_state("grace");
      begin0 = begin;
      begin = 0;
    } else if (x == "tuplet") {
      switch_state("tuplet");
      tup_state.push({
        id: short_id(),
        mul: 1,
        begin,
        dur: 0,
        num: 3,
        members: []
      });
    } else if (x == "voice") {
      switch_state("voice");
    } else if (x == "slur") {
      switch_state("slur");
      slur = {
        left: null,
        right: null,
        is_tie: false
      };
    } else if (x == "tie") {
      switch_state("slur");
      slur = {
        left: null,
        right: null,
        is_tie: true
      };
    } else if (x == "cresc") {
      switch_state("cresc");
      cresc = {
        left: null,
        right: null,
        val_left: null,
        val_right: null
      };
    } else if (curr_state("measure")) {
      if (x.startsWith("|") || x.startsWith(":")) {
        if (x == "|") {
          measure.barline = BARLINE.SINGLE;
        } else if (x == "||") {
          measure.barline = BARLINE.DOUBLE;
        } else if (x == "|||") {
          measure.barline = BARLINE.END;
        } else if (x == "|:") {
          measure.barline = BARLINE.REPEAT_BEGIN;
        } else if (x == ":|") {
          measure.barline = BARLINE.REPEAT_END;
        } else if (x == ":|:") {
          measure.barline = BARLINE.REPEAT_END_BEGIN;
        }
      }
    } else if (curr_state("staff")) {
      if (x == "G") {
        staff.clef = CLEF.TREBLE;
      } else if (x == "F") {
        staff.clef = CLEF.BASS;
      } else if (x == "Ca" || x == "C") {
        staff.clef = CLEF.ALTO;
      } else if (x == "Ct") {
        staff.clef = CLEF.TENOR;
      } else if (x == "Cm") {
        staff.clef = CLEF.MEZZO_SOPRANO;
      } else if (x == "Cs") {
        staff.clef = CLEF.SOPRANO;
      } else if (x == "Cb") {
        staff.clef = CLEF.BARITONE;
      } else if (x == "~") {
        staff.key_signature = [0, 0];
      } else if (x.startsWith("b")) {
        staff.key_signature = [ACCIDENTAL.FLAT, x.length];
      } else if (x.startsWith("#")) {
        staff.key_signature = [ACCIDENTAL.SHARP, x.length];
      } else if (x.includes("/")) {
        let s = x.split("/");
        staff.time_signature = [Number(s[0]), Number(s[1])];
      }
    } else if (curr_state("note")) {
      if (/^[A-Z].*/.test(x)) {
        note.name = x[0];
        note.octave = Number(x.slice(1));
      } else if (x[0] == "d") {
        let [dur, mod] = parse_dur(x.slice(1));
        note.duration = dur;
        note.modifier = mod;
        if (note.tuplet) note.tuplet.display_duration = null;
      } else if (x[0] == "$") {
        note.id = x.slice(1);
      } else if (x[0] == "#") {
        note.accidental = ACCIDENTAL.SHARP;
      } else if (x[0] == "b") {
        note.accidental = ACCIDENTAL.FLAT;
      } else if (x[0] == "~") {
        note.accidental = ACCIDENTAL.NATURAL;
      } else if (x[0] == "l") {
        note.lyric = x.slice(1).replace(/(^')|('$)/g, "");
      } else if (x[0] == "a") {
        if (ARTICULATION_SYMBOL_LOOKUP[x[1]]) {
          note.articulation = ARTICULATION_SYMBOL_LOOKUP[x[1]];
        } else {
          note.articulation = Number(x[1]);
        }
        if (x[2] == "|") {
          note.articulation = -note.articulation;
        }
      } else if (x[0] == "|") {
        note.cue = { position: 0, data: x.slice(1).replace(/(^')|('$)/g, "") };
      } else if (x[0] == "[") {
        note.cue = { position: -1, data: x.slice(1).replace(/(^')|('$)/g, "") };
      } else if (x[0] == "]") {
        note.cue = { position: 1, data: x.slice(1).replace(/(^')|('$)/g, "") };
      }
    } else if (curr_state("rest")) {
      if (x[0] == "d") {
        let dur = 64 / Number(x.slice(1));
        rest.duration = dur;
        if (rest.tuplet) rest.tuplet.display_duration = null;
      } else if (x[0] == "|") {
        rest.cue = { position: 0, data: x.slice(1).replace(/(^')|('$)/g, "") };
      } else if (x[0] == "[") {
        rest.cue = { position: -1, data: x.slice(1).replace(/(^')|('$)/g, "") };
      } else if (x[0] == "]") {
        rest.cue = { position: 1, data: x.slice(1).replace(/(^')|('$)/g, "") };
      } else if (x[0] == "-") {
        rest_hidden = true;
      }
    } else if (curr_state("slur")) {
      if (x[0] == "$") {
        if (slur.left == null) {
          slur.left = x.slice(1);
        } else {
          slur.right = x.slice(1);
        }
      }
    } else if (curr_state("cresc")) {
      if (x[0] == "$") {
        if (cresc.left == null) {
          cresc.left = x.slice(1);
        } else {
          cresc.right = x.slice(1);
        }
      } else {
        if (cresc.val_left === null) {
          cresc.val_left = Number(x);
        } else {
          cresc.val_right = Number(x);
        }
      }
    } else if (curr_state("tuplet")) {
      if (x[0] == "d") {
        let [a_, b_] = x.slice(1).split("/");
        let a = parse_dur(a_)[0];
        let b = parse_dur(b_)[0];
        tup_state[tup_state.length - 1].mul = a / b;
        tup_state[tup_state.length - 1].dur = a;
      } else {
        let n = Number(x);
        tup_state[tup_state.length - 1].num = n;
      }
    } else if (curr_state("title")) {
      score2.title.push(x.replace(/(^')|('$)/g, ""));
    } else if (curr_state("composer")) {
      score2.composer.push(x.replace(/(^')|('$)/g, ""));
    } else if (curr_state("instruments")) {
      if (x == "{") {
        while (score2.instruments[score2.instruments.length - 1] && score2.instruments[score2.instruments.length - 1].connect_barlines.length < score2.instruments[score2.instruments.length - 1].names.length)
          score2.instruments[score2.instruments.length - 1].connect_barlines.push(
            false
          );
        score2.instruments.push({
          bracket: BRACKET.BRACE,
          names: [],
          connect_barlines: []
        });
      } else if (x == "[") {
        while (score2.instruments[score2.instruments.length - 1] && score2.instruments[score2.instruments.length - 1].connect_barlines.length < score2.instruments[score2.instruments.length - 1].names.length)
          score2.instruments[score2.instruments.length - 1].connect_barlines.push(
            false
          );
        score2.instruments.push({
          bracket: BRACKET.BRACKET,
          names: [],
          connect_barlines: []
        });
      } else if (x == "|") {
        while (score2.instruments[score2.instruments.length - 1] && score2.instruments[score2.instruments.length - 1].connect_barlines.length < score2.instruments[score2.instruments.length - 1].names.length)
          score2.instruments[score2.instruments.length - 1].connect_barlines.push(
            false
          );
        score2.instruments.push({
          bracket: BRACKET.NONE,
          names: [],
          connect_barlines: []
        });
      } else if (x == "-") {
        score2.instruments[score2.instruments.length - 1].connect_barlines.push(
          true
        );
      } else {
        if (!score2.instruments.length) {
          score2.instruments.push({
            bracket: BRACKET.NONE,
            names: [],
            connect_barlines: []
          });
        }
        let group = score2.instruments[score2.instruments.length - 1];
        if (group.connect_barlines.length < group.names.length) {
          group.connect_barlines.push(false);
        }
        group.names.push(x.replace(/(^')|('$)/g, ""));
      }
    } else if (curr_state("tempo")) {
      if (!score2.tempo) {
        score2.tempo = {};
      }
      if (x[0] == "d") {
        let [dur, mod] = parse_dur(x.slice(1));
        score2.tempo.duration = dur;
        score2.tempo.modifier = mod;
      } else if (x[0] == "=") {
        score2.tempo.bpm = Number(x.slice(1));
      } else {
        score2.tempo.text = x.replace(/(^')|('$)/g, "");
      }
    }
    i2++;
  }
  pop_short_state();
  return score2;
}
function compile_staff2(staff, force_stem_dir = 0) {
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    staff.voices = Math.max(staff.notes[i2].voice + 1, staff.voices);
  }
  for (let i2 = 0; i2 < staff.rests.length; i2++) {
    staff.voices = Math.max(staff.rests[i2].voice + 1, staff.voices);
  }
  function get_beat_length(time_sig) {
    if (CONFIG.BEAM_POLICY == 0) {
      return 1;
    } else if (CONFIG.BEAM_POLICY == 1) {
      return ~~(NOTE_LENGTH.WHOLE / time_sig[1]);
    } else {
      let beat_length2 = ~~(NOTE_LENGTH.WHOLE / time_sig[1]);
      beat_length2 *= time_sig[0] % 2 || time_sig[0] <= 2 && time_sig[1] > 2 ? time_sig[0] : time_sig[0] / 2;
      return beat_length2;
    }
  }
  let beat_length = get_beat_length(staff.time_signature);
  function get_beat_idx(note) {
    return ~~(note.begin / beat_length);
  }
  function get_notes_in_beat(beat_idx) {
    let notes = [];
    for (let m of staff.notes) {
      if (get_beat_idx(m) == beat_idx) {
        notes.push(m);
      }
    }
    return notes;
  }
  function calc_stem_dir(note) {
    let notes_in_beat;
    if (note.duration < NOTE_LENGTH.QUARTER) {
      let beat_idx = get_beat_idx(note);
      if (note.tuplet) {
        notes_in_beat = staff.notes.filter(
          (x) => x.tuplet && x.tuplet.id == note.tuplet.id
        );
      } else {
        notes_in_beat = get_notes_in_beat(beat_idx).filter(
          (x) => x.duration < NOTE_LENGTH.QUARTER
        );
      }
    } else {
      notes_in_beat = [];
      for (let m of staff.notes) {
        if (m.begin == note.begin) {
          notes_in_beat.push(m);
        }
      }
    }
    let avg_line = notes_in_beat.reduce(
      (acc, x) => acc + x.staff_pos,
      0
    ) / notes_in_beat.length;
    if (avg_line < 4) {
      return 1;
    } else {
      return -1;
    }
  }
  let [measure_acc, num_acc] = staff.key_signature;
  let acc_names = ORDER_OF_ACCIDENTALS[measure_acc].slice(0, num_acc).split("");
  let acc_history = {};
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let note_bname = note.name;
    let key = note_bname + "_" + note.octave;
    if (note.accidental != null) {
      note.name = note_bname + ["b", "", "s"][note.accidental + 1];
      acc_history[key] = note.accidental;
    } else {
      if (acc_history[key] === void 0) {
        if (acc_names.includes(note_bname)) {
          note.name = note_bname + ["b", null, "s"][measure_acc + 1];
          acc_history[key] = measure_acc;
        } else {
          note.name = note_bname;
        }
      } else {
        note.name = note_bname + ["b", "", "s"][acc_history[key] + 1];
      }
    }
    note.name += "_";
    note.name += note.octave;
    note.staff_pos = note_name_to_staff_pos(note.name, staff.clef);
  }
  for (let i2 = 0; i2 < staff.notes.length; i2++) {
    let note = staff.notes[i2];
    let stem_dir;
    if (staff.voices == 1) {
      stem_dir = force_stem_dir || calc_stem_dir(note);
    } else {
      stem_dir = note.voice % 2 ? 1 : -1;
    }
    note.stem_dir = stem_dir;
  }
  chord_and_beam_staff(staff, beat_length);
}
function export_txt(score2) {
  let o = "";
  o += `title '${score2.title.map((x) => x.replace(/'/g, "\\'")).join("' '")}'
`;
  if (score2.composer) {
    o += `composer '${score2.composer}'
`;
  }
  if (score2.tempo) {
    o += `tempo`;
    if (score2.tempo.text) {
      o += ` '` + score2.tempo.text.replace(/'/g, "\\'") + `'`;
    }
    if (score2.tempo.duration) {
      if (score2.tempo.modifier) {
        o += " d" + (96 / score2.tempo.duration).toString() + ".";
      } else {
        o += " d" + (64 / score2.tempo.duration).toString();
      }
      if (score2.tempo.bpm) {
        o += " =" + score2.tempo.bpm;
      }
    }
    o += "\n";
  }
  if (score2.instruments.length) {
    o += "instruments ";
    for (let i2 = 0; i2 < score2.instruments.length; i2++) {
      o += ["", "{", "["][score2.instruments[i2].bracket] + " ";
      for (let j = 0; j < score2.instruments[i2].names.length; j++) {
        if (j && score2.instruments[i2].connect_barlines[j - 1]) {
          o += " - ";
        }
        o += `'${score2.instruments[i2].names[j].replace(/'/g, "\\'")}' `;
      }
    }
    o += "\n";
  }
  for (let i2 = 0; i2 < score2.measures.length; i2++) {
    let measure = score2.measures[i2];
    o += `measure`;
    if (measure.barline == BARLINE.DOUBLE) {
      o += ` ||`;
    } else if (measure.barline == BARLINE.REPEAT_BEGIN) {
      o += ` |:`;
    } else if (measure.barline == BARLINE.REPEAT_END) {
      o += ` :|`;
    } else if (measure.barline == BARLINE.END) {
      o += ` |||`;
    } else if (measure.barline == BARLINE.REPEAT_END_BEGIN) {
      o += ` :|:`;
    }
    o += `
`;
    for (let j = 0; j < measure.staves.length; j++) {
      let staff = measure.staves[j];
      o += `  staff ${staff.clef == CLEF.TREBLE ? "G" : "F"} ${["b", "", "#"][staff.key_signature[0] + 1].repeat(staff.key_signature[1])} ${staff.time_signature[0]}/${staff.time_signature[1]}
`;
      for (let k = 0; k < staff.voices; k++) {
        let do_items = function(items2) {
          for (let l = 0; l < items2.length; l++) {
            let done = items2[l][2];
            if (done) {
              continue;
            }
            if (items2[l][1].tuplet) {
              let count = function() {
                let begin = -1;
                let real = 0;
                let disp = 0;
                for (let m = l; m < items2.length; m++) {
                  if (!items2[m][1].tuplet || items2[m][1].tuplet.id != items2[l][1].tuplet.id) {
                    break;
                  }
                  if (items2[m][1].begin != begin) {
                    begin = items2[m][1].begin;
                    disp += items2[m][1].tuplet.display_duration;
                  }
                  real = items2[m][1].begin - items2[l][1].begin + items2[m][1].duration;
                }
                function to_str(n) {
                  if (64 / n == ~~(64 / n)) {
                    return (~~(64 / n)).toString();
                  } else {
                    return (~~(96 / n)).toString() + ".";
                  }
                }
                let real_str = to_str(real);
                let disp_str = to_str(disp);
                return [real_str, disp_str];
              };
              let prev_tup_id = null;
              for (let m = l - 1; m >= 0; m--) {
                let e = items2[m][1];
                if (e.tuplet) {
                  prev_tup_id = items2[m][1].tuplet.id;
                  break;
                }
              }
              if (!items2[l - 1] || prev_tup_id === null) {
                o += `   tuplet ${items2[l][1].tuplet.label} d${count().join("/")}
`;
              } else if (prev_tup_id !== null && prev_tup_id != items2[l][1].tuplet.id) {
                o += `   end
   tuplet ${items2[l][1].tuplet.label} d${count().join("/")}
`;
              }
            } else if (items2[l - 1] && items2[l - 1][1].tuplet) {
              let next_tup_id = null;
              for (let m = l + 1; m < items2.length; m++) {
                let e = items2[m][1];
                if (e.tuplet) {
                  next_tup_id = items2[m][1].tuplet.id;
                  break;
                }
              }
              if (items2[l - 1][1].tuplet.id != next_tup_id) {
                o += `   end
`;
              }
            }
            if (items2[l][0] == "note") {
              let e = items2[l][1];
              while (e.prev_in_chord !== null) {
                e = staff.notes[e.prev_in_chord];
              }
              let is_chord = e.next_in_chord !== null;
              if (is_chord) o += "    chord\n";
              do {
                items2.find((x) => x[1] == e)[2] = true;
                let s = ["note"];
                s.push(e.name[0] + e.octave);
                if (e.accidental !== null) {
                  s.push(["b", "~", "#"][e.accidental + 1]);
                }
                let dur = e.duration;
                if (e.tuplet) {
                  dur = e.tuplet.display_duration;
                }
                if (e.modifier) {
                  s.push("d" + (96 / dur).toString() + ".");
                } else {
                  s.push("d" + (64 / dur).toString());
                }
                if (e.articulation) {
                  s.push(
                    "a" + (ARTICULATION_SYMBOL[e.articulation] ?? e.articulation)
                  );
                }
                if (e.cue) {
                  s.push(
                    `${["[", "|", "]"][e.cue.position + 1]}'${e.cue.data.replace(/'/g, "\\'")}'`
                  );
                }
                if (e.lyric) {
                  s.push(`l'${e.lyric.replace(/'/g, "\\'")}'`);
                }
                let t = "    ";
                if (is_chord) t += "  ";
                t += s.join(" ");
                if (e.id) {
                  t = t.padEnd(50, " ") + " $" + e.id;
                }
                o += t + "\n";
                e = staff.notes[e.next_in_chord];
              } while (e);
              if (is_chord) o += "    end\n";
            } else if (items2[l][0] == "rest") {
              let e = items2[l][1];
              let dur = e.duration;
              if (e.tuplet) {
                dur = e.tuplet.display_duration;
              }
              o += `    rest d${64 / dur}`;
              if (e.cue) {
                o += ` ${["[", "|", "]"][e.cue.position + 1]}'${e.cue.data.replace(/'/g, "\\'")}'`;
              }
              o += "\n";
            } else if (items2[l][0] == "grace") {
              o += `   grace
`;
              do_items(
                items2[l][1].items
              );
              o += `   end
`;
            } else {
            }
          }
          if (items2[items2.length - 1] && items2[items2.length - 1][1].tuplet) {
            o += `   end
`;
          }
        };
        let items = [];
        for (let l = 0; l < staff.notes.length; l++) {
          if (staff.notes[l].voice == k) {
            items.push(["note", staff.notes[l], false]);
          }
        }
        for (let l = 0; l < staff.rests.length; l++) {
          if (staff.rests[l].voice == k) {
            items.push(["rest", staff.rests[l], false]);
          }
        }
        for (let l = 0; l < staff.grace.length; l++) {
          if (!staff.grace[l]) {
            continue;
          }
          let grace_item = [
            "grace",
            { begin: l - 1e-3, duration: staff.grace[l].duration, items: [] },
            false
          ];
          for (let m = 0; m < staff.grace[l].staves[0].notes.length; m++) {
            let n = staff.grace[l].staves[0].notes[m];
            if (n.voice == k) {
              grace_item[1].items.push(["note", n, false]);
            }
          }
          for (let m = 0; m < staff.grace[l].staves[0].rests.length; m++) {
            let n = staff.grace[l].staves[0].rests[m];
            if (n.voice == k) {
              grace_item[1].items.push(["rest", n, false]);
            }
          }
          grace_item[1].items.sort(
            (a, b) => a[1].begin - b[1].begin
          );
          if (grace_item[1].items.length) items.push(grace_item);
        }
        items.sort((a, b) => a[1].begin - b[1].begin);
        if (staff.voices > 1) {
          o += "   voice\n";
        }
        do_items(items);
        if (staff.voices > 1) {
          o += "   end\n";
        }
      }
      o += `  end
`;
    }
    o += `end
`;
  }
  for (let i2 = 0; i2 < score2.slurs.length; i2++) {
    let slur = score2.slurs[i2];
    if (slur.is_tie) {
      o += `tie $${slur.left} $${slur.right}
`;
    } else {
      o += `slur $${slur.left} $${slur.right}
`;
    }
  }
  for (let i2 = 0; i2 < score2.crescs.length; i2++) {
    let cresc = score2.crescs[i2];
    o += `cresc ${cresc.val_left} ${cresc.val_right} $${cresc.left} $${cresc.right}
`;
  }
  return o;
}

// src/cli.ts
var build_date = "2025-07-03";
function print_help() {
  console.log(`legumes: render sheet music => polylines`);
  console.log(`(build ${build_date})
`);
  console.log(`usage:
`);
  console.log(`legc [options] file.(txt|mid) > output.ext
`);
  console.log(`options:
`);
  console.log("--format pdf|svg|gif|json|txt|mid|      Output format");
  console.log("         svg-mock|svg-anim|svg-hand     ");
  console.log("--font   font.json                      Custom Hershey font");
  console.log("--config config.json                    Configuration file, OR");
  console.log("                                        as below arguments:\n");
  let o = "";
  let nl = false;
  let keys = Object.keys(CONFIG).sort();
  for (let k of keys) {
    let t = "--" + k.toLowerCase().replace(/_/g, "-");
    let v = Number(CONFIG[k]).toString();
    let l = 37 - t.length - v.length;
    o += t + " ".repeat(l) + v;
    if (nl) {
      console.log(o);
      o = "";
    } else {
      o += "     ";
    }
    nl = !nl;
  }
  if (o.length) {
    console.log(o);
  }
}
if (process.argv.length <= 2) {
  print_help();
  process.exit(0);
}
var i = 2;
var input_path;
var inp_format = "txt";
var out_format = "pdf";
while (i < process.argv.length) {
  if (process.argv[i] == "--help" || process.argv[i] == "-h") {
    print_help();
    process.exit(0);
  } else if (process.argv[i] == "--version" || process.argv[i] == "-v") {
    console.log(build_date);
    process.exit(0);
  } else if (process.argv[i] == "--format") {
    out_format = process.argv[i + 1];
    i += 2;
  } else if (process.argv[i] == "--config") {
    Object.assign(
      CONFIG,
      JSON.parse(import_fs.default.readFileSync(process.argv[i + 1]).toString())
    );
    i += 2;
  } else if (process.argv[i] == "--font") {
    let font = JSON.parse(import_fs.default.readFileSync(process.argv[i + 1]).toString());
    register_font(font.cmap, font.data, font.scale ?? 1);
    i += 2;
  } else if (process.argv[i].slice(0, 2) == "--") {
    let k = process.argv[i].slice(2).toUpperCase().replace(/-/g, "_");
    let v = Number(process.argv[i + 1]);
    if (CONFIG[k] === void 0) {
      console.error("unrecognized option: " + process.argv[i]);
      process.exit(1);
    }
    if (isNaN(v)) {
      console.error(
        `invalid value for option '${process.argv[i]}': ${process.argv[i + 1]}`
      );
      process.exit(1);
    }
    CONFIG[k] = v;
    i += 2;
  } else {
    input_path = process.argv[i];
    i++;
  }
}
if (!input_path) {
  console.error("no input file.");
  process.exit(1);
}
var input = import_path.default.parse(input_path);
if (input.ext != ".txt" && input.ext != ".mid") {
  console.error(`unsupported file format '${input.ext}'`);
  process.exit(1);
} else {
  inp_format = input.ext.slice(1);
}
var score;
if (inp_format == "mid") {
  const bytes = Array.from(new Uint8Array(import_fs.default.readFileSync(input_path)));
  const midi_file = parse_midi(bytes);
  score = score_from_midi(midi_file);
} else if (inp_format == "txt") {
  const txt = import_fs.default.readFileSync(input_path).toString();
  score = parse_txt(txt);
}
score = compile_score(score);
var drawing;
if (out_format == "txt") {
  const txto = export_txt(score);
  console.log(txto);
  process.exit(0);
} else {
  drawing = render_score(score);
  round_polylines(drawing.polylines, 2);
}
if (out_format == "json") {
  console.dir({ score, drawing }, { depth: null, maxArrayLength: Infinity });
} else if (out_format == "svg") {
  console.log(export_svg(drawing));
} else if (out_format == "pdf") {
  console.log(export_pdf(drawing));
} else if (out_format == "svg-mock") {
  console.log(export_mock_svg(drawing));
} else if (out_format == "svg-anim") {
  console.log(export_animated_svg(drawing));
} else if (out_format == "svg-hand") {
  console.log(export_sketch_svg(drawing));
} else if (out_format == "mid") {
  let midi_file = score_to_midi(score);
  let bytes = export_midi(midi_file);
  process.stdout.write(Buffer.from(bytes));
} else if (out_format == "gif") {
  let bytes = export_gif(drawing);
  process.stdout.write(Buffer.from(bytes));
} else {
  console.error("unrecognized output format: " + out_format);
  process.exit(1);
}
